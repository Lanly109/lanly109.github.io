<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MILP-StuDio</title>
      <link href="/posts/b5f500a.html"/>
      <url>/posts/b5f500a.html</url>
      
        <content type="html"><![CDATA[<h2 id="摘要"><a class="markdownIt-Anchor" href="#摘要"></a> 摘要</h2><p>混合整数线性规划（MILP）具有广泛的应用。在实际中，改进 MILP 求解器的性能通常需要大量高质量数据，这些数据往往难以收集。研究人员转向生成技术来生成额外的 MILP 实例，但现有的方法没有考虑到约束系数矩阵（CCM）中的特定块结构，这些结构与问题表述密切相关。因此，它们容易生成计算上简单或不可行的实例。为了解决这一挑战，本文提出了一个新的 MILP 生成框架，称为块结构分解（MILP-StuDio），通过保留块结构来生成高质量实例。</p><p>具体来说，MILP-StuDio 通过识别 CCM 中的块并将其分解为块单元开始，这些块单元作为 MILP 实例的构建块。然后通过设计三种操作来通过删除、替换和追加块单元来构造新实例，能够生成灵活大小的实例。MILP-StuDio 的一个吸引人的特点是其强大的能力，能够保持生成实例的可行性和计算难度。在常用基准上的实验表明，使用 MILP-StuDio 生成的实例，基于学习的求解器能够显著减少超过 10% 的求解时间。</p><h2 id="方法"><a class="markdownIt-Anchor" href="#方法"></a> 方法</h2><h3 id="milp的块结构"><a class="markdownIt-Anchor" href="#milp的块结构"></a> MILP的块结构</h3><p>MILP 问题的约束系数矩阵（CCM）是一个稀疏矩阵，它包含了问题的所有约束和变量。CCM 的块结构是指 CCM 中的子矩阵，这些子矩阵具有相同的非零元素模式。MILP 问题的块结构反映了问题的结构，例如哪些变量和约束是相关的。</p><p><img src="image-20250307155506826.png" alt="image-20250307155506826" /></p><p>上图是4个问题（combinatorial auctions (CA), item placement (IP), multiple knapsacks (MIK), and workload balancing (WA)）的CCM矩阵通过排列后得到的附有规律的图，行是约束，列是变量，白色像素代表其系数不为0。</p><h3 id="现有生成实例方法的问题"><a class="markdownIt-Anchor" href="#现有生成实例方法的问题"></a> 现有生成实例方法的问题</h3><p>本文主要比较另外两个基线方法：Bowly和G2MILP，通过可视化的方法展现出它们的生成实例的问题。</p><ul><li>Bowly 是一种基于统计的 MILP 实例生成方法，旨在通过控制特定的统计特征来生成与原始实例具有相似统计属性的新实例。具体来说，Bowly 方法通过调整系数密度和系数均值等统计特征，生成与原始实例在统计上相似的 MILP 实例。</li><li>G2MILP 是一种基于学习的 MILP 实例生成框架，利用深度学习模型来捕获全局实例特征，并通过迭代修改原始实例中的约束来生成新实例。G2MILP 的核心思想是通过掩码变分自编码器（VAE）来逐步替换和修改原始实例的约束节点，从而生成新的实例。</li></ul><p><img src="image-20250307155909239.png" alt="image-20250307155909239" /></p><p><img src="image-20250307155926437.png" alt="image-20250307155926437" /></p><p><img src="image-20250307155936781.png" alt="image-20250307155936781" /></p><p><img src="image-20250307155945244.png" alt="image-20250307155945244" /></p><p>从可视化结果可以看出来，这两种方法会都会破坏原有实例的块结构，使得生成出来的实例与原实例不相似，从而影响了下游的学习任务的效果。</p><h3 id="块分解"><a class="markdownIt-Anchor" href="#块分解"></a> 块分解</h3><p>MILP-StuDio 的核心是块结构分解，通过重新排列 CCM 的行和列来识别块结构。</p><p><img src="image-20250307161333161.png" alt="image-20250307161333161" /></p><p>本文首先通过 GCG （<a href="https://gcg.or.rwth-aachen.de/doc-3.5.0/index.html">Generic Column Generation</a>）求解器中的结构检测器来重新排列 CCM，进行初步分块。然后再使用以下算法进一步分解特定块。这个算法能够处理比 GCG 更复杂的块结构，例如在 WA 中具有 M-Cons、B-Cons 和 BD-Cons 的实例。</p><p><img src="image-20250307161505183.png" alt="image-20250307161505183" /></p><p><img src="image-20250307161741214.png" alt="image-20250307161741214" /></p><p>该算法是包含了超参数的分割算法，用于区分出D、F、B等变量和约束，基于以下观察设计的：</p><ul><li><p>对于CCM中的行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>m</mi><mo>×</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">A\in\mathbb{R}^{m\times n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.771331em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span>：</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mtext>max</mtext></msub></mrow><annotation encoding="application/x-tex">x_{\text{max}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">max</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是非零系数的最大 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span> 坐标</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mtext>min</mtext></msub></mrow><annotation encoding="application/x-tex">x_{\text{min}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31750199999999995em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">min</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是非零系数的最小 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span> 坐标</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">h_x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是该行非零系数的数量</li></ul><p>对于CCM中的列：</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mtext>max</mtext></msub></mrow><annotation encoding="application/x-tex">y_{\text{max}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">max</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是非零系数的最大 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 坐标</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mtext>min</mtext></msub></mrow><annotation encoding="application/x-tex">y_{\text{min}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31750199999999995em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">min</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是非零系数的最小 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 坐标</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mi>y</mi></msub></mrow><annotation encoding="application/x-tex">h_y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 是该列非零系数的数量</li></ul><p>观察结果：</p><ul><li><p><strong>M-Con 行特征</strong><br />非零系数具有大范围的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>-索引：<br /><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∙</mo></mrow><annotation encoding="application/x-tex">\bullet</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord">∙</span></span></span></span> 较大的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mtext>max</mtext></msub><mo>−</mo><msub><mi>x</mi><mtext>min</mtext></msub></mrow><annotation encoding="application/x-tex">x_{\text{max}} - x_{\text{min}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">max</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31750199999999995em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">min</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br /><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∙</mo></mrow><annotation encoding="application/x-tex">\bullet</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord">∙</span></span></span></span> 较高的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>坐标标准差（standard deviation）</p></li><li><p><strong>B-Con 行特征</strong><br />非零系数具有较窄的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>-索引范围：<br /><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∙</mo></mrow><annotation encoding="application/x-tex">\bullet</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord">∙</span></span></span></span> 较小的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mtext>max</mtext></msub><mo>−</mo><msub><mi>x</mi><mtext>min</mtext></msub></mrow><annotation encoding="application/x-tex">x_{\text{max}} - x_{\text{min}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">max</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31750199999999995em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">min</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br /><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∙</mo></mrow><annotation encoding="application/x-tex">\bullet</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord">∙</span></span></span></span> 较低的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>坐标标准差</p></li><li><p><strong>Bd-Var 列特征</strong><br />非零系数具有：<br /><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∙</mo></mrow><annotation encoding="application/x-tex">\bullet</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord">∙</span></span></span></span> 广泛的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>-索引（较大的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mtext>max</mtext></msub><mo>−</mo><msub><mi>y</mi><mtext>min</mtext></msub></mrow><annotation encoding="application/x-tex">y_{\text{max}} - y_{\text{min}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">max</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31750199999999995em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">min</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>）<br /><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∙</mo></mrow><annotation encoding="application/x-tex">\bullet</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord">∙</span></span></span></span> 高密度（列中非零比例 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mi>y</mi></msub><mi mathvariant="normal">/</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">h_y/m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord mathnormal">m</span></span></span></span> 较大）</p></li><li><p><strong>DB-Cons 定义</strong><br />包含 Bd-Vars 的约束条件</p></li></ul></li></ul><h3 id="结构库构建"><a class="markdownIt-Anchor" href="#结构库构建"></a> 结构库构建</h3><p>通过上述分解得到的基本块，构建相应的二分子图，并利用这些子图来构建结构库。这个结构库作为块单元的存储库，允许高效地存储、检索和利用块信息。</p><h3 id="块操作"><a class="markdownIt-Anchor" href="#块操作"></a> 块操作</h3><p>三种块操作来生成新实例：减少、混合和扩展。</p><ul><li>减少操作涉及从原始实例中随机采样一个块单元并删除它；</li><li>混合操作涉及从原始实例中随机采样一个块单元，并从结构库 L 中随机采样另一个块单元，然后用后者替换前者；</li><li>扩展操作涉及从结构库 L 中随机采样一个块单元并将其附加到原始实例中。</li></ul><h2 id="实验"><a class="markdownIt-Anchor" href="#实验"></a> 实验</h2><h3 id="实验设置"><a class="markdownIt-Anchor" href="#实验设置"></a> 实验设置</h3><p>我们在四个 MILP 问题基准上进行实验：组合拍卖（CA）、有容量的设施选址（FA）、物品放置（IP）和工作负载分配（WA）。我们使用三个指标来评估原始和生成实例之间的相似性：图统计、计算难度和可行比率。我们考虑了两种基线：基于统计的 MILP 生成方法 Bowly 和基于学习的方法 G2MILP.</p><h3 id="实验结果"><a class="markdownIt-Anchor" href="#实验结果"></a> 实验结果</h3><h4 id="相似性"><a class="markdownIt-Anchor" href="#相似性"></a> 相似性</h4><p>MILP-StuDio 在图结构分布相似性得分方面显著高于基线方法。随着修改比率的增加，MILP-StuDio 的相似性得分下降幅度较小，而 G2MILP 的相似性得分下降幅度较大。</p><h4 id="计算硬度和可行性"><a class="markdownIt-Anchor" href="#计算硬度和可行性"></a> 计算硬度和可行性</h4><p>MILP-StuDio 生成的实例在计算硬度和可行性方面与原始实例非常接近，而基线方法生成的实例在计算硬度方面显著退化，且 G2MILP 在 FA 和 WA 数据集上的大部分实例不可行。</p><h4 id="改进学习求解器"><a class="markdownIt-Anchor" href="#改进学习求解器"></a> 改进学习求解器</h4><p>MILP-StuDio 生成的实例显著提高了学习求解器的性能，包括基于预测和搜索的 PS 方法和基于学习的分支方法。例如，在 CA 和 FA 数据集上，PS 方法在 MILP-StuDio 生成的实例上达到与原始实例相同的解，且求解时间更短；在 IP 和 WA 数据集上，MILP-StuDio 生成的实例使得 PS 方法达到更小的绝对原始间隙。</p><p><img src="image-20250307162458508.png" alt="image-20250307162458508" /></p><h4 id="生成效率"><a class="markdownIt-Anchor" href="#生成效率"></a> 生成效率</h4><p>MILP-StuDio 在生成效率方面显著优于 G2MILP，尤其是在处理大规模实例时。</p><h2 id="结论"><a class="markdownIt-Anchor" href="#结论"></a> 结论</h2><p>我们提出了一个新的 MILP 生成框架 MILP-StuDio，通过块结构分解来生成高质量的 MILP 实例。MILP-StuDio 能够有效地保持生成实例的计算硬度和可行性，具有强大的可扩展生成能力和高效率。实验表明，MILP-StuDio 在提高学习求解器性能方面非常有效。</p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SCIP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用Github Actions实现UnityCI构建</title>
      <link href="/posts/b5c76f33.html"/>
      <url>/posts/b5c76f33.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>通过<code>Github Actions</code>实现Unity的持续集成构建，便捷构建的同时进行多平台构建。</p></blockquote><p>参考资料：<a href="https://game.ci/docs/github/activation/#license-server">GameCI</a></p><h2 id="总命令"><a class="markdownIt-Anchor" href="#总命令"></a> 总命令</h2><p>我用的是个人许可证，因此在<code>Github</code>对应仓库的<code>Secrets and Variables &gt; Actions</code>添加以下三个变量：</p><ul><li><code>UNITY_LICENSE</code>：Unity的<code>.ulf</code>文件内容</li><li><code>UNITY_EMAIL</code>：Unity账号邮箱</li><li><code>UNITY_PASSWORD</code>：Unity账号密码</li></ul><p>其中<code>UNITY_LICENSE</code>是需要下载<code>Unity Hub</code>并登录创建一个许可证，创建好后将许可证内容作为<code>UNITY_LICENSE</code>的值。其路径为：</p><ul><li>Windows: C:\ProgramData\Unity\Unity_lic.ulf</li><li>Mac: /Library/Application Support/Unity/Unity_lic.ulf</li><li>Linux: ~/.local/share/unity3d/Unity/Unity_lic.ulf</li></ul><p>然后在<code>.github/workflows/build.yml</code>创建<code>workflow</code>文件。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">name: Build project</span><br><span class="line"></span><br><span class="line">on:</span><br><span class="line">  push:</span><br><span class="line">    branches:</span><br><span class="line">      - <span class="string">&#x27;**&#x27;</span>  <span class="comment"># 所有分支</span></span><br><span class="line">  pull_request:</span><br><span class="line">    branches:</span><br><span class="line">      - <span class="string">&#x27;**&#x27;</span>  <span class="comment"># 所有分支</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">env</span>:</span><br><span class="line">  UNITY_LICENSE: <span class="variable">$&#123;&#123; secrets.UNITY_LICENSE &#125;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">jobs</span>:</span><br><span class="line">  buildForSomePlatforms:</span><br><span class="line">    name: Build <span class="keyword">for</span> <span class="variable">$&#123;&#123; matrix.targetPlatform &#125;</span>&#125; on version <span class="variable">$&#123;&#123; matrix.unityVersion &#125;</span>&#125;</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    strategy:</span><br><span class="line">      fail-fast: <span class="literal">false</span></span><br><span class="line">      matrix:</span><br><span class="line">        buildName:</span><br><span class="line">          - Game</span><br><span class="line">        projectPath:</span><br><span class="line">          - ./</span><br><span class="line">        unityVersion:</span><br><span class="line">          - 2021.3.27f1</span><br><span class="line">        targetPlatform:</span><br><span class="line">          - StandaloneOSX <span class="comment"># Build a macOS standalone (Intel 64-bit).</span></span><br><span class="line">          - StandaloneWindows64 <span class="comment"># Build a Windows 64-bit standalone.</span></span><br><span class="line">          - StandaloneLinux64 <span class="comment"># Build a Linux 64-bit standalone.</span></span><br><span class="line">          - iOS <span class="comment"># Build an iOS player.</span></span><br><span class="line">          - Android <span class="comment"># Build an Android .apk standalone app.</span></span><br><span class="line">          - WebGL <span class="comment"># WebGL.</span></span><br><span class="line"></span><br><span class="line">    steps:</span><br><span class="line">      - uses: actions/checkout@v2</span><br><span class="line">        with:</span><br><span class="line">          lfs: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># 获取当前分支的提交哈希值</span></span><br><span class="line">      - name: Get Git Commit Hash</span><br><span class="line">        <span class="built_in">id</span>: get_commit_hash</span><br><span class="line">        run: <span class="built_in">echo</span> <span class="string">&quot;::set-output name=hash::<span class="subst">$(git rev-parse --short HEAD)</span>&quot;</span></span><br><span class="line"></span><br><span class="line">      - uses: actions/cache@v3</span><br><span class="line">        with:</span><br><span class="line">          path: Library</span><br><span class="line">          key: Library-<span class="variable">$&#123;&#123; matrix.targetPlatform &#125;</span>&#125;</span><br><span class="line">          restore-keys: Library-</span><br><span class="line"></span><br><span class="line">      - <span class="keyword">if</span>: matrix.targetPlatform == <span class="string">&#x27;Android&#x27;</span></span><br><span class="line">        uses: jlumbroso/free-disk-space@v1.3.1</span><br><span class="line"></span><br><span class="line">      - uses: game-ci/unity-builder@v4</span><br><span class="line">        <span class="built_in">env</span>:</span><br><span class="line">          UNITY_LICENSE: <span class="variable">$&#123;&#123; secrets.UNITY_LICENSE &#125;</span>&#125;</span><br><span class="line">          UNITY_EMAIL: <span class="variable">$&#123;&#123; secrets.UNITY_EMAIL &#125;</span>&#125;</span><br><span class="line">          UNITY_PASSWORD: <span class="variable">$&#123;&#123; secrets.UNITY_PASSWORD &#125;</span>&#125;</span><br><span class="line">        with:</span><br><span class="line">          unityVersion: <span class="variable">$&#123;&#123; matrix.unityVersion &#125;</span>&#125;</span><br><span class="line">          targetPlatform: <span class="variable">$&#123;&#123; matrix.targetPlatform &#125;</span>&#125;</span><br><span class="line">          versioning: Custom</span><br><span class="line">          version: <span class="variable">$&#123;&#123; steps.get_commit_hash.outputs.hash &#125;</span>&#125;</span><br><span class="line"></span><br><span class="line">      - name: Upload Build Artifact</span><br><span class="line">        uses: actions/upload-artifact@v3</span><br><span class="line">        with:</span><br><span class="line">          name: <span class="variable">$&#123;&#123; matrix.buildName &#125;</span>&#125;_<span class="variable">$&#123;&#123; matrix.targetPlatform &#125;</span>&#125;</span><br><span class="line">          path: build/<span class="variable">$&#123;&#123; matrix.targetPlatform &#125;</span>&#125;</span><br></pre></td></tr></table></figure><p>上述代码是一个多平台构建的<code>workflow</code>文件，指定了<code>Unity</code>的版本，缓存文件，会构建多平台的<code>Unity</code>项目，在有任意修改提交时触发构建，版本号为提交哈希值。</p><p>关于<code>unity-builder</code>参数可参考<a href="https://game.ci/docs/github/builder">GameCI Builder</a></p><p>构建平台的取值可参考<a href="https://docs.unity3d.com/ScriptReference/BuildTarget.html">Unity BuildTarget</a></p>]]></content>
      
      
      <categories>
          
          <category> 环境部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github </tag>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vim使用记录</title>
      <link href="/posts/6719ba1e.html"/>
      <url>/posts/6719ba1e.html</url>
      
        <content type="html"><![CDATA[<h2 id="将文件换行符格式批量改成unix格式"><a class="markdownIt-Anchor" href="#将文件换行符格式批量改成unix格式"></a> 将文件换行符格式批量改成unix格式</h2><p>有些测试数据需要确保是<code>unix</code>格式的换行符<code>\n</code>，而非<code>windows</code>的<code>\r\n</code>，因此需要批量更改。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim +<span class="string">&quot;argdo set ff=unix | update&quot;</span> *.&#123;<span class="keyword">in</span>,out&#125;</span><br></pre></td></tr></table></figure><p><code>+</code>表示在vim启动后立刻执行以下指令，<code>argdo</code>指对参数文件（即<code>*.&#123;in,out&#125;</code>所匹配到的<code>.in .out</code>文件）执行以下指令：</p><ul><li><code>set ff=unix</code> 将换行符格式更改为<code>unix</code>格式</li><li><code>update</code> 将文件更新<br />中间用<code>|</code>分割不同命令</li></ul>]]></content>
      
      
      <categories>
          
          <category> 经验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>科研工具</title>
      <link href="/posts/7c69d6fd.html"/>
      <url>/posts/7c69d6fd.html</url>
      
        <content type="html"><![CDATA[<h2 id="趋势关注"><a class="markdownIt-Anchor" href="#趋势关注"></a> 趋势关注</h2><h3 id="rss-阅读器"><a class="markdownIt-Anchor" href="#rss-阅读器"></a> RSS 阅读器</h3><ul><li><a href="http://irreader.fatecore.com/">irreader 阅读器</a>：这是我现在在使用的 RSS 阅读器。一个非常大的优点是，对于一些没有提供 RSS 订阅源的网站，irreader 可以自定义 RSS 订阅源。另外，订阅的 RSS 更新时，有弹窗提醒。还有一个我暂时用不到的功能是，irreader 同时支持订阅播客和播放有声媒体。</li></ul><h2 id="论文查找"><a class="markdownIt-Anchor" href="#论文查找"></a> 论文查找</h2><h3 id="搜索引擎"><a class="markdownIt-Anchor" href="#搜索引擎"></a> 搜索引擎</h3><ul><li><p><a href="https://dblp.org/">dblp: computer science bibliography</a>：专为 CS 设计的论文查询网站，收录比较顶级并可以被检索到的论文。可以根据会议、期刊等分类查询作者的论文，想搜一个计算机会议的所有文章时好用。</p></li><li><p><a href="https://scholar.google.com/schhp?hl=zh-CN">Google scholar</a>：除开搜索论文之外，可以在这里查看论文统计和引用参考文献，还能通过关注作者或者论文获得新论文更新提醒，以及利用自动化推荐来提供一个基本库。</p></li><li><p><a href="https://www.semanticscholar.org/">Semantic scholar</a>：可以结合外部材料整合进行论文的语义分析。功能包括：展示引用和参考文献、度量论文影响力、展示论文图表、自动生成关键词（根据标题）、分析作者、在互联网寻找额外资源（例如，相关 youtube 视频），以及推荐论文。</p></li></ul><h3 id="arxiv-相关"><a class="markdownIt-Anchor" href="#arxiv-相关"></a> arXiv 相关</h3><ul><li><p><a href="https://arxiv.org/">arXiv</a>: 论文预印本收录网站。</p></li><li><p><a href="http://arxiv-sanity.com/">arXiv-sanity</a>：在功能上相比于 arXiv 有很大的改进，包括在浏览中显示摘要、评论和非常基本的社交、推荐、库功能。搜索也更好用。</p></li><li><p><a href="https://s2-sanity.apps.allenai.org">Semantic Sanity: A Personalized Adaptive Feed</a>：创建自己的个性化 arXiv 选读 Feed。创建每个 Feed 时，会让您先选择几篇论文，然后根据这几篇论文开始推荐，对于推荐结果可以点赞或者不喜欢来帮助调整推荐结果。</p></li><li><p><a href="https://www.paperdigest.org/">Paper Digest – AI for tracking and summarizing papers</a>: 提供邮件订阅前一天出的论文的列表，附有每篇论文的一句话总结。对我更重要的是这个网站也会在每个顶会论文全部公布时进行整理。</p></li></ul><h3 id="代码实现查找"><a class="markdownIt-Anchor" href="#代码实现查找"></a> 代码实现查找</h3><ul><li><p><a href="https://paperswithcode.com/">Papers With Code</a>：自动把论文连接到实现代码的 GitHub 资源库和数据集，并根据 GitHub 的收藏量排序。展示各任务上的 SOTA 以供比较。</p></li><li><p><a href="https://github.com/labmlai/annotated_deep_learning_paper_implementations">labmlai/annotated_deep_learning_paper_implementations</a>：很多算法的 PyTorch 实现，带有在线版的注释。缺点是展示的部分不是从头实现，一部分代码放在他们自己的包里了。</p></li></ul><h2 id="论文阅读"><a class="markdownIt-Anchor" href="#论文阅读"></a> 论文阅读</h2><h3 id="查阅下载"><a class="markdownIt-Anchor" href="#查阅下载"></a> 查阅下载</h3><ul><li><a href="http://tool.yovisun.com/scihub/">SCI-Hub 科研论文全文下载可用网址</a></li></ul><h3 id="文献管理"><a class="markdownIt-Anchor" href="#文献管理"></a> 文献管理</h3><ul><li><a href="https://www.zotero.org/">Zotero</a>：能够对文献数据库网页中的文献题录直接抓取，与<a href="https://www.jianguoyun.com/">坚果云</a>配合使用，来实现文献管理多端同步（支持MacOS、Windows、iPad、Linux、iOS）。</li></ul><h3 id="阅读助手"><a class="markdownIt-Anchor" href="#阅读助手"></a> 阅读助手</h3><ul><li><p><a href="https://chatgpt.com/">ChatGPT</a>：元老级产品。</p></li><li><p><a href="https://kimi.moonshot.cn/">Kimi Chat</a>：类 ChatPGT 产品，读pdf很方便。</p></li><li><p><a href="https://papers.cool/">Cool Papers</a>：苏剑林大佬开发的刷论文网站。可根据 <a href="https://github.com/bojone/papers.cool">README</a> 自行探索使用。</p></li></ul><h3 id="文献翻译"><a class="markdownIt-Anchor" href="#文献翻译"></a> 文献翻译</h3><ul><li><a href="https://bobtranslate.com">Bob</a>：体验很好，框住文字即可翻译。</li></ul><h3 id="笔记工具"><a class="markdownIt-Anchor" href="#笔记工具"></a> 笔记工具</h3><h2 id="编码实验"><a class="markdownIt-Anchor" href="#编码实验"></a> 编码实验</h2><h3 id="pytorch-相关"><a class="markdownIt-Anchor" href="#pytorch-相关"></a> Pytorch 相关</h3><h4 id="功能配置封装"><a class="markdownIt-Anchor" href="#功能配置封装"></a> 功能配置封装</h4><ul><li><a href="https://github.com/williamFalcon/pytorch-lightning">pytorch-lightning</a>：将 PyTorch 开发中的各种通用配置（训练验证逻辑、超参搜索、分布式训练等）全部包装起来，以更高级的形式快速搭建模型。功能强大，有些复杂，正在摸索。<a href="https://mp.weixin.qq.com/s/5ueJvt1tcWW0wknpkM3WIg">机器之心写的简介</a></li></ul><h4 id="项目参考"><a class="markdownIt-Anchor" href="#项目参考"></a> 项目参考</h4><ul><li><p><a href="https://github.com/ritchieng/the-incredible-pytorch">the-incredible-pytorch</a>：有关 PyTorch 的各种教程、项目、视频等资源。</p></li><li><p><a href="https://github.com/microsoft/computervision-recipes">computervision-recipes</a>：微软出品，基于 PyTorch 的各种 CV 任务的教程。</p></li></ul><!-- * [donnyyou/torchcv](https://github.com/donnyyou/torchcv)：基于 PyTorch 的 CV 模型框架，包含图像分类、语义分割、目标检测、姿态检测、实例分割、生成对抗网络等任务中的多个常见模型。 --><h4 id="项目管理"><a class="markdownIt-Anchor" href="#项目管理"></a> 项目管理</h4><ul><li><a href="https://oidiotlin.com/torchtracer/">torchtracer</a>：一个管理 PyTorch AI 实验项目的工具，主要用于保存各类训练数据（模型 checkpoints、超参数组合、日志、loss 变化曲线图像等）。</li></ul><h4 id="风格指南"><a class="markdownIt-Anchor" href="#风格指南"></a> 风格指南</h4><ul><li><a href="https://github.com/IgorSusmelj/pytorch-styleguide">pytorch-styleguide</a>：一份 PyTorch 的非官方风格指南和最佳实践总结。</li></ul><h4 id="项目模板"><a class="markdownIt-Anchor" href="#项目模板"></a> 项目模板</h4><ul><li><p><a href="https://github.com/moemen95/Pytorch-Project-Template">Pytorch-Project-Template</a>：一个可扩展的 PyTorch 项目模板，包括图像分割、目标分类、GANs 和强化学习等实例。</p></li><li><p><a href="https://github.com/lyakaap/pytorch-template">pytorch-template</a>：另一份 PyTorch 项目模板。</p></li></ul><h4 id="神经网络分析器"><a class="markdownIt-Anchor" href="#神经网络分析器"></a> 神经网络分析器</h4><ul><li><p><a href="https://github.com/TylerYep/torchinfo">torchinfo</a>：打印 PyTorch 模型信息，包含模型每层的参数量、输出张量大小等。</p></li><li><p><a href="https://github.com/sovrasov/flops-counter.pytorch">flops-counter.pytorch</a>：计算模型总共的 FLOPs（浮点运算数，理解为计算量，可以用来衡量算法/模型的复杂度）以及每层的占比。缺点是似乎不支持 RNN 相关层，另外打印下来的信息不是很方便看。</p></li></ul><h4 id="可视化"><a class="markdownIt-Anchor" href="#可视化"></a> 可视化</h4><ul><li><p>PyTorch 最新版本已经带有 tensorboard。<a href="https://pytorch.org/tutorials/intermediate/tensorboard_tutorial.html">官方 tutorial</a>。</p></li><li><p><a href="https://github.com/facebookresearch/visdom">visdom</a>：【待尝试】用于创建、组织和共享实时丰富数据可视化的灵活工具。</p></li><li><p><a href="https://ezyang.github.io/convolution-visualizer/index.html">Convolution Visualizer</a>：如果卷积层配置比较复杂，不方便计算输出大小时，可以利用这个可视化工具辅助。</p></li></ul><h3 id="实验记录"><a class="markdownIt-Anchor" href="#实验记录"></a> 实验记录</h3><ul><li><a href="https://github.com/fastnlp/fitlog">fitlog</a>：【待尝试】架构无关的实验记录工具，可以看<a href="https://www.zhihu.com/question/384519338/answer/1181186086">邱锡鹏老师在知乎写的介绍</a>。</li></ul><h3 id="数据集查找"><a class="markdownIt-Anchor" href="#数据集查找"></a> 数据集查找</h3><ul><li><p><a href="https://toolbox.google.com/datasetsearch">Google Dataset Search</a></p></li><li><p><a href="https://datasets.bifrost.ai/">Data Search | Bifrost</a>：视觉数据集搜索。</p></li></ul><h3 id="数据集下载"><a class="markdownIt-Anchor" href="#数据集下载"></a> 数据集下载</h3><ul><li><a href="https://github.com/wkentaro/gdown">gdown</a>：用于解决在 Google Drive 上下载大型数据集常发生的失败现象。</li></ul><h3 id="特征工程"><a class="markdownIt-Anchor" href="#特征工程"></a> 特征工程</h3><ul><li><a href="https://github.com/featuretools/featuretools">Featuretools</a>：【待尝试】自动化特征工程库。</li></ul><h3 id="超参搜索"><a class="markdownIt-Anchor" href="#超参搜索"></a> 超参搜索</h3><ul><li><p><a href="https://github.com/optuna/optuna">optuna</a>：自动超参数优化框架。</p></li><li><p><a href="https://github.com/microsoft/nni/blob/master/README_zh_CN.md">microsoft/nni</a>：【待尝试】用于神经模型搜索和超参数调优的开源自动机器学习（AutoML）的工具包，支持绝大多数主流框架和运行环境。</p></li><li><p><a href="http://hyperopt.github.io/hyperopt/">Hyperopt</a>：【待尝试】分布式异步超参数优化。看到知乎上有人推荐，不过根据文档来看，目前支持的优化算法只有两种，且不包括贝叶斯优化。</p></li><li><p><a href="https://github.com/pytorch/botorch">BoTorch</a>：【待尝试】基于 PyTorch 的贝叶斯优化库。</p></li><li><p><a href="https://github.com/automl/Auto-PyTorch">automl/Auto-PyTorch</a>：【待尝试】基于 PyTorch 的自动结构搜素和超参数搜索。</p></li></ul><!-- ### Debug 工具* [PySnooper](https://github.com/cool-RR/pysnooper)：【待尝试】致力让用户抛弃`print`函数来 debug（然而，至少目前我还是习惯用 logging 模块，和`print`差不了多少）。[机器之心写的简介](https://mp.weixin.qq.com/s?__biz=MzA3MzI4MjgzMw==&mid=2650760939&idx=1&sn=5b69c106549f329f83ca241e1bc71ff3&chksm=871aa295b06d2b83deade4fc16f99ed5354572c8838d202d0a229d804bb535815f2315d980d0&scene=0&xtrack=1&key=6854b25c2a023c1b259671991171b31fab8ca8f0b3be42cfe9746f0ac6a97af337c3f692988c69af5813e1658308b6087dc66c1d1f218619aab29c7d02dfc8b005eff42eea7fcb837022e321727f14b5&ascene=1&uin=MjA1ODkwNzIyNw%3D%3D&devicetype=Windows+10&version=62060739&lang=zh_CN&pass_ticket=5JdoVuTltfAvWg%2FaBYq40SvnVT0xZhhRK9fPaxA3iu2MgoceoLJpRqamQ9gnBuY2) --><h2 id="论文写作"><a class="markdownIt-Anchor" href="#论文写作"></a> 论文写作</h2><h3 id="latex-模板"><a class="markdownIt-Anchor" href="#latex-模板"></a> LaTeX 模板</h3><p>包括论文、报告、海报等在内的各种 LaTeX 模板。</p><ul><li><p><a href="https://www.overleaf.com/latex/templates">Templates from Overleaf</a></p></li><li><p><a href="http://www.latextemplates.com/">LaTeX Templates</a></p></li></ul><h3 id="latex-编辑器"><a class="markdownIt-Anchor" href="#latex-编辑器"></a> LaTeX 编辑器</h3><p>多人协作推荐 Overleaf，也是我绝大多数时候的选择。单人项目可以使用 VSCode 进行离线的 LaTeX 写作，配合 Github 私有库进行版本管理。</p><ul><li><a href="https://www.overleaf.com/">Overleaf</a>：支持多人协作的<strong>在线</strong> LaTeX 编辑器。但是对网络连接有一定要求。</li></ul><h3 id="语言表达"><a class="markdownIt-Anchor" href="#语言表达"></a> 语言表达</h3><h4 id="搭配查找"><a class="markdownIt-Anchor" href="#搭配查找"></a> 搭配查找</h4><p>可以看一下这篇文章的推荐：<a href="https://zhuanlan.zhihu.com/p/35396232">有了这些网站，英文论文再也不难写了（15个英文论文写作辅助网站介绍和使用技巧） - 知乎</a></p><ul><li><p><a href="https://linggle.com/">Linggle</a>：搜索最常出现的英文词语搭配。不确定自己的表达方式是否正确时使用。</p></li><li><p><a href="https://www.english-corpora.org/coca/">Corpus of Contemporary American English (COCA)</a>：可以查词汇搭配的<strong>美式</strong>英语语料库，可以查看具体的用了这个词的句子。 <a href="https://www.english-corpora.org/bnc/">British National Corpus (BYU-BNC)</a>：英式英语的语料库，语料比美式的少一些</p></li><li><p><a href="https://www.thesaurus.com/">Thesaurus</a>：将低端词汇转换为同义的高端词汇。</p></li><li><p><a href="http://www.esoda.org/">易搜搭ESODA</a>：清华HCI Lab工作室出品的一款适合国人英语写作的词组搭配查询工具。可切换具体研究方向的论文语料库，展示相关的可替换用法，支持中英混搜。</p></li><li><p><a href="https://www.wordandphrase.info/analyzeText.asp">Words and phrases: frequency, genres, collocates, concordances, synonyms, and WordNet</a>：用不同颜色区分高中低频词，展现代表文章类型的词汇，并归类出相关可替换的词。虽然说是英文写作措辞辅助工具，感觉最大的用途是学习相关领域论文常用的词汇和搭配。</p></li></ul><h4 id="句式推荐"><a class="markdownIt-Anchor" href="#句式推荐"></a> 句式推荐</h4><ul><li><a href="http://www.phrasebank.manchester.ac.uk/">Academic Phrasebank</a>：学术用语库，告诉你各个章节适合用哪些句式搭配。</li></ul><h4 id="写作检查"><a class="markdownIt-Anchor" href="#写作检查"></a> 写作检查</h4><p>除开各种类 ChatGPT 外的一些选择。请注意在线检测工具的泄露风险，谨慎处理关键文字。</p><ul><li><p><a href="https://www.grammarly.com/">Grammarly</a>：语法、句型、标点、选词检测修改，有浏览器插件。</p></li><li><p><a href="https://www.nounplus.net/">Nounplus.net</a>：免费的在线英文语法检测。</p></li></ul><!-- * [proofread](https://gitlab.com/snowhitiger/proofread)：【待尝试】对科学文章草稿自动检查，寻找不符合英文科学写作标准的部分，并提出修改意见。作者写的介绍：[分享一个自己做的英文科学写作检查器 - 知乎](https://zhuanlan.zhihu.com/p/62351973)。 --><h3 id="公式编辑"><a class="markdownIt-Anchor" href="#公式编辑"></a> 公式编辑</h3><ul><li><p><a href="https://mathpix.com/">Mathpix</a>：通过截取复杂数学方程式的截图将其转换为 LaTeX 代码。可以处理 PDF 的印刷体和照片中的手写公式等。</p></li><li><p><a href="https://webdemo.myscript.com/">MyScript Webdemo</a>：Math 模块可以将手写公式转为 LaTeX 代码；同时，Diagram 模块可以将手绘的框图转化为工整的框图。</p></li><li><p><a href="http://detexify.kirelabs.org/classify.html">Detexify LaTeX handwritten symbol recognition</a>: 忘记某些字符用 LaTeX 怎么表示时，可以在这个网站上通过手写来查询。</p></li></ul><!-- ### 截屏悬浮写论文时经常会遇到需要参考多个文献或代码的情况，同时查看多个文件并频繁切换会非常麻烦。这里是别人推荐的两个能够将截图悬浮置顶的工具，并随时调整位置和大小，方便写作时参考。* [Snipaste](https://www.snipaste.com/)：【待尝试】有 Windows 和 Mac 版，暂时没有 Linux 版。* [Snappy](http://snappy-app.com/)：【待尝试】有 Mac 和 iPhone & iPad 版，暂时没有 Windows 版。 --><h3 id="表格转-latex"><a class="markdownIt-Anchor" href="#表格转-latex"></a> 表格转 LaTeX</h3><ul><li><a href="https://ctan.org/tex-archive/support/excel2latex">Excel2LaTeX</a>：用在 Excel 上的宏工具，能够将 Excel 表格转换为 LaTeX 代码，节省很多时间。能够满足大多数效果的转换，有些效果可能需要微调。</li></ul><h3 id="绘制示意图"><a class="markdownIt-Anchor" href="#绘制示意图"></a> 绘制示意图</h3><h4 id="绘图工具"><a class="markdownIt-Anchor" href="#绘图工具"></a> 绘图工具</h4><ul><li><p>Mac OS 系统可以使用 OmniGraffle。</p></li><li><p>PPT 通常是我的第一选择：入手快，种类多，自由度高，支持导出矢量图。</p></li></ul><!-- * [Inkscape](https://inkscape.org/) with [latex equation extensions](https://writetex.tk/)：【待尝试】* [http://Lucidchart.com](https://www.lucidchart.com/)：在线画矢量图，可以导出 png、pdf，也支持各种颜色，组合和图层等。 --><h4 id="绘图参考"><a class="markdownIt-Anchor" href="#绘图参考"></a> 绘图参考</h4><ul><li><p><a href="https://github.com/MLNLP-World/Paper-Picture-Writing-Code">Paper-Picture-Writing-Code</a>：基于 LaTex 的画图代码，包含折线图、柱状图、散点图、注意力可视化以及结构图。</p></li><li><p><a href="https://github.com/xinychen/academic-drawing">academic-drawing</a>：Matlab/Python 绘图，主要用于画时序数据。</p></li><li><p><a href="https://github.com/xinychen/awesome-latex-drawing">awesome-latex-drawing</a>：LaTeX 绘图，主要用于画贝叶斯网络、张量分解等。</p></li><li><p><a href="https://github.com/HarisIqbal88/PlotNeuralNet">PlotNeuralNet</a>：Python 得到可用于 LaTeX 的图，主要画 CNN。</p></li></ul><h4 id="ppt-插件"><a class="markdownIt-Anchor" href="#ppt-插件"></a> PPT 插件</h4><ul><li><a href="http://www.jonathanleroux.org/software/iguanatex/">IguanaTex</a>：帮助插入 LaTeX 公式的 PPT 插件。将输入的 LaTeX 代码转换为高质量的 png 或矢量图来插入。</li></ul><h4 id="图片转换"><a class="markdownIt-Anchor" href="#图片转换"></a> 图片转换</h4><p>提供各种格式的图片的转换服务的网站很多。这里只是简单列举，你也可以通过搜索引擎来找到其他类似的网站。</p><ul><li><p><a href="http://www.tlhiv.org/rast2vec/">Convert PNG/JPEG (Raster) to EPS/PDF (Vector) Format</a>：将 jpg、png 格式的图片文件转换为 eps 文件。</p></li><li><p><a href="https://convertio.co/zh/eps-pdf/">EPS到PDF转换器</a>：也可以将 eps 文件转换为别的格式的图片。</p></li></ul><h4 id="图片休整"><a class="markdownIt-Anchor" href="#图片休整"></a> 图片休整</h4><ul><li><p><a href="https://pdfresizer.com/crop">Crop PDF files online - PDF Tools</a>：裁剪 pdf 文件的白边。</p></li><li><p>TexLive 自带了一些命令行工具：</p><ul><li>将 eps 转换为 pdf：<code>epstopdf &lt;file.eps&gt;</code>；</li><li>自动裁剪 pdf 的白边：<code>pdfcrop &lt;file.pdf&gt;</code>。</li></ul></li></ul><h2 id="论文投递"><a class="markdownIt-Anchor" href="#论文投递"></a> 论文投递</h2><h3 id="会议期刊查找筛选"><a class="markdownIt-Anchor" href="#会议期刊查找筛选"></a> 会议期刊查找筛选</h3><ul><li><p><a href="https://ccfddl.github.io/">ccf-deadlines</a>：可以根据研究方向和 CCF 等级来筛选本年度已经确定截稿日期的会议。对国内的同学比较友好。</p></li><li><p><a href="https://aideadlin.es/">AI Conference Deadlines</a>：可以根据研究方向筛选会议。但是好像需要科学上网才能看到全部信息。</p></li><li><p><a href="http://www.conferencelist.info/upcoming.html">Conference List</a>：根据截稿时间排序，过期的会议不在首页出现。有一页可以看每个研究方向有哪些会议，但是没有办法根据研究方向筛选还没过期的会议。</p></li><li><p><a href="http://www.myhuiban.com/">Conference Partner (会伴)</a>：计算机最新国际会议和期刊列表。可以注册以关注会议或期刊。比较全，但目前信息更新不及时。</p></li></ul><!-- * [Conference-Acceptance-Rate](https://github.com/lixin4ever/Conference-Acceptance-Rate)：主要会议近年录取率统计。 --><h3 id="匿名链接"><a class="markdownIt-Anchor" href="#匿名链接"></a> 匿名链接</h3><p>出于论文盲审考虑，有时候文件（如源码）链接需要是匿名的。有些人会选择在 Github 上创建一个匿名账号，但为每一个会议的每一篇论文都创建一个账号可能过于繁琐。我查到有一些工具支持匿名分享文件如下。</p><ul><li><p><a href="https://www.dropbox.com/">Dropbox</a>：应该是最常用的。</p></li><li><p><a href="http://help.osf.io/m/links_forks/l/783581-create-a-view-only-link-for-a-registration">Open Science Framework</a></p></li><li><p><a href="https://knowledge.figshare.com/articles/item/how-to-share-cite-or-embed-my-data">Figshare</a></p></li></ul><h3 id="arxiv-提交"><a class="markdownIt-Anchor" href="#arxiv-提交"></a> arXiv 提交</h3><ul><li><p><a href="https://zhuanlan.zhihu.com/p/109405192">Arxiv 论文提交流程——看这篇就够了</a>：文章，用于了解将论文提交至 arXiv 上的流程。</p></li><li><p><a href="https://github.com/google-research/arxiv-latex-cleaner">arxiv-latex-cleaner</a>：将论文的 LaTeX 代码清理为提交至 arXiv 上的要求。一个亮点是能够自动清理掉论文中所有被注释掉的内容。</p></li><li><p><a href="https://zhuanlan.zhihu.com/p/558225069">overleaf -&gt; arxiv 丝滑提交过程</a>：如果是使用 Overleaf（而不是在本地将 LaTeX 代码编译为论文），可以先参考本文下载合适的源码包，然后再考虑使用 arxiv-latex-cleaner。</p></li></ul><h3 id="代码开源"><a class="markdownIt-Anchor" href="#代码开源"></a> 代码开源</h3><p>为已发表的论文提供清晰、可复现的代码能够有效推动领域发展。这里推荐一些对开源代码有帮助的工具。</p><ul><li><p><a href="https://www.cs.mcgill.ca/~jpineau/ReproducibilityChecklist.pdf">ReproducibilityChecklist-v2.0</a>：一份机器学习复现清单，列举了你应该提供哪些文件来增强你的论文的可复现性。</p></li><li><p><a href="https://github.com/Damnever/pigar">pigar</a>：Python 项目 requirements 文件自动生成工具。</p></li></ul><h2 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h2><h3 id="专利检索"><a class="markdownIt-Anchor" href="#专利检索"></a> 专利检索</h3><ul><li><a href="https://iseex.github.io//2020-05/Google-Patents/">Google Patents</a>：免费检索和下载中英文专利。具体可见 <a href="https://iseex.github.io//2020-05/Google-Patents/">Google Patents，免费检索和下载中英文专利的最佳工具！</a>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apollo-MILP</title>
      <link href="/posts/23e11e23.html"/>
      <url>/posts/23e11e23.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-引言"><a class="markdownIt-Anchor" href="#1-引言"></a> 1. 引言</h2><ul><li>混合整数线性规划 (MILP) 的挑战</li><li>现有方法的局限性</li><li>提出 Apollo-MILP 框架</li></ul><h2 id="2-相关工作"><a class="markdownIt-Anchor" href="#2-相关工作"></a> 2. 相关工作</h2><ul><li>基于ML的分支定界求解器<ul><li>学习分支策略</li><li>学习切割平面选择</li><li>节点探索策略</li></ul></li><li>解决方案预测的ML方法<ul><li>Neural Diving (ND)</li><li>Predict-and-Search (PS)</li></ul></li></ul><h2 id="3-预备知识"><a class="markdownIt-Anchor" href="#3-预备知识"></a> 3. 预备知识</h2><ul><li>MILP公式描述</li><li>双部图表示</li><li>预测与搜索框架 (PS)</li></ul><h2 id="4-apollo-milp框架"><a class="markdownIt-Anchor" href="#4-apollo-milp框架"></a> 4. Apollo-MILP框架</h2><h3 id="40-框架图"><a class="markdownIt-Anchor" href="#40-框架图"></a> 4.0 框架图</h3><p><img src="framework.png" alt="framework" /></p><h3 id="41-预测步骤"><a class="markdownIt-Anchor" href="#41-预测步骤"></a> 4.1 预测步骤</h3><ul><li>使用GNN预测器</li><li>数据增强与训练目标</li></ul><h3 id="42-修正步骤"><a class="markdownIt-Anchor" href="#42-修正步骤"></a> 4.2 修正步骤</h3><ul><li>信任区域搜索</li><li>不确定性误差上界 (UEBO)</li><li>变量修正策略</li></ul><h3 id="43-修正策略分析"><a class="markdownIt-Anchor" href="#43-修正策略分析"></a> 4.3 修正策略分析</h3><ul><li>一致性定义与UEBO关系</li><li>修正策略公式与优化分析</li><li>可行性保障</li></ul><h2 id="5-实验"><a class="markdownIt-Anchor" href="#5-实验"></a> 5. 实验</h2><h3 id="51-实验设置"><a class="markdownIt-Anchor" href="#51-实验设置"></a> 5.1 实验设置</h3><ul><li>基准测试：CA, SC, IP, WA 数据集</li><li>比较基线：ND、PS、ConPS、传统求解器 (SCIP, Gurobi)</li></ul><h3 id="52-主要评估结果"><a class="markdownIt-Anchor" href="#52-主要评估结果"></a> 5.2 主要评估结果</h3><ul><li>目标函数值与差距分析</li><li>收敛性能曲线</li></ul><h3 id="53-消融研究"><a class="markdownIt-Anchor" href="#53-消融研究"></a> 5.3 消融研究</h3><ul><li>不同变量修正策略的性能比较</li><li>热启动方法的效果</li></ul><h2 id="6-结论与未来工作"><a class="markdownIt-Anchor" href="#6-结论与未来工作"></a> 6. 结论与未来工作</h2><ul><li>方法总结</li><li>应用前景与潜在改进方向</li></ul><hr /><p><strong>符号说明:</strong></p><ul><li>MILP: 混合整数线性规划</li><li>ND: Neural Diving</li><li>PS: Predict-and-Search</li><li>UEBO: 不确定性误差上界</li></ul>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MILP </tag>
            
            <tag> Branch and Bound </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速且可解释的 MILP 求解</title>
      <link href="/posts/5c282d63.html"/>
      <url>/posts/5c282d63.html</url>
      
        <content type="html"><![CDATA[<h2 id="摘要"><a class="markdownIt-Anchor" href="#摘要"></a> 摘要</h2><ul><li><strong>挑战:</strong> 解空间维度过高</li><li><strong>提出方法:</strong> 基于偏好的模型约简</li><li><strong>改进效果:</strong> 提高 20% 精度，速度提升 2-4 个数量级</li></ul><h2 id="引言"><a class="markdownIt-Anchor" href="#引言"></a> 引言</h2><ul><li><strong>应用场景:</strong><ul><li>供应链 (Supply Chain)</li><li>能源管理 (Energy Management)</li><li>物流 (Logistics)</li></ul></li><li><strong>挑战:</strong><ul><li>可扩展性 (Scalability)</li><li>可解释性 (Interpretability)</li></ul></li><li><strong>解决方案:</strong> 通过模型约简代替直接预测</li></ul><h2 id="相关工作"><a class="markdownIt-Anchor" href="#相关工作"></a> 相关工作</h2><ul><li>端到端解的预测 (End-to-End Solution Prediction)</li><li>优化过程学习 (Learning to Optimize)</li><li>MILP 模型简化学习 (Learning to Simplify MILP)</li><li>先前论文MLOPT的问题：</li></ul><h2 id="方法"><a class="markdownIt-Anchor" href="#方法"></a> 方法</h2><h3 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h3><ul><li><p><strong>原MILP问题：</strong></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><munder><mo><mi>min</mi><mo>⁡</mo></mo><mi>x</mi></munder><mi>f</mi><mo stretchy="false">(</mo><mi>c</mi><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo><mspace width="1em"/><mtext>subject to</mtext><mspace width="1em"/><mi>g</mi><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo><mo>≤</mo><mi>b</mi><mo separator="true">,</mo><mspace width="1em"/><msub><mi>x</mi><mi>I</mi></msub><mo>∈</mo><msup><mi>Z</mi><mi>d</mi></msup><mo separator="true">,</mo><mspace width="1em"/><msub><mi>x</mi><mrow><mo>−</mo><mi>I</mi></mrow></msub><mo>∈</mo><msup><mi>R</mi><mrow><mi>n</mi><mo>−</mo><mi>d</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\min_{x} f(c, x) \quad \text{subject to} \quad g(A, x) \leq b, \quad x_I \in Z^d, \quad x_{-I} \in R^{n-d}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.45em;vertical-align:-0.7em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.66786em;"><span style="top:-2.4em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">min</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:1em;"></span><span class="mord text"><span class="mord">subject to</span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">I</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1074389999999998em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">d</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.328331em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.07847em;">I</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8991079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">d</span></span></span></span></span></span></span></span></span></span></span></span></span></p><p>其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">c \in \mathbb{R}^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span> 是目标系数向量，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> 是约束矩阵，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span> 是约束向量，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi><mo>=</mo><mo stretchy="false">⟨</mo><mi>A</mi><mo separator="true">,</mo><mi>c</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\theta = \langle A, c, b \rangle</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⟨</span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mclose">⟩</span></span></span></span> 表示 MILP 的所有参数。</p></li><li><p><strong>简化后的问题：</strong></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><munder><mo><mi>min</mi><mo>⁡</mo></mo><mi>x</mi></munder><mi>f</mi><mo stretchy="false">(</mo><mi>c</mi><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo><mspace width="1em"/><mtext>subject to</mtext><mspace width="1em"/><msub><mi>g</mi><mi>i</mi></msub><mo stretchy="false">(</mo><msub><mi>A</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>x</mi><mi>I</mi></msub><mo separator="true">,</mo><msub><mi>x</mi><mrow><mo>−</mo><mi>I</mi></mrow></msub><mo stretchy="false">)</mo><mo>≤</mo><msub><mi>b</mi><mi>i</mi></msub><mo separator="true">,</mo><mtext>  </mtext><mi mathvariant="normal">∀</mi><mi>i</mi><mo>∈</mo><mi>T</mi><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\min_{x} f(c, x) \quad \text{subject to} \quad g_i(A_i, x_I, x_{-I}) \leq b_i, \; \forall i \in T(\theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.45em;vertical-align:-0.7em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.66786em;"><span style="top:-2.4em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">min</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:1em;"></span><span class="mord text"><span class="mord">subject to</span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">I</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.328331em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.07847em;">I</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∀</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span></span></p><p>其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(\theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span> 表示最优解下的紧约束集合，整数变量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>I</mi></msub></mrow><annotation encoding="application/x-tex">x_I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">I</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 被固定为其最优值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>x</mi><mi>I</mi><mo>∗</mo></msubsup><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x^*_I(\theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.025331em;vertical-align:-0.275331em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-2.424669em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">I</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.275331em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span>。</p></li><li><p><strong>策略定义：</strong></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi>s</mi><mo>∗</mo></msup><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo><mo>=</mo><mrow><mo fence="true">(</mo><mi>T</mi><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><msubsup><mi>x</mi><mi>I</mi><mo>∗</mo></msubsup><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">s^*(\theta) = \left(T(\theta), x^*_I(\theta)\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.738696em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7386959999999999em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">I</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span></span></p><p>策略由紧约束集合和最优整数变量值组成。</p></li></ul><h3 id="架构图"><a class="markdownIt-Anchor" href="#架构图"></a> 架构图</h3><p><img src="./Fast%20and%20Interpretable%20Mixed-Integer%20Linear%20Program%20Solving%20by%20Learning%20Model%20Reduction/framework.png" alt="framework" /></p><h3 id="框架概览"><a class="markdownIt-Anchor" href="#框架概览"></a> 框架概览</h3><ul><li><strong>阶段 1:</strong> 策略生成与剪枝 (Strategy Generation and Pruning)</li><li><strong>阶段 2:</strong> 基于偏好的策略学习 (Preference-based Strategy Learning)</li></ul><h3 id="策略生成与剪枝"><a class="markdownIt-Anchor" href="#策略生成与剪枝"></a> 策略生成与剪枝</h3><ul><li><strong>生成:</strong> 随机采样 (Random Sampling)</li><li><strong>剪枝:</strong> 集合覆盖算法 (SETCOVER Algorithm)</li></ul><h3 id="基于偏好的学习"><a class="markdownIt-Anchor" href="#基于偏好的学习"></a> 基于偏好的学习</h3><ul><li><strong>奖励定义:</strong> 不可行性 + 次优性 (Infeasibility + Suboptimality)</li><li><strong>训练:</strong> 基于注意力机制的模型 (Attention-based Model)</li><li><strong>损失函数:</strong> 偏好损失 + 均方误差损失 (Preference Loss + MSE Loss)</li></ul><h2 id="实验"><a class="markdownIt-Anchor" href="#实验"></a> 实验</h2><h3 id="数据集"><a class="markdownIt-Anchor" href="#数据集"></a> 数据集</h3><ul><li>MIPLIB</li><li>燃料电池管理 (Fuel Cell Management)</li><li>库存管理 (Inventory Management)</li></ul><h3 id="评价指标"><a class="markdownIt-Anchor" href="#评价指标"></a> 评价指标</h3><ul><li>精度 (Accuracy)</li><li>不可行性 (Infeasibility)</li><li>次优性 (Suboptimality)</li></ul><h3 id="结果"><a class="markdownIt-Anchor" href="#结果"></a> 结果</h3><ul><li><strong>性能:</strong> 精度提升 (Accuracy Improvement)</li><li><strong>速度:</strong> 比 Gurobi 快 3 个数量级 (3 Orders Faster than Gurobi)</li></ul><h2 id="结论"><a class="markdownIt-Anchor" href="#结论"></a> 结论</h2><ul><li><strong>贡献:</strong> 快速且可解释的 MILP 求解 (Fast &amp; Interpretable MILP Solving)</li><li><strong>技术:</strong> 基于偏好的学习与集合覆盖 (Preference-based Learning, SETCOVER)</li><li><strong>未来工作:</strong> 扩展到其他优化问题 (Expand to Other Optimization Problems)</li></ul><h2 id="思考"><a class="markdownIt-Anchor" href="#思考"></a> 思考</h2><ul><li><strong>无扩展性:</strong> 输入为 MILP 参数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span>，这限制了输入尺寸，遇到更大规模的问题只能重新训练</li><li><strong>创新有限:</strong> 跟先前论文 MLOPT 对比，改进为将评判指标从分数变为偏序关系</li><li><strong>简化模型存疑:</strong> 简化模型中固定了整数变量取值，其实就是 LP 砍去不重要约束 + 预测整数变量取值，两个做法的结合</li></ul>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MILP </tag>
            
            <tag> Branch and Bound </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>应用机器学习的分支定界算法求解混合整数线性规划问题</title>
      <link href="/posts/f7c75aea.html"/>
      <url>/posts/f7c75aea.html</url>
      
        <content type="html"><![CDATA[<h2 id="混合整数线性规划问题"><a class="markdownIt-Anchor" href="#混合整数线性规划问题"></a> 混合整数线性规划问题</h2><p>给定一个矩阵 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>∈</mo><msup><mi mathvariant="double-struck">Q</mi><mrow><mi>m</mi><mo>×</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">A\in \mathbb{Q}^{m\times n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.938001em;vertical-align:-0.16667em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">Q</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span>, 向量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>∈</mo><msup><mi mathvariant="double-struck">Q</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">c\in\mathbb{Q}^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85556em;vertical-align:-0.16667em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">Q</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span> 和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>∈</mo><msup><mi mathvariant="double-struck">Q</mi><mi>m</mi></msup></mrow><annotation encoding="application/x-tex">b\in\mathbb{Q}^m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85556em;vertical-align:-0.16667em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">Q</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span></span></span></span>，一个集合<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mn>1</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{1,...,n\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">}</span></span></span></span>的划分 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi mathvariant="script">A</mi><mo separator="true">,</mo><mi mathvariant="script">B</mi><mo separator="true">,</mo><mi mathvariant="script">C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\mathcal{A}, \mathcal{B}, \mathcal{C})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathcal">A</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.03041em;">B</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span><span class="mclose">)</span></span></span></span> . 一个混合整数线性规划问题(<code>Mixed Integer Linear Programming</code>, <code>MILP</code>)的定义如下：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.24999999999999992em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msup><mi>z</mi><mo>∗</mo></msup><mo>=</mo><mi>min</mi><mo>⁡</mo><mtext>  </mtext></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><msup><mi>c</mi><mi>T</mi></msup><mi>x</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mtext>subject to </mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mi>A</mi><mi>x</mi><mo>≥</mo><mi>b</mi><mo separator="true">,</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><msub><mi>x</mi><mi>j</mi></msub><mo>∈</mo><msub><mi mathvariant="double-struck">Z</mi><mrow><mo>≥</mo><mn>0</mn></mrow></msub><mspace width="0.8535826771653543em"/><mi mathvariant="normal">∀</mi><mi>j</mi><mo>∈</mo><mi mathvariant="script">A</mi><mo separator="true">,</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><msub><mi>x</mi><mi>j</mi></msub><mo>∈</mo><mo stretchy="false">{</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">}</mo><mspace width="0.8535826771653543em"/><mi mathvariant="normal">∀</mi><mi>j</mi><mo>∈</mo><mi mathvariant="script">B</mi><mo separator="true">,</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><msub><mi>x</mi><mi>j</mi></msub><mo>≥</mo><mn>0</mn><mspace width="0.8535826771653543em"/><mi mathvariant="normal">∀</mi><mi>j</mi><mo>∈</mo><mi mathvariant="script">C</mi><mi mathvariant="normal">.</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned} z^* = \min\ \  &amp; c^T x  \\ \text{subject to } &amp; A x \geq b ,  \\ &amp; x_{j}\in \mathbb{Z}_{\geq 0} \hspace{3mm} \forall j\in \mathcal{ A}, \\ &amp; x_{j}\in \{0,1\}\hspace{3mm} \forall j\in \mathcal{B}, \\ &amp; x_{j}\geq 0 \hspace{3mm} \forall j\in \mathcal{C}. \\\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:7.551331em;vertical-align:-3.5256654999999997em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:4.025665500000001em;"><span style="top:-6.1343345000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.738696em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mop">min</span><span class="mspace"> </span><span class="mspace"> </span></span></span><span style="top:-4.6343345000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">subject to </span></span></span></span><span style="top:-3.1343345000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span><span style="top:-1.6343345000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span><span style="top:-0.13433450000000047em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.5256654999999997em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:4.025665500000001em;"><span style="top:-6.1343345000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathnormal">x</span></span></span><span style="top:-4.6343345000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mord mathnormal">A</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">b</span><span class="mpunct">,</span></span></span><span style="top:-3.1343345000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">Z</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mrel mtight">≥</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24517899999999998em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.8535826771653543em;"></span><span class="mord">∀</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathcal">A</span></span><span class="mpunct">,</span></span></span><span style="top:-1.6343345000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">}</span><span class="mspace" style="margin-right:0.8535826771653543em;"></span><span class="mord">∀</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.03041em;">B</span></span><span class="mpunct">,</span></span></span><span style="top:-0.13433450000000047em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.8535826771653543em;"></span><span class="mord">∀</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span><span class="mord">.</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.5256654999999997em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p>设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">I</mi><mo>:</mo><mo>=</mo><mi mathvariant="script">A</mi><mo>∪</mo><mi mathvariant="script">B</mi></mrow><annotation encoding="application/x-tex">\mathcal{I}:=\mathcal{A}\cup \mathcal{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathcal">A</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.03041em;">B</span></span></span></span></span>表示整数和二进制变量的集合。如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">A</mi><mo>=</mo><mi mathvariant="normal">∅</mi></mrow><annotation encoding="application/x-tex">\mathcal{A}=\emptyset</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathcal">A</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">∅</span></span></span></span>，则称混合整数线性规划为混合二进制；如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">A</mi><mo>=</mo><mi mathvariant="script">C</mi><mo>=</mo><mi mathvariant="normal">∅</mi></mrow><annotation encoding="application/x-tex">\mathcal{A}=\mathcal{C}=\emptyset</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathcal">A</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">∅</span></span></span></span>，则称为二进制。去除限制<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">I</mi></mrow><annotation encoding="application/x-tex">\mathcal{I}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span></span></span></span></span>，则得到一个线性规划（<code>Linear Programming</code>, <code>LP</code>），称为<code>MILP</code>的<code>LP</code>松弛。</p><h2 id="milp求解器"><a class="markdownIt-Anchor" href="#milp求解器"></a> MILP求解器</h2><p>现代求解器解决<code>MILP</code>问题是使用了分支定界算法（<code>Branch and Bound</code>, <code>B&amp;B</code>），这是一个精确求解算法。</p><p><code>B&amp;B</code>通过通过<code>MLIP</code>的<code>LP</code>松弛进行可行区域划分，进而解决更小的子<code>MILP</code>。这种划分方案可以表示为一棵搜索树，其中每个节点代表一个子<code>MILP</code>。在搜索过程中，整数可行解的目标函数值提供了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>z</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">z^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.688696em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span>的上界。已知的最优上界值称为<strong>原始界</strong>（<code>primal bound</code>），用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>z</mi><mo>ˉ</mo></mover></mrow><annotation encoding="application/x-tex">\bar{z}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.56778em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.56778em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.19444em;"><span class="mord">ˉ</span></span></span></span></span></span></span></span></span></span>表示。同样，探索过的节点的<code>LP</code>松弛的解<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>z</mi><mrow><mi>L</mi><msub><mi>P</mi><mi>i</mi></msub></mrow></msup></mrow><annotation encoding="application/x-tex">z^{LP_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">L</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:-0.13889em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>作为下界。设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><munder accentunder="true"><mi>z</mi><mo stretchy="true">‾</mo></munder><mo>:</mo><mo>=</mo><msub><mo><mi>min</mi><mo>⁡</mo></mo><mrow><mi>i</mi><mo>:</mo><mi>i</mi><mtext> expored</mtext></mrow></msub><mo stretchy="false">{</mo><msup><mi>z</mi><mrow><mi>L</mi><msub><mi>P</mi><mi>i</mi></msub></mrow></msup><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\underline{z}:=\min_{i: i\text{ expored}} \{z^{LP_i}\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.63056em;vertical-align:-0.19999999999999996em;"></span><span class="mord underline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.43056000000000005em;"><span style="top:-2.84em;"><span class="pstrut" style="height:3em;"></span><span class="underline-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19999999999999996em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1274389999999999em;vertical-align:-0.286108em;"></span><span class="mop"><span class="mop">min</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">:</span><span class="mord mathnormal mtight">i</span><span class="mord text mtight"><span class="mord mtight"> expored</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">L</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:-0.13889em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>提供了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>z</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">z^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.688696em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span>的下界，称为<strong>对偶界</strong>（<code>dual bound</code>）。当所有节点都已处理完毕，或<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>z</mi><mo>ˉ</mo></mover><mo>=</mo><munder accentunder="true"><mi>z</mi><mo stretchy="true">‾</mo></munder></mrow><annotation encoding="application/x-tex">\bar{z}=\underline{z}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.56778em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.56778em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.19444em;"><span class="mord">ˉ</span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.63056em;vertical-align:-0.19999999999999996em;"></span><span class="mord underline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.43056000000000005em;"><span style="top:-2.84em;"><span class="pstrut" style="height:3em;"></span><span class="underline-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19999999999999996em;"><span></span></span></span></span></span></span></span></span>，或符合其他终止条件（如超时）时，<code>B&amp;B</code>算法结束。</p><p>这些是<code>B&amp;B</code>算法在商业求解器（如<code>CPLEX</code>、<code>Gurobi</code>或<code>Xpress</code>）以及学术求解器（如<code>SCIP</code>）中实现的基本原理。在实践中，<code>B&amp;B</code>算法的执行依赖一些关键求解组件，这些组件负责求解过程的不同方面，它们共同决定了求解一个<code>MLIP</code>问题的时间。最重要的组件是<strong>预处理</strong>、<strong>分支规则</strong>、<strong>割平面</strong>和<strong>原始启发式</strong>。</p><p><strong>预处理</strong>。预处理指通过识别子结构等方式，移除冗余的、不必要的约束，从而减小问题规模。</p><p><strong>分支规则</strong>。划分可行区域的过程称为<strong>分支</strong>。而分支规则一般包含两方面：<strong>节点选择</strong>和<strong>变量选择</strong>。关于选择什么节点、选择哪个变量作分支是需要决定的。选择节点指要考虑的未处理的<code>B&amp;B</code>节点。而变量选择一般是使用单变量分支，其为</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>x</mi><mi>j</mi></msub><mo>≤</mo><mo stretchy="false">⌊</mo><msubsup><mi>x</mi><mi>j</mi><mrow><mi>L</mi><mi>P</mi></mrow></msubsup><mo stretchy="false">⌋</mo><mo>∨</mo><msub><mi>x</mi><mi>j</mi></msub><mo>≥</mo><mo stretchy="false">⌈</mo><msubsup><mi>x</mi><mi>j</mi><mrow><mi>L</mi><mi>P</mi></mrow></msubsup><mo stretchy="false">⌉</mo><mtext> </mtext><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">x_j \leq \lfloor x^{LP}_j \rfloor \lor x_j \geq \lceil x^{LP}_j \rceil\,,</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.922078em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.274439em;vertical-align:-0.383108em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.891331em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span><span style="top:-3.1130000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">L</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.383108em;"><span></span></span></span></span></span></span><span class="mclose">⌋</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.922078em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.274439em;vertical-align:-0.383108em;"></span><span class="mopen">⌈</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.891331em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span><span style="top:-3.1130000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">L</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.383108em;"><span></span></span></span></span></span></span><span class="mclose">⌉</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span></span></span></span></span></p><p>对于某些<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>∈</mo><mi mathvariant="script">I</mi></mrow><annotation encoding="application/x-tex">j\in\mathcal{I}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span></span></span></span></span>，使得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>x</mi><mi>j</mi><mrow><mi>L</mi><mi>P</mi></mrow></msubsup><mo mathvariant="normal">∉</mo><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">x^{LP}_j \notin \mathbb{Z}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.236103em;vertical-align:-0.394772em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">L</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.394772em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mord"><span class="mrel">∈</span></span><span class="mord vbox"><span class="thinbox"><span class="llap"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="inner"><span class="mord"><span class="mord">/</span><span class="mspace" style="margin-right:0.05555555555555555em;"></span></span></span><span class="fix"></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">Z</span></span></span></span></span>，即对该子问题下的<code>LP</code>松弛解中不满足整数约束的变量进行上界或下界的收缩，将可行域切分，分成两个子问题。然而，<code>LP</code>松弛的解可能违反多个整数约束，这意味着有多个候选变量可以进行分支，需要从中选择一个。</p><p><strong>割平面</strong>。割平面指通过添加线性不等式来收紧<code>MILP</code>的可行域，但不排除任何整数可行解。这可以在<code>B&amp;B</code>树的任何可行域非空的节点中进行，不过在实践中一般在根节点使用割平面。而在根节点之外添加割平面的<code>B&amp;B</code>过程通常称为<strong>分支切割</strong>（<code>Branch and Cut</code>）。但是割平面也可能会产生问题：虽然割平面的添加能够收缩可行域，但大量切割可能会减慢<code>LP</code>求解速度并导致数值不稳定。因此，审慎的<strong>割平面</strong>策略至关重要。</p><p><strong>原始启发式</strong>。原始启发式来指尝试在短时间内找到可行解的方法。仅依靠分支定界来找到解通常效率比较低下。而原始启发式可以迅速找到一个可行解，从而有效地降低<strong>原始界</strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>z</mi><mo>ˉ</mo></mover></mrow><annotation encoding="application/x-tex">\bar{z}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.56778em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.56778em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.19444em;"><span class="mord">ˉ</span></span></span></span></span></span></span></span></span></span>。与割平面类似，原始启发式可以在树的任何节点中使用。</p><h2 id="milp的评估指标"><a class="markdownIt-Anchor" href="#milp的评估指标"></a> MILP的评估指标</h2><p>如何评估求解器求解一个<code>MILP</code>问题的好坏，有一些量化的指标。首先定义时间变量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">t\geq 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。将<strong>原始界</strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>z</mi><mo>ˉ</mo></mover><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>:</mo><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><msub><mi>T</mi><mi>max</mi><mo>⁡</mo></msub><mo stretchy="false">]</mo><mo>↦</mo><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">\bar{z}(t):[0,T_{\max}]\mapsto \mathbb{R}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.56778em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.19444em;"><span class="mord">ˉ</span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight"><span class="mtight">m</span><span class="mtight">a</span><span class="mtight">x</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">↦</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">R</span></span></span></span></span>和<strong>对偶界</strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><munder accentunder="true"><mi>z</mi><mo stretchy="true">‾</mo></munder><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>:</mo><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><msub><mi>T</mi><mi>max</mi><mo>⁡</mo></msub><mo stretchy="false">]</mo><mo>↦</mo><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">\underline{z}(t):[0,T_{\max}]\mapsto \mathbb{R}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord underline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.43056000000000005em;"><span style="top:-2.84em;"><span class="pstrut" style="height:3em;"></span><span class="underline-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19999999999999996em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight"><span class="mtight">m</span><span class="mtight">a</span><span class="mtight">x</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">↦</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">R</span></span></span></span></span>定义为时间的函数。我们定义如果在时间<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span></span></span></span>尚未找到整数可行解，则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>z</mi><mo>ˉ</mo></mover><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\bar{z}(t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.56778em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.19444em;"><span class="mord">ˉ</span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span>为无穷大。设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi><mo>=</mo><mn>1</mn><msup><mn>0</mn><mrow><mo>−</mo><mn>6</mn></mrow></msup></mrow><annotation encoding="application/x-tex">\epsilon = 10^{-6}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">ϵ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span></span>，用于一些被<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>除的情况。注意有些指标需要用到最优解的目标函数值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>z</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">z^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.688696em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span>，因此一些指标必须在问题解决后计算。</p><h3 id="最优间隙optimality-gap"><a class="markdownIt-Anchor" href="#最优间隙optimality-gap"></a> 最优间隙（<code>Optimality gap</code>）</h3><p class='katex-block katex-error' title='ParseError: KaTeX parse error: No such environment: cases* at position 19: …) :=    \begin{̲c̲a̲s̲e̲s̲*̲}̲      \infty &amp;…'>g(t) :=    \begin{cases*}      \infty &amp; 如果尚未找到解或$\bar{z}(t)\cdot \underline{z}(t)&lt;0$,\\      \frac{|\bar{z}(t)-\underline{z}(t)|}{\min \{|\bar{z}(t)|, |\underline{z}(t)|\}} &amp; 否则。\end{cases*}</p><p>或者，也可以设为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>g</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">∣</mi><msup><mi>z</mi><mo>∗</mo></msup><mo>−</mo><munder accentunder="true"><mi>z</mi><mo stretchy="true">‾</mo></munder><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">g&#x27;(t)=|z^*-\underline{z}(t)|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord underline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.43056000000000005em;"><span style="top:-2.84em;"><span class="pstrut" style="height:3em;"></span><span class="underline-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19999999999999996em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mord">∣</span></span></span></span>。</p><h3 id="原始间隙和积分"><a class="markdownIt-Anchor" href="#原始间隙和积分"></a> 原始间隙和积分</h3><p>对于给定的可行解<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>，我们定义<strong>原始间隙</strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\gamma(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>为</p><p class='katex-block katex-error' title='ParseError: KaTeX parse error: No such environment: cases* at position 24: …) :=    \begin{̲c̲a̲s̲e̲s̲*̲}̲      1 &amp; 如果$z…'>\gamma(x) :=    \begin{cases*}      1 &amp; 如果$z^*\cdot c^Tx &lt; 0$, \\      \frac{|z^*-c^Tx|}{\max\{ |z^*|,|c^Tx|, \epsilon \}} &amp; 否则。    \end{cases*}</p><p>我们可以定义一个<strong>原始间隙函数</strong>，将求解时间映射到到目前为止找到的最佳解的原始间隙。特别地，记<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x(t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span>为时间<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span></span></span></span>找到的最佳解，我们定义</p><p class='katex-block katex-error' title='ParseError: KaTeX parse error: No such environment: cases* at position 19: …) :=    \begin{̲c̲a̲s̲e̲s̲*̲}̲      1 &amp; 如果在时…'>p(t) :=    \begin{cases*}      1 &amp; 如果在时间$t$尚未找到解,\\      \gamma(x(t)) &amp; 否则。    \end{cases*}</p><p><strong>原始积分</strong>定义为</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><msub><mi>t</mi><mi>max</mi><mo>⁡</mo></msub><mo stretchy="false">)</mo><mo>:</mo><mo>=</mo><msubsup><mo>∫</mo><mn>0</mn><msub><mi>t</mi><mi>max</mi><mo>⁡</mo></msub></msubsup><mi>p</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mi>d</mi><mi>t</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">P(t_{\max}) := \int_0^{t_{\max}} p(t) dt.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight"><span class="mtight">m</span><span class="mtight">a</span><span class="mtight">x</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.4554060000000004em;vertical-align:-0.9119499999999999em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5434560000000004em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mop mtight"><span class="mtight">m</span><span class="mtight">a</span><span class="mtight">x</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mord mathnormal">d</span><span class="mord mathnormal">t</span><span class="mord">.</span></span></span></span></span></p><h3 id="原始对偶积分"><a class="markdownIt-Anchor" href="#原始对偶积分"></a> 原始对偶积分</h3><p>可以扩展原始积分的概念以考虑对偶界的改进。为此，我们使用最优间隙代替原始间隙，并积分函数</p><p class='katex-block katex-error' title='ParseError: KaTeX parse error: No such environment: cases* at position 20: …) :=    \begin{̲c̲a̲s̲e̲s̲*̲}̲      1 &amp; 如果尚未…'>pd(t) :=    \begin{cases*}      1 &amp; 如果尚未找到解或$\bar{z}(t)\cdot \underline{z}(t)&lt;0$,\\    g(t)  &amp; 否则为上面的g(t),    \end{cases*}</p><p>得到原始对偶积分，定义为</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>P</mi><mi>D</mi><mo stretchy="false">(</mo><msub><mi>t</mi><mi>max</mi><mo>⁡</mo></msub><mo stretchy="false">)</mo><mo>:</mo><mo>=</mo><msubsup><mo>∫</mo><mn>0</mn><msub><mi>t</mi><mi>max</mi><mo>⁡</mo></msub></msubsup><mi>p</mi><mi>d</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mi>d</mi><mi>t</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">PD(t_{\max}) := \int_0^{t_{\max}} pd(t) dt.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight"><span class="mtight">m</span><span class="mtight">a</span><span class="mtight">x</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.4554060000000004em;vertical-align:-0.9119499999999999em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5434560000000004em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mop mtight"><span class="mtight">m</span><span class="mtight">a</span><span class="mtight">x</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mord mathnormal">d</span><span class="mord mathnormal">t</span><span class="mord">.</span></span></span></span></span></p><h3 id="搜索树大小"><a class="markdownIt-Anchor" href="#搜索树大小"></a> 搜索树大小</h3><p><code>B&amp;B</code>树的节点数量在一定程度上反映了求解时间，因此节点数越小，意味着求解时间更短。</p><h2 id="机器学习的部件"><a class="markdownIt-Anchor" href="#机器学习的部件"></a> 机器学习的部件</h2><h3 id="原始启发式"><a class="markdownIt-Anchor" href="#原始启发式"></a> 原始启发式</h3><p>原始启发式算法的作用是快速找到可行解，因而改善原始界 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>z</mi><mo>ˉ</mo></mover></mrow><annotation encoding="application/x-tex">\bar{z}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.56778em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.56778em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.19444em;"><span class="mord">ˉ</span></span></span></span></span></span></span></span></span></span> ，从而能够<strong>剪枝</strong>更多的节点，特别是在求解初期阶段，能够加快求解。而机器学习技术可以利用实例中的共性结构，快速找到一些可行解而因此备受关注。为此，已经提出了多种方法。从概念上讲，这些方法可以分为三大类：</p><ol><li>预测解以引导搜索</li><li>学习解的邻域搜索改进解</li><li>学习调用已有的原始启发式方法</li></ol><p><img src="image-20240603175653655.png" alt="image-20240603175653655" /></p><p><img src="image-20240603175729529.png" alt="image-20240603175729529" /></p><p><img src="image-20240603175740212.png" alt="image-20240603175740212" /></p><p>根据方式是否需要一个可行解，将原始启发式算法分为两组。</p><ul><li><p>需要一个可行解，其目标是对其进行改进，称之为<strong>改进启发式算法</strong>。</p></li><li><p>不需要一个可行解，称之为<strong>起始启发式算法</strong></p><p>这些算法可以在树的任何一个节点中运行。<strong>改进启发式算法</strong>的一个典型例子是大邻域搜索（<code>LNS</code>）。</p></li></ul><h4 id="预测解以引导搜索"><a class="markdownIt-Anchor" href="#预测解以引导搜索"></a> 预测解以引导搜索</h4><p>预测解以引导搜索指的是，对于一个<code>MILP</code>问题中的<strong>二元变量</strong>，通过机器学习来识别在最优解里，它们取<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>01</mn></mrow><annotation encoding="application/x-tex">01</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">1</span></span></span></span>的概率，得到预测后，就可以交给<code>MILP</code>求解其余变量，从而缩小问题的规模。这一般被称为<strong>温启动</strong>。</p><p>如何进行学习呢？这可以被视为一个监督学习任务，其中期望输出是最优解的值。然而，用于训练阶段的标签的最优解的求解代价往往比较高昂，因此退而用可行解来学习预测。即，学习过程从一个数据收集阶段开始，对每个问题实例 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>，收集一组可行解 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">{</mo><msup><mover accent="true"><mi>x</mi><mo>^</mo></mover><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup><mo separator="true">,</mo><msup><mover accent="true"><mi>x</mi><mo>^</mo></mover><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow></msup><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msup><mover accent="true"><mi>x</mi><mo>^</mo></mover><mrow><mo stretchy="false">(</mo><mi>K</mi><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">D(X) = \{\hat{x}^{(1)},\hat{x}^{(2)},..., \hat{x}^{(K)}\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.138em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">x</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.22222em;"><span class="mord">^</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">x</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.22222em;"><span class="mord">^</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">2</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">x</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.22222em;"><span class="mord">^</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>。目标是学习一个函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mi>θ</mi></msub><mo stretchy="false">(</mo><msub><mi>x</mi><mi>j</mi></msub><mo>=</mo><mn>1</mn><mi mathvariant="normal">∣</mi><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p_\theta (x_j=1|X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span>，其参数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span>，可以解释为给定问题 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> 时变量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">x_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 取值为1的概率。参数被调整以使这些函数的行为尽可能接近目标概率分布 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mi>T</mi></msub><mo stretchy="false">(</mo><msub><mi>x</mi><mi>j</mi></msub><mo>=</mo><mn>1</mn><mi mathvariant="normal">∣</mi><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p_T (x_j=1|X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span> 的行为。  具体可参考以下文章：</p><ul><li><a href="https://arxiv.org/abs/1906.09575">Accelerating Primal Solution Findings for Mixed Integer Programs Based on Solution Prediction</a></li><li><a href="https://arxiv.org/abs/2205.14210">MIP-GNN: A Data-Driven Framework for Guiding Combinatorial Solvers</a></li><li><a href="https://arxiv.org/abs/2012.13349">Solving Mixed Integer Programs Using Neural Networks</a></li></ul><h4 id="学习解的邻域搜索改进解"><a class="markdownIt-Anchor" href="#学习解的邻域搜索改进解"></a> 学习解的邻域搜索改进解</h4><p>解的邻域搜索指的是，给定一个初始可行解 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>x</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">x</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.22222em;"><span class="mord">^</span></span></span></span></span></span></span></span></span></span>，选择要固定的变量值，优化其他变量，即探索其邻域。这一过程可以反复运行。该方法同样期望能识别出问题的子结构，以将其分解为更小、更易处理的子问题。在这种方法中，学习的目标不是预测变量在最优解中的取值，而是预测变量在当前最佳解 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>x</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">x</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.22222em;"><span class="mord">^</span></span></span></span></span></span></span></span></span></span> 中是否已分配到其最优值。具体可参考以下文章：</p><ul><li><a href="https://arxiv.org/abs/2004.00422">A General Large Neighborhood Search Framework for Solving Integer Linear Programs</a></li><li><a href="https://arxiv.org/abs/2107.10201">Learning a Large Neighborhood Search Algorithm for Mixed Integer Programs</a></li><li><a href="https://arxiv.org/abs/2111.03466">Learning Large Neighborhood Search Policy for Integer Programming</a></li><li><a href="https://ojs.aaai.org/index.php/AAAI/article/view/20294">Learning to Search in Local Branching</a></li><li><a href="https://arxiv.org/abs/2302.01578">Searching Large Neighborhoods for Integer Linear Programs with Contrastive Learning</a></li></ul><h4 id="学习调用已有的原始启发式方法"><a class="markdownIt-Anchor" href="#学习调用已有的原始启发式方法"></a> 学习调用已有的原始启发式方法</h4><p>目前的<code>MILP</code>原始启发式算法非常丰富，有实验表明，没有单一的启发式算法适应所有的问题，其优化程度高度依赖于问题，甚至依赖于求解阶段。因此，还有一种优化思路是如何利用这些原始启发式方法。即在一组原始启发式算法中，此时应该运行哪一个？</p><p>学习的方法是观察所选启发式算法的性能。这个简单的方法包含了经典的利用与探索的权衡：在已知的表现良好的启发式算法和运行性能未知的启发式算法之间找到平衡。</p><p>除了决定运行哪些启发式算法以及运行多长时间，还有“何时”运行它们的问题，即在哪些<code>B&amp;B</code>的节点上运行。</p><ul><li><a href="https://www.ijcai.org/proceedings/2017/92">Learning to Run Heuristics in Tree Search</a></li><li><a href="https://optimization-online.org/2018/07/6725/">Adaptive Algorithmic Behavior for Solving Mixed Integer Programs Using Bandit Algorithms</a></li><li><a href="https://link.springer.com/article/10.1007/s12532-021-00209-7">Adaptive large neighborhood search for mixed integer programming</a></li><li><a href="https://arxiv.org/abs/2304.03755">Online Learning for Scheduling MIP Heuristics</a></li><li><a href="https://arxiv.org/abs/2103.10294">Learning to Schedule Heuristics in Branch-and-Bound</a></li></ul><h4 id="未来展望"><a class="markdownIt-Anchor" href="#未来展望"></a> 未来展望</h4><p>上述讨论的优化方法，大都是在特定类别的<code>MILP</code>问题内进行学习，而泛化到其他问题来说是比较困难的。这在某方面使得机器学习的原始启发式算法集成到<code>MILP</code>求解器带来困难。 不过有研究表明，与强化学习结合的探索解空间的算法在一定程度上的泛化是可行的。</p><p>通过组合现有的原始启发式算法来创建新的强大启发式算法也是一个热门的方向。其本质的多臂赌博机问题，已经取得了一些成功。然而，为了能往正确的方向优化，获得更高的性能，需要对性能预测有更高的认识，并需要能有一定的问题泛化能力。</p><h3 id="分支规则"><a class="markdownIt-Anchor" href="#分支规则"></a> 分支规则</h3><p>分支是<code>B&amp;B</code>算法的关键步骤。在已提出的的分支规则中，<strong>强分支</strong>（<code>Strong branching</code>）会产生较小的<code>B&amp;B</code>树，但每个分支的计算成本很高。还有一个被称为<strong>伪成本</strong>（<code>pseudocosts</code>）规则据过去的值来估计。有一种说法是在树的根节点附近执行强分支，然后在变量分支足够多次后切换到使用伪成本，因为初始化阶段的分支对整棵树的大小影响巨大。</p><p>分支规则的目标都是最小化求解时间。但求解时间包括计算时间、节点数量等等，这可能需要在不同计算部分之间取得平衡。</p><h4 id="学习强分支"><a class="markdownIt-Anchor" href="#学习强分支"></a> 学习强分支</h4><p>关于强分支规则的近似是最早进行的。在早期的分析得知，在分支决策影响最大的根节点执行强分支是非常有利的，其次，一个有希望的改进方向是适应问题结构。</p><p>对于强分支规则的近似任务，这可以视为一个预测任务，即根据变量特征预测变量的强分支分数，但也可视为一个排名。不需要知道它们的具体分数，而是预测出其相对大小。</p><p>而从变量特征到变量分数的映射，除了最早的自定义特征外，2019年提出的<code>GNN</code>模型被证明在变量选择中非常有效，他们通过行为克隆的方式训练<code>GNN</code>来模仿强分支，但此时的方向仍是针对同一类问题的求解能力评估。</p><ul><li><a href="https://arxiv.org/abs/1906.01629">Exact Combinatorial Optimization with Graph Convolutional Neural Networks</a></li><li><a href="https://arxiv.org/abs/2311.13843">Exact Combinatorial Optimization with Temporo-Attentional Graph Neural Networks</a></li><li><a href="https://ojs.aaai.org/index.php/AAAI/article/view/10080">Learning to Branch in Mixed Integer Programming</a></li><li><a href="https://arxiv.org/abs/2206.14987">Lookback for Learning to Branch</a></li><li><a href="https://arxiv.org/abs/2006.15212">Hybrid Models for Learning to Branch</a></li><li><a href="https://pubsonline.informs.org/doi/10.1287/ijoc.2016.0723">A Machine Learning-Based Approximation of Strong Branching</a></li></ul><h4 id="学习通用分支规则"><a class="markdownIt-Anchor" href="#学习通用分支规则"></a> 学习通用分支规则</h4><p>上述讨论的方法都仅仅在特定的<code>MILP</code>类问题进行学习和应用，但应用到其他类的<code>MILP</code>问题则效果不好。为了学习到一个通用策略，一个研究方向是在变量选择中增加搜索树的信息来克服它。这个方向的假设是，在<code>MILP</code>之间，存在一种更高阶的信息，并且这种信息可以在<code>B&amp;B</code>树的空间中被捕获。</p><p>尽管如此，如何利用<code>B&amp;B</code>树的信息，仍待研究。</p><ul><li><a href="https://arxiv.org/abs/2002.05120">Parameterizing Branch-and-Bound Search Trees to Learn Branching Policies</a></li><li><a href="https://www.sciencedirect.com/science/article/abs/pii/S0950705122007298">Learning to branch with Tree-aware Branching Transformers</a></li></ul><h4 id="不依赖于专家的分支学习"><a class="markdownIt-Anchor" href="#不依赖于专家的分支学习"></a> 不依赖于专家的分支学习</h4><p>与其他分支策略相比，强分支生成的<code>B&amp;B</code>树相对较小，因此先前的模仿学习模仿的策略都是强分支策略。但是由于一些原因，比如：强分支的标准实现依赖于一些计算过程中的额外数据，比如上下界收缩以及其他统计数据，而单纯的模仿学习并没有依赖这些数据，因此进行完美的模仿，其性能也会比预期差。而在没有比强分支更好的替代方案的情况下，能否不依赖专家知识进行分支规则的学习？</p><p>有研究证明，当使用深度优先搜索（<code>DFS</code>）的选择节点规则进行节点遍历时，最小化每个子树的大小相当于最小化整个<code>B&amp;B</code>树的大小。除此之外，有研究在此基础上定义了一个新的学习分支框架，称之为<strong>树MDP</strong>。树<code>MDP</code>与一般的<code>MDP</code>之间的区别，在于其行为影响的范围仅仅是这棵子树内，而不是后继的整个状态。</p><p>还有的研究设法将树剖成链，让网络学习一条条链。</p><p>实验表明，在强分支表现非常好的实例上，模仿学习的方法更优。然而，当强分支表现不佳时，基于<code>RL</code>的方法能够找到更好的分支策略，体现了在某些情况下无专家学习的潜力。</p><ul><li><p><a href="">Reinforcement learning for variable selection in a branch and bound algorithm</a></p></li><li><p><a href="">Learning to branch with tree MDPs</a></p></li><li><p><a href="https://arxiv.org/abs/2205.14345">Reinforcement Learning for Branch-and-Bound Optimisation using Retrospective Trajectories</a></p></li></ul><h4 id="生成分支规则"><a class="markdownIt-Anchor" href="#生成分支规则"></a> 生成分支规则</h4><p>与直接学习分支规则不同，有工作致力于学习如何生成一个分支规则，通过强化学习的方式，用四则运算、预设常数和预设的函数来生成小型函数，并通过实验表明运行在纯<code>CPU</code>基础策略在性能上与先前的<code>GPU</code>基础的最先进方法相当。</p><ul><li><a href="https://openreview.net/forum?id=jKhNBulNMh">Rethinking Branching on Exact Combinatorial Optimization Solver: The First Deep Symbolic Discovery Framework</a></li></ul><h4 id="强化学习和模仿学习的结合"><a class="markdownIt-Anchor" href="#强化学习和模仿学习的结合"></a> 强化学习和模仿学习的结合</h4><p>有工作将强化学习和模仿学习相结合，提出的混合代理以迭代方式执行，在线RL代理决定样本生成，而离线RL代理进一步筛选具有高累积回报的生成样本。在不同的MIP问题上的实验表明了该方法的有效性，甚至在某些情况下超过了领先的商业求解器。</p><ul><li><a href="https://openreview.net/forum?id=NdcQQ82mfy">Towards Imitation Learning to Branch for MIP: A Hybrid Reinforcement Learning based Sample Augmentation Approach</a></li></ul><h4 id="未来展望-2"><a class="markdownIt-Anchor" href="#未来展望-2"></a> 未来展望</h4><h5 id="适应性"><a class="markdownIt-Anchor" href="#适应性"></a> 适应性</h5><p>上述的工作都表明，没有单一的分支规则在所有问题中都表现优异。而最终目的是希望有一种分支规则，该分支规则能够动态适应各类问题的具体特征。一种引入这种适应性的方法是控制模型用于学习的数据样本的分布。虽然已有研究致力于分支规则的适应性，但如何使用或在不牺牲速度的情况下进一步提高性能的方式，还需探索。</p><h5 id="专家指导"><a class="markdownIt-Anchor" href="#专家指导"></a> 专家指导</h5><p>许多工作都使用强分支规则作为学习有效决策的专家。然而对强分支学习的有效性有些许质疑，一些例子表明，强分支评分未能提供有用的信息。值得研究的方向包括寻找新的专家，更好地模仿它们的新策略，或者相反，在没有专家知识的情况下进行学习。这显然需要强化学习的方法。</p><h5 id="新的方向"><a class="markdownIt-Anchor" href="#新的方向"></a> 新的方向</h5><p>除了上述方向外，还有许多较少研究的方向，比如，强调重要变量的子集而不是在每个节点选择单个变量，该重要变量的子集指的是，在分支定界过程中，只通过在这个后门上的变量进行分支，就可以解决实例达到全局最优或证明其不可行。有工作提出了一种找到这种重要子集的方法，并展示了将它们用作优先分支候选者的潜力。</p><ul><li><a href="https://arxiv.org/abs/2110.08423">Finding Backdoors to Integer Programs: A Monte Carlo Tree Search Framework</a></li></ul><h3 id="割平面"><a class="markdownIt-Anchor" href="#割平面"></a> 割平面</h3><p>割平面程序是现代<code>MILP</code>求解器的另一个重要部分。给定一个<code>LP</code>松弛解<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mrow><mi>L</mi><mi>P</mi></mrow></msup></mrow><annotation encoding="application/x-tex">x^{LP}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">L</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span></span></span></span></span></span></span></span></span></span></span></span>，将生成若干不同类别的割平面，通过选择规则选择其中的一个子集，添加它们并重新求解<code>LP</code>松弛解。一个好的选择标准对于改进<code>LP</code>松弛至关重要，但要避免过多的割平面导致减慢<code>LP</code>求解并导致数值不稳定。因此，如何选择有效的割平面成为了学习的方向，而不是生成割平面。</p><p>最近的研究中，割平面通常在根节点应用得更多，虽然在其他节点进行割平面没有问题，但尚不清楚在根节点之外使用割平面在计算上是否有益。</p><h4 id="单割平面选择"><a class="markdownIt-Anchor" href="#单割平面选择"></a> 单割平面选择</h4><p>早些研究将割平面选择任务建模成<code>MDP</code>。在每一步<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>，从割平面池<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">C</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">\mathcal{C}_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>中选择一个割平面<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">c_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，然后重新求解<code>LP</code>松弛。具体来说，设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">\mathcal{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span></span>是一组割平面，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo stretchy="false">(</mo><mi mathvariant="script">C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">z(\mathcal{C})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mopen">(</span><span class="mord"><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span><span class="mclose">)</span></span></span></span>是添加所有割平面<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">\mathcal{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span></span>后求解<code>LP</code>松弛的结果。度量是第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>步割平面<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">c</span></span></span></span>所带来的<code>LP</code>界限改进，定义为</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi mathvariant="normal">Δ</mi><mi>k</mi></msub><mo stretchy="false">(</mo><mi>c</mi><mo stretchy="false">)</mo><mo>:</mo><mo>=</mo><mi>z</mi><mrow><mo fence="true">(</mo><mo stretchy="false">{</mo><msub><mi>c</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>c</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><mi>c</mi><mo stretchy="false">}</mo><mo fence="true">)</mo></mrow><mo>−</mo><mi>z</mi><mrow><mo fence="true">(</mo><mo stretchy="false">{</mo><msub><mi>c</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>c</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">}</mo><mo fence="true">)</mo></mrow><mtext> </mtext><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\Delta_k(c):=z\left(\{c_1,...,c_{k-1},c\} \right) - z\left(\{c_1,...,c_{k-1}\} \right) \, .</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">Δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">c</span><span class="mclose">}</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mclose">}</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span></span></span></span></span></p><p>为简单表示，设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>z</mi><mi>k</mi></msub><mo>=</mo><mi>z</mi><mrow><mo fence="true">(</mo><mo stretchy="false">{</mo><msub><mi>c</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>c</mi><mi>k</mi></msub><mo stretchy="false">}</mo><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">z_k=z\left(\{c_1,...,c_{k}\} \right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span>。</p><p><img src="image-20240608163523267.png" alt="image-20240608163523267" /></p><p>有一研究采用模仿学习，魔方一个显示的贪心策略：每次从割平面池<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">C</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">\mathcal{C}_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>中选择一个割平面<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">c</span></span></span></span>，其<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Δ</mi><mi>k</mi></msub><mo stretchy="false">(</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Delta_k(c)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">Δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mclose">)</span></span></span></span>最大。他们的计算研究表明，与其他选择规则相比，这种模仿贪心方法在添加<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>个割平面后，其<code>LP</code>界限的改进非常有效。</p><p>还有研究使用强化学习，设定奖励为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>k</mi></msub><mo>=</mo><msub><mi mathvariant="normal">Δ</mi><mi>k</mi></msub><mo stretchy="false">(</mo><msub><mi>c</mi><mi>k</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R_k=\Delta_k(c_k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">Δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。但是样本效率低且缺乏泛化能力。</p><ul><li><p><a href="https://arxiv.org/abs/2206.13414">Learning to cut by looking ahead: Cutting plane selection via imitation learning</a></p></li><li><p><a href="https://arxiv.org/abs/1906.04859">Reinforcement learning for integer programming: Learning to cut</a></p></li></ul><h4 id="多割平面选择"><a class="markdownIt-Anchor" href="#多割平面选择"></a> 多割平面选择</h4><p>上述方法仅仅是将选择割平面分成<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>个步骤，然而事实上，不同割平面之间会有相互影响，而上述方法忽略了这个内在关系。</p><ul><li><a href="https://arxiv.org/abs/2202.10962">Adaptive Cut Selection in Mixed-Integer Linear Programming</a></li><li><a href="https://arxiv.org/abs/2302.00244">Learning Cut Selection for Mixed-Integer Linear Programming via Hierarchical Sequence Model</a></li></ul><h4 id="选择之外"><a class="markdownIt-Anchor" href="#选择之外"></a> 选择之外</h4><p>除了选择割平面之外，还有可作的决策，比如添加的割平面数量。</p><h4 id="未来展望-3"><a class="markdownIt-Anchor" href="#未来展望-3"></a> 未来展望</h4><h5 id="衡量性能"><a class="markdownIt-Anchor" href="#衡量性能"></a> 衡量性能</h5><h5 id="多割平面轮次"><a class="markdownIt-Anchor" href="#多割平面轮次"></a> 多割平面轮次</h5><h3 id="节点选择"><a class="markdownIt-Anchor" href="#节点选择"></a> 节点选择</h3><p>原始启发式的目标是改善<strong>原始界限</strong>，而分支规则和割平面旨在改善<strong>对偶界限</strong>。节点选择策略则是在于平衡这两个目标。通常，更好的节点选择规则能带来更短的求解时间，因为这能得到一个较小的搜索树。为此，需要避免处理一些可被修剪的节点，比如松弛解比最优解还差的节点。</p><p>一种节点选择策略是选择最佳对偶界限的节点。这称为最佳优先搜索（<code>Best First Search</code>，<code>BFS</code>），其优点是能快速改善对偶界限。另外一种节点选择策略是深度优先搜索（<code>Depth First Search</code>，<code>DFS</code>）策略，它优先处理最新分支的节点，类似于原始启发式，旨在快速找到可行解。</p><p>有研究提出一种策略，该策略选择处理通向最优解路径上的节点。这需要在训练过程中知道最优解，从而得知哪条路径通向最优解。还有研究学习一个函数，该函数可以比较树中的任何两个节点的优劣。</p><ul><li><a href="https://papers.nips.cc/paper_files/paper/2014/hash/757f843a169cc678064d9530d12a1881-Abstract.html">Learning to Search in Branch-and-Bound Algorithms</a></li><li><a href="https://arxiv.org/abs/2210.16934">Learning to Compare Nodes in Branch and Bound with Graph Neural Networks</a></li><li><a href="https://arxiv.org/abs/2007.03948">A Study of Learning Search Approximation in Mixed Integer Branch and Bound: Node Selection in SCIP</a></li><li><a href="https://arxiv.org/abs/2310.00112">Reinforcement Learning for Node Selection in Branch-and-Bound</a></li></ul><h4 id="未来展望-4"><a class="markdownIt-Anchor" href="#未来展望-4"></a> 未来展望</h4><p>上述论文的实验结果虽然有所改进，但改进的幅度很小。一般来说，一个有效的原始启发式和分支策略更为重要，而节点选择策略的影响相对较小。</p><h3 id="求解配置"><a class="markdownIt-Anchor" href="#求解配置"></a> 求解配置</h3><p><code>MILP</code>求解器可调整的参数非常多。比如<code>SCIP 8</code>版本中，它有超过<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2000</mn></mrow><annotation encoding="application/x-tex">2000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>个用户可调参数。而适用于不同问题的参数可能不唯一。因此，可以通过机器学习来预测某些参数。</p><ul><li><a href="https://arxiv.org/abs/2311.05650">Learning to Configure Separators in Branch-and-Cut</a></li></ul><h2 id="milp的嵌入"><a class="markdownIt-Anchor" href="#milp的嵌入"></a> MILP的嵌入</h2><p>给定 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>∈</mo><msup><mi mathvariant="double-struck">Q</mi><mrow><mi>m</mi><mo>×</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">A\in \mathbb{Q}^{m\times n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.938001em;vertical-align:-0.16667em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">Q</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>∈</mo><msup><mi mathvariant="double-struck">Q</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">c\in\mathbb{Q}^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85556em;vertical-align:-0.16667em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">Q</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>∈</mo><msup><mi mathvariant="double-struck">Q</mi><mi>m</mi></msup></mrow><annotation encoding="application/x-tex">b\in\mathbb{Q}^m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85556em;vertical-align:-0.16667em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">Q</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span></span></span></span> 以及变量的划分 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi mathvariant="script">A</mi><mo separator="true">,</mo><mi mathvariant="script">B</mi><mo separator="true">,</mo><mi mathvariant="script">C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\mathcal{A}, \mathcal{B}, \mathcal{C})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathcal">A</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.03041em;">B</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span><span class="mclose">)</span></span></span></span>，<code>MILP</code>求解器就可以求解。上述提到的机器学习方法都是将{<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">c</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>} 作为输入。可如何输入呢？我们希望有一些性质。</p><ol><li><strong>置换不变性</strong>： 交换变量或约束的顺序不应改变此问题。</li><li><strong>尺度不变性</strong>：尺度不变性是为了将数值保持在可控范围内，这有助于学习过程。这可以通过归一化步骤实现。</li><li><strong>大小不变性</strong>：表示的大小不应取决于实例的大小。即，我们需要每个需要表示的元素（例如，每个变量或每个节点）的固定大小描述。</li><li><strong>低计算成本</strong>：数据的提取、存储和处理成本低。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MILP </tag>
            
            <tag> Branch and Bound </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mip</title>
      <link href="/posts/5b7420b3.html"/>
      <url>/posts/5b7420b3.html</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a class="markdownIt-Anchor" href="#引言"></a> 引言</h1><h2 id="mip问题的重要性"><a class="markdownIt-Anchor" href="#mip问题的重要性"></a> MIP问题的重要性</h2><ul><li>在实际问题中的广泛应用</li><li>解决大规模MIP问题的挑战</li></ul><h2 id="研究目标"><a class="markdownIt-Anchor" href="#研究目标"></a> 研究目标</h2><ul><li>提出一种分布式方法以高效解决大规模MIP问题</li></ul><h1 id="预备知识"><a class="markdownIt-Anchor" href="#预备知识"></a> 预备知识</h1><h2 id="mip的定义"><a class="markdownIt-Anchor" href="#mip的定义"></a> MIP的定义</h2><ul><li>MIP的基本形式如下：<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><munder><mo><mi>min</mi><mo>⁡</mo></mo><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi></mrow></munder><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><msub><mi>f</mi><mi>i</mi></msub><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>y</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\min_{x, y} \sum_{i=1}^N f_i(x_i, y_i) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.106005em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.66786em;"><span style="top:-2.4000000000000004em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">min</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.836108em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283360000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>subject to:</mtext><mspace width="1em"/><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><msub><mi>g</mi><mi>i</mi></msub><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>y</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>≤</mo><mn>0</mn><mo separator="true">,</mo><mspace width="1em"/><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>y</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>∈</mo><msub><mi>X</mi><mi>i</mi></msub><mo>×</mo><msub><mi>Y</mi><mi>i</mi></msub><mo separator="true">,</mo><mspace width="1em"/><mi>i</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">\text{subject to:} \quad \sum_{i=1}^N g_i(x_i, y_i) \leq 0,\quad (x_i, y_i) \in X_i \times Y_i, \quad i = 1, \ldots, N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.106005em;vertical-align:-1.277669em;"></span><span class="mord text"><span class="mord">subject to:</span></span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283360000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></span></p>其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub><mo>⊆</mo><msup><mi mathvariant="double-struck">R</mi><msub><mi>p</mi><mi>i</mi></msub></msup></mrow><annotation encoding="application/x-tex">X_i \subseteq \mathbb{R}^{p_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>是一个紧的凸集合，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Y</mi><mi>i</mi></msub><mo>⊆</mo><msup><mi mathvariant="double-struck">Z</mi><msub><mi>q</mi><mi>i</mi></msub></msup></mrow><annotation encoding="application/x-tex">Y_i \subseteq \mathbb{Z}^{q_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">Z</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>是一个有限的整数集合。</li></ul><h2 id="现有解决方法"><a class="markdownIt-Anchor" href="#现有解决方法"></a> 现有解决方法</h2><ul><li>分支定界法</li><li>分解方法：通过将原问题分解为更小的子问题来提高求解效率。</li></ul><h1 id="问题的提出"><a class="markdownIt-Anchor" href="#问题的提出"></a> 问题的提出</h1><h2 id="目标函数"><a class="markdownIt-Anchor" href="#目标函数"></a> 目标函数</h2><ul><li>目标函数形式：<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><munder><mo><mi>min</mi><mo>⁡</mo></mo><mrow><mo stretchy="false">{</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>y</mi><mi>i</mi></msub><mo stretchy="false">)</mo><msubsup><mo stretchy="false">}</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></msubsup></mrow></munder><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><msub><mi>f</mi><mi>i</mi></msub><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>y</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\min_{\{(x_i, y_i)\}_{i=1}^N} \sum_{i=1}^N f_i(x_i, y_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.106005em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.66786em;"><span style="top:-2.250975em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">{</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span><span class="mclose mtight"><span class="mclose mtight">}</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8328928571428571em;"><span style="top:-2.177714285714286em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-2.8448em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3222857142857143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">min</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.074625em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283360000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p></li></ul><h2 id="约束条件"><a class="markdownIt-Anchor" href="#约束条件"></a> 约束条件</h2><ul><li>约束条件形式：<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><msub><mi>g</mi><mi>i</mi></msub><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>y</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>≤</mo><mn>0</mn><mo separator="true">,</mo><mspace width="1em"/><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>y</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>∈</mo><msub><mi>X</mi><mi>i</mi></msub><mo>×</mo><msub><mi>Y</mi><mi>i</mi></msub><mo separator="true">,</mo><mspace width="1em"/><mi>i</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">\sum_{i=1}^N g_i(x_i, y_i) \leq 0, \quad (x_i, y_i) \in X_i \times Y_i, \quad i = 1, \ldots, N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.106005em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283360000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></span></p></li></ul><h1 id="mip问题的分解"><a class="markdownIt-Anchor" href="#mip问题的分解"></a> MIP问题的分解</h1><h2 id="右端分配方法"><a class="markdownIt-Anchor" href="#右端分配方法"></a> 右端分配方法</h2><ul><li>将原问题分解为主问题和子问题。</li></ul><h2 id="主问题形式"><a class="markdownIt-Anchor" href="#主问题形式"></a> 主问题形式</h2><ul><li>主问题形式：<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><munder><mo><mi>min</mi><mo>⁡</mo></mo><mrow><mo stretchy="false">{</mo><msub><mi>z</mi><mi>i</mi></msub><msubsup><mo stretchy="false">}</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></msubsup></mrow></munder><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><msub><mi>p</mi><mi>i</mi></msub><mo stretchy="false">(</mo><msub><mi>z</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\min_{\{z_i\}_{i=1}^N} \sum_{i=1}^N p_i(z_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.106005em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.66786em;"><span style="top:-2.250975em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">{</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:-0.04398em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight"><span class="mclose mtight">}</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8328928571428571em;"><span style="top:-2.177714285714286em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-2.8448em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3222857142857143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">min</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.074625em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283360000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>subject to:</mtext><mspace width="1em"/><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><msub><mi>z</mi><mi>i</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\text{subject to:} \quad \sum_{i=1}^N z_i = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.106005em;vertical-align:-1.277669em;"></span><span class="mord text"><span class="mord">subject to:</span></span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283360000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></span></p></li></ul><h2 id="子问题形式"><a class="markdownIt-Anchor" href="#子问题形式"></a> 子问题形式</h2><ul><li>子问题形式：<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub><mo stretchy="false">(</mo><msub><mi>z</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>=</mo><munder><mo><mi>min</mi><mo>⁡</mo></mo><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>y</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow></munder><msub><mi>f</mi><mi>i</mi></msub><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>y</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>+</mo><mi>M</mi><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">p_i(z_i) = \min_{(x_i, y_i, v_i)} f_i(x_i, y_i) + Mv_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.716em;vertical-align:-0.966em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.66786em;"><span style="top:-2.3089999999999997em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">min</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.966em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>subject to:</mtext><mspace width="1em"/><msub><mi>g</mi><mi>i</mi></msub><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>y</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>−</mo><msub><mi>v</mi><mi>i</mi></msub><mo>≤</mo><msub><mi>z</mi><mi>i</mi></msub><mo separator="true">,</mo><mspace width="1em"/><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>y</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>∈</mo><msub><mi>X</mi><mi>i</mi></msub><mo>×</mo><msub><mi>Y</mi><mi>i</mi></msub><mo separator="true">,</mo><mspace width="1em"/><msub><mi>v</mi><mi>i</mi></msub><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\text{subject to:} \quad g_i(x_i, y_i) - v_i \leq z_i, \quad (x_i, y_i) \in X_i \times Y_i, \quad v_i \geq 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">subject to:</span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7859700000000001em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></span></p></li></ul><h1 id="函数-p_iz_i-的半连续性"><a class="markdownIt-Anchor" href="#函数-p_iz_i-的半连续性"></a> 函数$ p_i(z_i) $的半连续性</h1><h2 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h2><ul><li>上半连续和下半连续</li></ul><h2 id="命题"><a class="markdownIt-Anchor" href="#命题"></a> 命题</h2><ul><li>函数$ p_i(z_i) $在每个点是连续的</li></ul><h1 id="函数-p_iz_i的可微性"><a class="markdownIt-Anchor" href="#函数-p_iz_i的可微性"></a> 函数$ p_i(z_i)$的可微性</h1><h2 id="命题-2"><a class="markdownIt-Anchor" href="#命题-2"></a> 命题</h2><ul><li>存在右导数</li></ul><h2 id="定理"><a class="markdownIt-Anchor" href="#定理"></a> 定理</h2><ul><li>右导数的计算方法</li></ul><h1 id="函数-p_iz_i-的计算"><a class="markdownIt-Anchor" href="#函数-p_iz_i-的计算"></a> 函数$ p_i(z_i) $的计算</h1><h2 id="分离假设"><a class="markdownIt-Anchor" href="#分离假设"></a> 分离假设</h2><ul><li>函数$ f_i(x_i, y_i) <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>和</mtext></mrow><annotation encoding="application/x-tex">和</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">和</span></span></span></span> g_i(x_i, y_i) $是可分离的</li></ul><h2 id="定理-2"><a class="markdownIt-Anchor" href="#定理-2"></a> 定理</h2><ul><li>在分离假设下对$ p_i(z_i) $的描述</li></ul><h1 id="算法及收敛性分析"><a class="markdownIt-Anchor" href="#算法及收敛性分析"></a> 算法及收敛性分析</h1><h2 id="算法1"><a class="markdownIt-Anchor" href="#算法1"></a> 算法1</h2><ul><li>基于过估计的迭代求解方法</li></ul><h2 id="收敛性定理"><a class="markdownIt-Anchor" href="#收敛性定理"></a> 收敛性定理</h2><ul><li>序列的每个极限点都是局部最优解</li></ul><h2 id="分布式算法算法2"><a class="markdownIt-Anchor" href="#分布式算法算法2"></a> 分布式算法（算法2）</h2><ul><li>使用多代理系统的协同处理</li></ul><h2 id="收敛性定理-2"><a class="markdownIt-Anchor" href="#收敛性定理-2"></a> 收敛性定理</h2><ul><li>收敛到分解问题的最优点</li></ul><h1 id="模拟实验"><a class="markdownIt-Anchor" href="#模拟实验"></a> 模拟实验</h1><h2 id="数值实验"><a class="markdownIt-Anchor" href="#数值实验"></a> 数值实验</h2><ul><li>0-1 MIP问题示例</li></ul><h2 id="与gurobi的比较"><a class="markdownIt-Anchor" href="#与gurobi的比较"></a> 与Gurobi的比较</h2><ul><li>最优值和运行时间的比较</li></ul><h2 id="结果"><a class="markdownIt-Anchor" href="#结果"></a> 结果</h2><ul><li>所提出的算法在大规模N时优于Gurobi</li></ul><h1 id="结论"><a class="markdownIt-Anchor" href="#结论"></a> 结论</h1><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><ul><li>提出了解决大规模MIP问题的分布式算法</li></ul><h2 id="主要贡献"><a class="markdownIt-Anchor" href="#主要贡献"></a> 主要贡献</h2><ul><li>比Gurobi具有更高的精度和效率</li></ul><h2 id="实际意义"><a class="markdownIt-Anchor" href="#实际意义"></a> 实际意义</h2><ul><li>在电力系统、供应链管理和能源优化中的有效应用</li></ul>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MILP </tag>
            
            <tag> Branch and Bound </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SCIP教程</title>
      <link href="/posts/ea1b0e33.html"/>
      <url>/posts/ea1b0e33.html</url>
      
        <content type="html"><![CDATA[<h2 id="scip是什么"><a class="markdownIt-Anchor" href="#scip是什么"></a> SCIP是什么</h2><p>SCIP（Solving Constraint Integer Programs）是一个用于求解约束整数规划（Constraint Integer Programming，CIP）问题的优化软件框架。它结合了混合整数线性规划（MILP）、混合整数非线性规划（MINLP）以及约束规划（CP）技术，广泛应用于学术研究和工业优化中。SCIP不仅能够处理线性和非线性约束，还支持用户自定义约束和启发式算法，从而提供了灵活且强大的优化能力。</p><p>SCIP Optimization是一套用于生成和求解混合整数非线性规划（MINLP）、混合整数线性规划（MILP）以及整数约束规划（CIP）模型的优化工具。它由多个强大且灵活的组件组成，支持多种优化需求。以下是各组件的简要介绍及其在优化过程中的应用：</p><ol><li><p><strong>SCIP</strong>：</p><ul><li><strong>简介</strong>：SCIP（Solving Constraint Integer Programs）是一个集成了混合整数线性规划、混合整数非线性规划和约束规划的求解器和框架。</li><li><strong>功能</strong>：支持用户定义的约束和启发式算法，能够处理复杂的优化问题，包括线性和非线性约束。</li><li><strong>使用</strong>：用户可以通过C、C++、Python等编程语言接口使用SCIP，或通过数学建模语言ZIMPL来定义优化问题。</li></ul></li><li><p><strong>SoPlex</strong>：</p><ul><li><strong>简介</strong>：SoPlex是一个高性能的线性规划（LP）求解器。</li><li><strong>功能</strong>：解决大型线性规划问题，提供精确的单纯形法和内点法。</li><li><strong>使用</strong>：与SCIP无缝集成，为MILP和MINLP提供高效的线性松弛解法。</li></ul></li><li><p><strong>ZIMPL</strong>：</p><ul><li><strong>简介</strong>：ZIMPL是一个用于定义数学规划模型的建模语言。</li><li><strong>功能</strong>：支持简洁地表达线性和非线性优化模型，生成SCIP和其他求解器可以读取的模型文件。</li><li><strong>使用</strong>：用户通过编写ZIMPL脚本，定义优化变量、约束和目标函数。</li></ul></li><li><p><strong>UG</strong>：</p><ul><li><strong>简介</strong>：UG（Ubiquity Generator）是一个用于并行求解混合整数（线性和非线性）规划问题的框架。</li><li><strong>功能</strong>：利用多核处理器或计算集群加速求解过程，适用于大规模优化问题。</li><li><strong>使用</strong>：配置并行求解环境，通过SCIP调用UG实现并行化求解。</li></ul></li><li><p><strong>GCG</strong>：</p><ul><li><strong>简介</strong>：GCG（Generic Branch-Cut-and-Price Solver）是一个通用的分支切割定价求解器。</li><li><strong>功能</strong>：专注于大规模分配和调度问题，通过分支定界和割平面方法有效求解。</li><li><strong>使用</strong>：与SCIP集成，为特定类型的优化问题提供专业化的求解方法。</li></ul></li></ol><p><strong>SCIP Optimization使用步骤</strong>：</p><ol><li><p><strong>建模</strong>：</p><ul><li>使用ZIMPL语言编写模型，定义变量、目标函数和约束条件。</li><li>或者直接在编程语言（如C、C++、Python）中使用SCIP API构建模型。</li></ul></li><li><p><strong>配置求解器</strong>：</p><ul><li>根据问题特点配置SCIP参数，如启发式算法、剪枝策略等。</li><li>如果问题较大，考虑使用UG进行并行求解。</li></ul></li><li><p><strong>求解问题</strong>：</p><ul><li>调用SCIP求解器进行优化，获取最优解。</li><li>使用SoPlex求解线性松弛问题，以提高整体求解效率。</li></ul></li><li><p><strong>分析结果</strong>：</p><ul><li>提取和分析SCIP求解结果，检查解的有效性和最优性。</li><li>结合业务需求对优化结果进行应用和调整。</li></ul></li></ol><p>SCIP Optimization套件因其灵活性和强大的求解能力，广泛应用于调度、物流、金融、能源等领域的复杂优化问题中。通过各组件的协同工作，用户可以高效地构建、求解和分析优化模型，满足各种实际应用需求。</p><h2 id="如何获取scip"><a class="markdownIt-Anchor" href="#如何获取scip"></a> 如何获取SCIP</h2><p>SCIP可以在其<a href="https://scipopt.org/index.php#download">官网</a>下载，支持<code>Windows</code>,<code>Linux</code>和<code>Mac</code>。有源码（Source Code）下载和预编译包（Precompiled Packages）下载方式。</p><p><img src="image-20240602161127647.png" alt="image-20240602161127647" /></p><p>选择SCIP版本和平台。</p><p>如果仅为了使用，推荐通过预编译包安装，而如果为了结合其他编程语言，比如<code>C++,Python</code>，则推荐为源码安装。</p><h3 id="预编译包安装"><a class="markdownIt-Anchor" href="#预编译包安装"></a> 预编译包安装</h3><p><img src="image-20240602161233568.png" alt="image-20240602161233568" /></p><p>预编译包安装。</p><p><img src="image-20240602162325213.png" alt="image-20240602162325213" /></p><p>下载需要填写带星号的信息后，点击<code>Start Download</code>后开始下载。</p><p>安装时，推荐添加SCIP路径到环境变量<code>PATH</code>中。</p><p><img src="image-20240602163534024.png" alt="image-20240602163534024" /></p><p>随后打开<code>cmd</code>，输入<code>scip</code>，即可进入<code>SCIP</code>交互界面</p><p><img src="image-20240602163943283.png" alt="image-20240602163943283" /></p><h3 id="源码安装"><a class="markdownIt-Anchor" href="#源码安装"></a> 源码安装</h3><p><img src="image-20240602161202827.png" alt="image-20240602161202827" /></p><p>源码安装，第一个是scip套件。然后遵循<a href="https://scipopt.org/doc/html/md_INSTALL.php">这里</a>的指令。</p><h4 id="windows"><a class="markdownIt-Anchor" href="#windows"></a> Windows</h4><p>对于<code>Windows</code>下的源码安装，可以借助于<code>Cmake GUI</code>安装，或者命令行</p><figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">cmake -Bbuild -H. </span><br><span class="line">cmake --build build --config Release [Debug]</span><br></pre></td></tr></table></figure><p><code>[x]</code>表示参数<code>x</code>是可选择的。</p><h4 id="linuxmacos"><a class="markdownIt-Anchor" href="#linuxmacos"></a> Linux,MacOS</h4><p>源码编译需要一些依赖工具，对于使用<code>apt</code>作为包管理工具的系统，可以通过以下指令安装依赖</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt install wget cmake g++ m4 xz-utils libgmp-dev unzip zlib1g-dev libboost-program-options-dev libboost-serialization-dev libboost-regex-dev libboost-iostreams-dev libtbb-dev libreadline-dev pkg-config git liblapack-dev libgsl-dev flex bison libcliquer-dev gfortran file dpkg-dev libopenblas-dev rpm</span><br></pre></td></tr></table></figure><p>然后，通过以下命令安装</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar xvzf scip-x.y.z.tgz                                                       <span class="comment"># 解压下载的源码包，x,y,z替换为对应的版本</span></span><br><span class="line"><span class="built_in">cd</span> scip-x.y.z                                                                 <span class="comment"># 进入解压后的文件夹</span></span><br><span class="line"><span class="built_in">mkdir</span> build                                                                   <span class="comment"># 创建build文件夹</span></span><br><span class="line"><span class="built_in">cd</span> build                                                                      <span class="comment"># 进入build文件夹</span></span><br><span class="line">cmake .. -DCMAKE_INSTALL_PREFIX=&lt;install/dir&gt;                                 <span class="comment"># 编译配置安装路径</span></span><br><span class="line">make                                                                          <span class="comment"># 开始编译</span></span><br><span class="line">make check                                                                    <span class="comment"># (推荐可选) 测试生成文件</span></span><br><span class="line">make install                                                                  <span class="comment"># (可选) 复制编译出来的SCIP到CMAKE_INSTALL_PREFIX</span></span><br></pre></td></tr></table></figure><p>最后在<code>bash</code>输入<code>SCIP</code>即可启动。</p><h2 id="scip的简单使用"><a class="markdownIt-Anchor" href="#scip的简单使用"></a> SCIP的简单使用</h2><p>在<code>SCIP</code>界面，可通过输入<code>help</code>查看帮助。</p><p><img src="image-20240603134606188.png" alt="image-20240603134606188" /></p><p>我们可以通过<code>read</code>指令读取一个问题，我们创建一个<code>exmaple.lp</code>文件，内容为</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Maximize</span><br><span class="line"> obj: x1 + 2 x2 + 3 x3 + x4</span><br><span class="line">Subject To</span><br><span class="line"> c1: - x1 + x2 + x3 + 10 x4 &lt;= 20</span><br><span class="line"> c2: x1 - 3 x2 + x3 &lt;= 30</span><br><span class="line"> c3: x2 - 3.5 x4 = 0</span><br><span class="line">Bounds</span><br><span class="line"> 0 &lt;= x1 &lt;= 40</span><br><span class="line"> 2 &lt;= x4 &lt;= 3</span><br><span class="line">General</span><br><span class="line"> x4</span><br><span class="line">End</span><br></pre></td></tr></table></figure><p>在同目录下，我们输入<code>scip</code>启动，然后输出</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">read example.lp# 读取问题</span><br><span class="line">optimize# 问题求解</span><br></pre></td></tr></table></figure><p><img src="image-20240603135335745.png" alt="image-20240603135335745" /></p><p>最后的<code>Gap</code>为零说明求得了最优解，而最优的目标函数值为<code>1.225e2</code>，且搜到了三个可行解，输入<code>display solution</code>可得到最优解的变量取值。</p><p><img src="image-20240603140453195.png" alt="image-20240603140453195" /></p><p>输入<code>display sols</code>后输入<code>0</code>或<code>1</code>或<code>2</code>可以打印出对应可行解的取值。</p><p><img src="image-20240603140827526.png" alt="image-20240603140827526" /></p><p>可以看到这里的可行解的目标函数值与求解过程中表格里的<code>primalbound</code>的的数值是一致的。</p><h2 id="scip与python的结合"><a class="markdownIt-Anchor" href="#scip与python的结合"></a> SCIP与Python的结合</h2><p>要在<code>Python</code>中使用<code>SCIP</code>，需要借助<a href="https://github.com/scipopt/PySCIPOpt">PySCIPOpt</a>库，可以通过以下命令安装。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip3 install pyscipopt</span><br></pre></td></tr></table></figure><p>安装前需要设置环境变量<code>SCIPOPTDIR</code>为<code>SCIP</code>的安装路径，以便让库能正确与<code>SCIP</code>相结合。</p><p><code>SCIP</code>的安装路径应形如以下格式</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SCIPOPTDIR</span><br><span class="line">  &gt; lib</span><br><span class="line">    &gt; libscip.so (或linscip.dll) ...</span><br><span class="line">  &gt; include</span><br><span class="line">    &gt; scip</span><br><span class="line">    &gt; lpi</span><br><span class="line">    &gt; nlpi</span><br><span class="line">    &gt; ...</span><br></pre></td></tr></table></figure><p>设置环境变量的方法为</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> SCIPOPTDIR=&lt;path_to_install_dir&gt; (Linux, OS X)</span><br><span class="line"><span class="built_in">set</span> SCIPOPTDIR=&lt;path_to_install_dir&gt; (cmd, Cmder, WSL)</span><br><span class="line"><span class="variable">$Env</span>:SCIPOPTDIR = <span class="string">&quot;&lt;path_to_install_dir&gt;&quot;</span> (powershell)</span><br></pre></td></tr></table></figure><p>将<code>&lt;path_to_install_dir&gt;</code>替换为<code>SCIP</code>安装路径即可。</p><p>不同大版本适应不同版本的<code>SCIP</code>，需根据<code>SCIP</code>选择对应版本的<code>PySCIPOpt</code>。</p><table><thead><tr><th>SCIP</th><th>PySCIPOpt</th></tr></thead><tbody><tr><td>9.0</td><td>5.x</td></tr><tr><td>8.0</td><td>4.x</td></tr><tr><td>7.0</td><td>3.x</td></tr><tr><td>6.0</td><td>2.x</td></tr><tr><td>5.0</td><td>1.4, 1.3</td></tr><tr><td>4.0</td><td>1.2, 1.1</td></tr><tr><td>3.2</td><td>1.0</td></tr></tbody></table><p>然后创建一个<code>example.py</code>，输入以下内容</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyscipopt <span class="keyword">import</span> Model</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建模型</span></span><br><span class="line">model = Model(<span class="string">&quot;example&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义变量及其上下界</span></span><br><span class="line">x1 = model.addVar(<span class="string">&quot;x1&quot;</span>, vtype=<span class="string">&quot;C&quot;</span>, lb=<span class="number">0</span>, ub=<span class="number">40</span>)</span><br><span class="line">x2 = model.addVar(<span class="string">&quot;x2&quot;</span>, vtype=<span class="string">&quot;C&quot;</span>)</span><br><span class="line">x3 = model.addVar(<span class="string">&quot;x3&quot;</span>, vtype=<span class="string">&quot;C&quot;</span>)</span><br><span class="line">x4 = model.addVar(<span class="string">&quot;x4&quot;</span>, vtype=<span class="string">&quot;I&quot;</span>, lb=<span class="number">2</span>, ub=<span class="number">3</span>)  <span class="comment"># x4为整数变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置目标函数</span></span><br><span class="line">model.setObjective(x1 + <span class="number">2</span>*x2 + <span class="number">3</span>*x3 + x4, <span class="string">&quot;maximize&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加约束</span></span><br><span class="line">model.addCons(-x1 + x2 + x3 + <span class="number">10</span>*x4 &lt;= <span class="number">20</span>, <span class="string">&quot;c1&quot;</span>)</span><br><span class="line">model.addCons(x1 - <span class="number">3</span>*x2 + x3 &lt;= <span class="number">30</span>, <span class="string">&quot;c2&quot;</span>)</span><br><span class="line">model.addCons(x2 - <span class="number">3.5</span>*x4 == <span class="number">0</span>, <span class="string">&quot;c3&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 求解模型</span></span><br><span class="line">model.optimize()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查是否找到最优解</span></span><br><span class="line"><span class="keyword">if</span> model.getStatus() == <span class="string">&quot;optimal&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Optimal solution found:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;x1 = <span class="subst">&#123;model.getVal(x1)&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;x2 = <span class="subst">&#123;model.getVal(x2)&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;x3 = <span class="subst">&#123;model.getVal(x3)&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;x4 = <span class="subst">&#123;model.getVal(x4)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Optimal solution not found!&quot;</span>)</span><br></pre></td></tr></table></figure><p>然后<code>python3 example.py</code>运行</p><p><img src="image-20240603143500455.png" alt="image-20240603143500455" /></p><p>结果和上述<code>SCIP</code>的结果一致。</p><h2 id="scip与神经网络的结合"><a class="markdownIt-Anchor" href="#scip与神经网络的结合"></a> SCIP与神经网络的结合</h2><p><a href="https://www.ecole.ai/">Ecole</a>（Efficient Combinatorial Optimization Learning Environment）是一个专为结合SCIP和神经网络的研究和应用而设计的库。它为在组合优化问题中利用机器学习提供了一个灵活且高效的框架。以下是ECole库的主要功能和特点：</p><h3 id="ecole的主要特点"><a class="markdownIt-Anchor" href="#ecole的主要特点"></a> ECole的主要特点</h3><ol><li><p><strong>整合优化与学习</strong>：</p><ul><li>ECole允许将优化求解与机器学习模型无缝集成，支持在优化过程中引入机器学习方法，以增强求解性能。</li></ul></li><li><p><strong>环境与任务</strong>：</p><ul><li>ECole定义了一系列优化环境和任务，这些任务可以是传统的组合优化问题，也可以是经过扩展的、更具挑战性的问题。这些任务和环境可以直接与强化学习算法结合使用。</li></ul></li><li><p><strong>多样化的观察与反馈</strong>：</p><ul><li>ECole提供丰富的观察和反馈机制，使用户可以根据需求定制优化过程中的信息收集方式。这有助于在优化过程中动态调整策略。</li></ul></li><li><p><strong>高效的实现</strong>：</p><ul><li>ECole采用高效的数据结构和算法，确保在求解大规模优化问题时的性能和可扩展性。</li></ul></li></ol><p>要安装<code>Ecole</code>，首先设置好环境变量<code>SCIP_DIR</code>为<code>SCIP</code>的安装路径，然后输入以下指令安装。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip3 install ecole</span><br></pre></td></tr></table></figure><p>注意，该库暂不支持<code>Windows</code>系统。</p><p>该库不依赖<code>PyScipOpt</code>，但如果需要自定义<code>Ecole</code>里的模块，则仍需依赖<code>PyScipOpt</code>开发。</p><h3 id="ecole的简单使用"><a class="markdownIt-Anchor" href="#ecole的简单使用"></a> Ecole的简单使用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ecole</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化Ecole环境</span></span><br><span class="line">env = ecole.environment.Branching()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个优化实例生成器</span></span><br><span class="line">instance_generator = ecole.instance.SetCoverGenerator()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="comment"># 生成一个问题实例</span></span><br><span class="line">    instance = <span class="built_in">next</span>(instance_generator)</span><br><span class="line">    <span class="comment"># 初始化环境</span></span><br><span class="line">    observation, action_set, reward_offset, done, info = env.reset(instance)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> done:</span><br><span class="line">        <span class="comment"># 进行分支定界中的变量选择操作，observation就是当前要分支的子问题</span></span><br><span class="line">        observation, action_set, reward, done, info = env.step(action_set[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p><code>Ecole</code>类似于<code>OpenAI</code>里的<code>GYM</code>用法，将用分支定界算法求解混合整数线性规划问题抽象成一个序列决策的马尔科夫过程，期间的<code>Observation</code>是对当前子问题的一个描述，它可以是一个二分图表示法，进而作为一个图卷积神经网络的输入，得到动作，即选择的变量。</p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>综上所述，<code>SCIP</code>（Solving Constraint Integer Programs）及其相关组件（<code>SoPlex</code>、<code>ZIMPL</code>、<code>UG</code>、<code>GCG</code>）提供了一个强大且灵活的优化框架，能够有效解决复杂的混合整数规划问题。通过结合<code>SCIP</code>和<code>Python</code>（如使用<code>PySCIPOpt</code>库），用户可以轻松地在编程环境中构建和求解优化模型。此外，<code>Ecole</code>库进一步拓展了<code>SCIP</code>的应用范围，使其能够与机器学习特别是强化学习方法相结合，提供了在组合优化问题上进行深入研究和创新的工具。这些工具在学术研究和工业应用中都有广泛的用途，帮助解决各种实际优化问题，提升决策和资源分配的效率。</p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SCIP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于UDP的文件传输程序</title>
      <link href="/posts/2bf18a0f.html"/>
      <url>/posts/2bf18a0f.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>计算机网络大作业期中报告</p></blockquote><h2 id="项目一览与摘要"><a class="markdownIt-Anchor" href="#项目一览与摘要"></a> 项目一览与摘要</h2><h3 id="项目特色"><a class="markdownIt-Anchor" href="#项目特色"></a> 项目特色</h3><p>该项目在应用层实现了<code>TCP</code>协议中的众多功能以实现传输的可靠和高效：<strong>动态调整<code>RTT</code>，流量控制，阻塞控制，快速重传。</strong></p><p>同时，还实现了<strong>并发接收和并发传输</strong>机制，能够同时接收或发送若干个文件。发送还支持文件夹发送，即保留文件夹结构不变地情况下发送里面的所有文件。</p><p>实现了基于<code>md5</code>的<strong>断点续传</strong>功能，在传输发生中断时，下次传输时用户可以选择从上次中断之处继续传输，而不用从头传输，大大节省不必要的流量。</p><p>该项目还有完善的<strong>日志记录</strong>功能，会将程序运行过程中产生的正常信息，警告信息，错误信息分别保存下来，方便查错。</p><p>该项目实现了服务端和客户端<strong>双方收发文件</strong>的功能。客户端既能发送文件给服务端，也能从服务端下载文件到本地。</p><p>该项目实现了数据传输的报文数据段大小由<strong>客户端决定</strong>，服务端适应的机制，使得服务端能够适应不同客户端的传输需求。</p><p>该项目还有绘图功能，能够将发送过程中的参数变化绘制成图表，方便分析。</p><p>经实测实现了可靠和高效传输的效果。</p><p><img src="result.png" alt="result" /></p><p>此图为从连接校园网的终端传输一个10M的文件到阿里云服务器的结果，传输期间触发了一次超时重传，<code>236</code>次快速重传，总耗时<code>34</code>秒。</p><p>本项目基于<strong>python</strong>语言编写。</p><p>项目结构：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── Client.py# 客户端程序</span><br><span class="line">├── config</span><br><span class="line">│   ├── config.py# 配置信息</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── Logger.py# 日志信息</span><br><span class="line">│   ├── Receiver.py# 接收文件类</span><br><span class="line">│   ├── Sender.py# 发送文件类</span><br><span class="line">│   └── util.py# 功能函数，包括文件核对等</span><br><span class="line">└── Server.py# 服务端程序</span><br></pre></td></tr></table></figure><h2 id="需求分析"><a class="markdownIt-Anchor" href="#需求分析"></a> 需求分析</h2><p>众所周知，<code>UDP</code>是不可靠协议，但能够对应用层数据的发送控制更为精准，无连接建立，无连接状态使得<code>UDP</code>能较少地占用终端资源，且<code>UDP</code>分组的首部开销小，仅有<code>8</code>字节。而<code>TCP</code>是通用的可靠传输协议，适用范围很广，其首部有<code>20</code>字节的开销。因此对于文件传输来说，有许多信息是没有必要的。因此实现专门适用于文件传输的可靠协议是有必要的。而要用一个不可靠协议实现可靠传输，就如同<code>TCP</code>一样要在不可靠的IP协议下实现可靠传输一样，我们要将能够确保可靠的机制在<code>UDP</code>的上一层：应用层实现。于是我们需要参考<code>TCP</code>实现可靠传输的一些机制，在应用层上实现。同时为了改善用户体验，实现一些基本的需求比如断点续传，文件夹发送等功能。</p><h2 id="设计思想"><a class="markdownIt-Anchor" href="#设计思想"></a> 设计思想</h2><p>本项目基于建造者（<code>Builder</code>）模式设计。</p><p>服务端（<code>Server</code>）和客户端（<code>Client</code>）都有发送和接收文件的功能，两者在这两个功能上行为一致，只有起初的发送请求等行为不同。</p><p>于是服务端能够根据自身的身份（发送者还是接收者），创建相应的<code>Sender</code>或<code>Receiver</code>进行发送或接收文件。同理客户端也能如此。</p><p>同时为实现并发传输及可靠性，服务端有个主进程，监听客户端的请求，并创建一个子服务进程，处理该请求，而主进程继续监听请求。</p><p>客户端同样也有个主进程，负责扫描发送的文件（夹），对每一个要发送的文件，创建一个子客户进程向服务端发送请求。当所有子进程结束后，主进程将根据子进程发送文件时产生的数据进行汇总，绘制图表。</p><p>子服务进程在处理请求，以及子客户进程在执行请求时，会根据自身的身份（发送者还是接收者），创建相应的类，并调用类方法执行。</p><h2 id="核心算法"><a class="markdownIt-Anchor" href="#核心算法"></a> 核心算法</h2><h3 id="报文首部"><a class="markdownIt-Anchor" href="#报文首部"></a> 报文首部</h3><table><thead><tr><th>签名sign （16bit）</th><th>窗口大小rwnd(16bit)</th></tr></thead><tbody><tr><td><strong>报文序号(32bit)</strong></td><td></td></tr><tr><td><strong>数据段(MSS)</strong></td><td></td></tr></tbody></table><p>其中<code>rwnd</code>对于接收方发送的报文而言，就是缓冲区的剩余大小，单位是<code>MSS</code>.</p><p>对于发送方发送的报文而言，用于特殊标记，如终止传输报文，请求端口报文等。</p><p><code>ACK</code>报文，数据段为空。报文序号表示确认的报文序号。</p><p><strong>注意</strong>，此处的<code>ACK</code>报文序号与<code>TCP</code>中的<code>ACK</code>不同。此处的ACK序号为接收到的最后一个报文序号，并非<code>TCP</code>里的接收到的最后一个报文序号加一。可以理解此处的<code>ACK</code>与<code>TCP</code>里的<code>ACK</code>的关系为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>C</mi><mi>K</mi><mo>=</mo><mi>A</mi><mi>C</mi><msub><mi>K</mi><mrow><mi>T</mi><mi>C</mi><mi>P</mi></mrow></msub><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">ACK = ACK_{TCP} - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p><p>除了请求报文的<code>MSS</code>是双方约定好之外，握手和数据传输报文的<code>MSS</code>大小由客户端告知服务端，在请求报文中告知。</p><p>握手报文中，数据段的数据之间采用分隔符<code>spliter</code>（定义在<code>config/config.py</code>文件中）区分。</p><h3 id="可靠机制"><a class="markdownIt-Anchor" href="#可靠机制"></a> 可靠机制</h3><p>为实现可靠机制，需要对发出去的每一份报文收到相应的<code>ACK</code>确认报文，此处实现和<code>TCP</code>一致。</p><p>同时，为防止无关报文的干扰，传输通信的报文都有一个唯一确定的<strong>签名sign</strong>进行核验，不通过的报文将被丢弃。</p><p>报文出了签名外，还标有序号，以确保不被乱序收到。</p><h3 id="动态调整rtt"><a class="markdownIt-Anchor" href="#动态调整rtt"></a> 动态调整RTT</h3><p>实现自<code>Jacobson / Karels</code> 算法</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>R</mi><mi>T</mi><mi>T</mi><mo>=</mo><mi>S</mi><mi>R</mi><mi>T</mi><mi>T</mi><mo>+</mo><mi>α</mi><mo stretchy="false">(</mo><mi>R</mi><mi>T</mi><mi>T</mi><mtext>–</mtext><mi>S</mi><mi>R</mi><mi>T</mi><mi>T</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">SRTT = SRTT + \alpha ( RTT – SRTT )</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord">–</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mclose">)</span></span></span></span> —— 计算平滑 RTT</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>e</mi><mi>v</mi><mi>R</mi><mi>T</mi><mi>T</mi><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>β</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>D</mi><mi>e</mi><mi>v</mi><mi>R</mi><mi>T</mi><mi>T</mi><mo>+</mo><mi>β</mi><mo>∗</mo><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>R</mi><mi>T</mi><mi>T</mi><mo>−</mo><mi>S</mi><mi>R</mi><mi>T</mi><mi>T</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">DevRTT = ( 1-\beta ) * DevRTT + \beta * ( | RTT - SRTT | )</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span> ——计算平滑 RTT 和真实的差距（加权移动平均）</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>T</mi><mi>O</mi><mo>=</mo><mi>μ</mi><mo>∗</mo><mi>S</mi><mi>R</mi><mi>T</mi><mi>T</mi><mo>+</mo><mi mathvariant="normal">∂</mi><mo>∗</mo><mi>D</mi><mi>e</mi><mi>v</mi><mi>R</mi><mi>T</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">RTO= \mu * SRTT + \partial * DevRTT</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.6597200000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">μ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span></p><p>其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>=</mo><mn>0.125</mn><mo separator="true">,</mo><mi>β</mi><mo>=</mo><mn>0.25</mn><mo separator="true">,</mo><mi>μ</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mi mathvariant="normal">∂</mi><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">\alpha = 0.125, \beta = 0.25, \mu = 1, \partial = 4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">1</span><span class="mord">2</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">2</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">μ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span>，取自<a href="https://datatracker.ietf.org/doc/html/rfc6298">RFC6298</a>。RTT是测量值，为一份报文从发出到接收到ACK报文所经历的时间。</p><h3 id="流量控制"><a class="markdownIt-Anchor" href="#流量控制"></a> 流量控制</h3><p>考虑到服务端和客户端性能上的差异，接收方收到的包并不会马上写入文件，而是会放到缓冲区里，而当缓冲区满时，接收方就不能接收新的数据包，防止缓冲区溢出，而此时如果发送方继续发送报文则会导致丢失，因此当客户端和服务端性能差异过大时，要避免不必要的发包。</p><p>实现机制和<code>TCP</code>类似，接收方每一次<code>ACK</code>回复报文中会带有当前缓冲区剩余长度，发送方会根据<code>ACK</code>报文中的剩余长度，动态调整自己的发送行为，必要时暂停发送。</p><h3 id="阻塞控制"><a class="markdownIt-Anchor" href="#阻塞控制"></a> 阻塞控制</h3><p>除了考虑服务端和客户端之外，还要考虑当前网络状况，如出现频繁丢包现象时不应保持持续发包，以降低发送成功率，加剧网络阻塞。</p><p>实现机制和<code>TCP</code>类似，发送方维护一个发送状态，有诸如<em>慢启动</em>，<em>阻塞避免</em>，<em>快速恢复</em>等状态，以及一个阻塞窗口，和流量控制里的流量窗口（接收方缓冲区剩余长度）共同控制发送方的发送行为。</p><h3 id="快速重传"><a class="markdownIt-Anchor" href="#快速重传"></a> 快速重传</h3><p>限于接收方采用按序收包的策略，当出现包丢失时，能够通过接收方发送的多次冗余<code>ACK</code>得知。</p><p>实现机制和<code>TCP</code>类似，当发送方接收到三次及以上冗余<code>ACK</code>后，会立刻重发仍未被确认的数据包。</p><h3 id="断点续传"><a class="markdownIt-Anchor" href="#断点续传"></a> 断点续传</h3><p>由于文件是从头开始发送，中间传输故障时，我们能够知晓接收方收到的数据是文件开头一定大小的。</p><p>客户端和服务端在进行握手时，接收方会向发送方发送自身文件的大小size和md5码，接收方接收到后，计算发送文件前<code>size</code>大小的<code>md5</code>码，与接收方发送的<code>md5</code>码进行比对。如果一致，说明文件一致，则向用户询问是否续传还是重传。</p><h3 id="并发传输"><a class="markdownIt-Anchor" href="#并发传输"></a> 并发传输</h3><p>运用多进程，使得每个进程负责一个文件的收发，达到并发机制。</p><h2 id="软件架构"><a class="markdownIt-Anchor" href="#软件架构"></a> 软件架构</h2><p>本项目共有四个模块，十分清晰简单。其类成员方法如下所示。</p><pre class="mermaid">classDiagram    class Sender{    +file    +send()    +update_cwnd()    +resend()    +update_RTO()    +receive()    +summary()    +start()    }    class Receiver{    +file    +receive()    +write()    +start()    }    class Server{    +Shakehand()    +start()    }    class Client{    +Getport()    +Shakehand()    +start()    }    Sender --* Server    Sender --* Client    Receiver --* Server    Receiver --* Client</pre><h2 id="流程图"><a class="markdownIt-Anchor" href="#流程图"></a> 流程图</h2><p>这里展示客户端发送文件给服务端，续传方式。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Participant User</span><br><span class="line">Participant Client</span><br><span class="line">Participant SubServer</span><br><span class="line">Participant Server</span><br><span class="line"></span><br><span class="line">Client-&gt;Server: 我有个请求\n报文数据段大小为MSS\n报文签名为sign</span><br><span class="line">Note right of Server: Package 0</span><br><span class="line">Server--&gt;Client: OK\n请发送请求到这个端口</span><br><span class="line">Client-&gt;SubServer :这是文件名、\n文件大小、md5码</span><br><span class="line">Note right of SubServer: 收到文件名，\n获取自身的文件大小\n和md5码</span><br><span class="line">Note left of Client: Package 1</span><br><span class="line">SubServer --&gt; Client: OK，这是我这里存在的\n文件的部分数据大小\n和md5</span><br><span class="line">Note left of Client: 核对服务端发来\n文件信息</span><br><span class="line">Client -&gt; User: 发现服务端\n有部分数据\n是否仅发送剩余数据</span><br><span class="line">User --&gt; Client :OK</span><br><span class="line">Client -&gt; SubServer : 我将续传发送剩余数据</span><br><span class="line">Note right of SubServer: Package 2</span><br><span class="line">SubServer --&gt; Client : OK</span><br><span class="line">Note left of Client : 开始发送文件</span><br><span class="line">Client -&gt; SubServer : Data Package 3</span><br><span class="line">Client -&gt; SubServer : Data Package 4</span><br><span class="line">SubServer --&gt; Client : ACK 3</span><br><span class="line">SubServer --&gt; Client : ACK 4</span><br><span class="line">Client -&gt; SubServer : Data Package 5</span><br><span class="line">Client -&gt; SubServer : Data Package 6</span><br><span class="line">SubServer --&gt; Client : ACK 5</span><br><span class="line">SubServer --&gt; Client : Lost ACK 6</span><br><span class="line">Note left of Client : Timeout \nwhen receiving \nACK 6</span><br><span class="line">Client -&gt; SubServer : Data Package 6</span><br><span class="line">SubServer --&gt; Client : ACK 6</span><br><span class="line">Client -&gt; SubServer : Lost Data Package 7</span><br><span class="line">Client -&gt; SubServer : Data Package 8</span><br><span class="line">Client -&gt; SubServer : Data Package 9</span><br><span class="line">Client -&gt; SubServer : Data Package 10</span><br><span class="line">SubServer --&gt; Client : ACK 6</span><br><span class="line">SubServer --&gt; Client : ACK 6</span><br><span class="line">SubServer --&gt; Client : ACK 6</span><br><span class="line">Note left of Client : 快速重传</span><br><span class="line">Client -&gt; SubServer : Data Package 7</span><br><span class="line">Client -&gt; SubServer : Data Package 8</span><br><span class="line">Client -&gt; SubServer : Data Package 9</span><br><span class="line">Client -&gt; SubServer : Data Package 10</span><br><span class="line">SubServer --&gt; Client : ACK 7</span><br><span class="line">SubServer --&gt; Client : ACK 8</span><br><span class="line">SubServer --&gt; Client : ACK 9</span><br><span class="line">SubServer --&gt; Client : ACK 10, buffer is full</span><br><span class="line">Note left of Client : wait a second</span><br><span class="line">Client -&gt; SubServer : Is buffer still full?</span><br><span class="line">SubServer --&gt; Client : no, continue, please.</span><br><span class="line">Client -&gt; SubServer : Fin Package 11</span><br><span class="line">SubServer --&gt; Client : FIN ACK 11</span><br><span class="line">Note right of SubServer : 检查接收文件的md5与\n从一开始从客户端接收的md5\n是否一致</span><br><span class="line">Note right of SubServer : Close</span><br><span class="line">Client -&gt; User : I FINISH! \nHere is result.</span><br><span class="line">User --&gt; Client: Greate Jobs!</span><br><span class="line">Note left of Client : Close</span><br></pre></td></tr></table></figure><p>其余方式与此图非常类似。</p><p>关于异常处理，在发送文件前的握手阶段，如果有任何报文丢失的话，接收报文方将触发超时机制，重传上一份报文。连续超时<code>5</code>次则握手失败，关闭进程。</p><p>签名重复情况。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Participant Client</span><br><span class="line">Participant Server</span><br><span class="line"></span><br><span class="line">Client-&gt;Server: 我有个请求\n报文数据段大小为MSS\n报文签名为sign</span><br><span class="line">Note right of Server: 发现签名已被其他请求使用，\n且来自不同的ip:port</span><br><span class="line">Server--&gt;Client: RESET，签名重复，请更换签名</span><br><span class="line">Client-&gt;Server: 好的，我有个请求\n报文数据段大小为MSS\n新报文签名为Sign</span><br><span class="line">Server--&gt;Client: OK，请发送请求到这个端口</span><br></pre></td></tr></table></figure><p>收到任何签名<code>sign</code>不对的报文均丢弃。</p><p>收到的任何序号不对的报文将丢弃，并重发上一个报文。</p><p>发送数据过程中出现的异常处理和<code>TCP</code>的异常处理一致，上面的流程图有所展示。</p><p><code>Sender</code>内部的函数调用关系如下图所示。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">digraph G &#123;</span><br><span class="line"></span><br><span class="line">  subgraph cluster_0 &#123;</span><br><span class="line">    style=filled;</span><br><span class="line">    color=lightgrey;</span><br><span class="line">    node [style=filled,color=white];</span><br><span class="line">    Start -&gt; Send_Data</span><br><span class="line">    Start -&gt; Receive_ACK</span><br><span class="line">    Send_Data -&gt; pkg_Buffer</span><br><span class="line">    Receive_ACK -&gt; resend</span><br><span class="line">    Receive_ACK -&gt; update_RTO</span><br><span class="line">    Receive_ACK -&gt; update_cwnd</span><br><span class="line">    resend -&gt; pkg_Buffer</span><br><span class="line">    label = &quot;Sender&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Client -&gt; Start </span><br><span class="line">  SubServer -&gt; Start</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Receiver</code>内部的函数调用关系如下图所示。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">digraph F&#123;</span><br><span class="line"></span><br><span class="line">  subgraph cluster_1 &#123;</span><br><span class="line">    node [style=filled];</span><br><span class="line">    Write -&gt; Data_Buffer</span><br><span class="line">    Receive_Data -&gt; Data_Buffer</span><br><span class="line">    Start -&gt; Write</span><br><span class="line">    Start -&gt; Receive_Data</span><br><span class="line">    label = &quot;Receiver&quot;;</span><br><span class="line">    color=blue</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Client -&gt; Start</span><br><span class="line">  SubServer -&gt; Start</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><code>Sender</code>和<code>Receiver</code>的交互如下图所示。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">digraph F&#123;</span><br><span class="line"></span><br><span class="line">  subgraph cluster_0 &#123;</span><br><span class="line">    style=filled;</span><br><span class="line">    color=lightgrey;</span><br><span class="line">    node [style=filled,color=white];</span><br><span class="line">    Send_Data </span><br><span class="line">    Receive_ACK</span><br><span class="line">    label = &quot;Sender&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  subgraph cluster_1 &#123;</span><br><span class="line">    style=filled;</span><br><span class="line">    node [style=filled,color=white];</span><br><span class="line">    Receive_Data</span><br><span class="line">    label = &quot;Receiver&quot;;</span><br><span class="line">    color=lightgrey</span><br><span class="line">  &#125;</span><br><span class="line">  Receive_Data -&gt; Receive_ACK</span><br><span class="line">  Send_Data -&gt; Receive_Data</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="测试结果与讨论"><a class="markdownIt-Anchor" href="#测试结果与讨论"></a> 测试结果与讨论</h2><p>发送的<code>MSS</code>报文大小会影响到传输效果。</p><p>在实测中，<code>MSS</code>太小时，总发包数量过多，尽管一次发包数增加，但无法弥补总包数增多带来的时间上的增加。<code>MSS</code>太大时，接收方难以快速处理接收到的数据包，导致丢包发生，且包太大时，经过中间路由会导致数据包乱序到达，由于接收方必须按序接收，这容易触发发送方的快速重传机制。</p><p>当<code>MSS</code>过小，比如<code>256Byte</code>时，两次传输一个<code>3MB</code>的文件，发送方记录的数据图表如下：</p><p><img src="256.png" alt="256" /></p><p>当<code>MSS</code>为<code>1024Byte</code>时，其记录如下：</p><p><img src="2566.png" alt="2566" /></p><p>这两张图中<code>cwnd</code>曲线很好地符合教科书上的曲线特点。</p><p><img src="re.png" alt="re" /></p><p>这是发送方最后输出的信息。</p><p><img src="se.png" alt="se" /></p><p>这是接收方最后输出的信息，可以看到文件传输无误。</p><p>但当<code>MSS</code>调整为<code>1024 * 10Byte</code>时，发送方记录的数据图表如下：</p><p><img src="1024.png" alt="1024" /></p><p>可以看到，<code>cwnd</code>呈周期性震动，在接收方里的错误信息可以看到</p><p><img src="er.png" alt="er" /></p><p>接收方在接收数据时出现了周期性地数据包丢失，亦或者说是乱序收到，由于接收方必须按序接收，一旦乱序就会重传<code>ACK</code>报文，易让发送方产生多次没必要的超时重传。</p><p><img src="res.png" alt="res" /></p><p>从发送方的结果可以看出，消耗的时间反而更长了，因为期间产生了过多的快速重传机制。</p><p>刚刚传输了一次<code>qwq</code>文件，再次传输时会提示文件已存在，询问用户是否续传：</p><p><img src="qqq.png" alt="qqq" /></p><p>输入<code>1</code>表示续传，而由于文件已经完整，因而就只发了一个终止<code>FIN</code>包，传输就结束了。</p><p>将<code>MSS</code>调整为<code>1024 * 5Byte</code>，结果如下：</p><p><img src="qwe.png" alt="qwe" /></p><p>可以看到，快速重传的次数减少了，但由于发送的数据包的数量增加，总耗时与上面差不多。</p><p><img src="ober.png" alt="ober" /></p><p>仔细观察出现<code>warning</code>的情况，可以推断出并不是包丢了，而是数据包在传输过程中顺序被打乱了，这就导致了之后一连串数据包的错位，此时<code>cwnd</code>的作用就出现了，不断减小的窗口能够很快缓解数据包乱序带来的现象，但这在一定程度上消耗了一定的时间和网络资源来解决这个问题。</p><p>不过好在本程序支持断点续传，此时我们重新启动传输，也可以解决此问题。</p><p>但同样<code>MSS</code>，在内网传输时，结果如下：</p><p><img src="neiwangtu.png" alt="neiwangtu" /></p><p><img src="neiwang.png" alt="neiwang" /></p><p>可以看出内网的网络环境明显优于外网。</p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>通过这次在公网进行文件传输的测试，可以得知外网环境较为复杂，当传输数据包大小较大时，由于外网传输路径的复杂性，期间的路由器等网络设备对数据包的处理可能容易造成乱序，进而影响应用层数据包的接收。同时在出现乱序的现象，我们也看到<code>cwnd</code>阻塞控制所起到的作用：它迅速减少同时发包数量，防止数据包乱序现象的持续。因为此时已经是乱序了，接收端接收到的乱序包混杂了很多重发包，如果这又造成多次<code>ACK</code>重发的话，会进一步触发发送方的快速重传机制，导致这种现象的加剧。</p><p>从实验中我们也发现，丢包现象相对于数据包乱序现象发生次数较小，如果接收方采用选择重传的机制，即不要求数据包要按序收到，允许在一段小的时间内乱序，进而将数据包根据序号重排，这或许能有效减少此种乱序现象导致的回退N步方式的快速重传机制，能有效改善传输的时间。但由于需要缓存收到的数据包，将数据包重组排序，这在一定程度上会占用服务端的<code>CPU</code>资源，当有许多个并发任务传输时对传输的稳定性可能是有一定的影响。</p><p>从这次实验也可以看出来，为了传输的可靠性先人做了许多的措施，在这次代码的编写时，也根据实际情况，对<code>TCP</code>类似机制的实现做了微调，尽管不能完美的解决问题，我们只能接受一定程度上的缺陷，尽可能实现好的效率。在起初的程序设计中，曾为了实现高效可靠的传输斟酌了各种可能的方法，例如考虑握手的实现方式，考虑每一步如果出现差错如何处理，实现选择重传还是回退N步等，超时重传的时间计量应该如何进行，是每个包一个时间还是一个<code>ACK</code>接收间隔一个时间等等，虽然没想到一个能完美无缺的方案，但我们还是得选一个缺陷允许接受的方案实现。或许在未来，网络物理条件改善，在物理链路层能保证可靠传输的话，应该就不需要这些了。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> UDP </tag>
            
            <tag> TCP </tag>
            
            <tag> RTT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Deep Reinforcement Learning for ENAS</title>
      <link href="/posts/2d0ac27e.html"/>
      <url>/posts/2d0ac27e.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>论文复现与改进</p></blockquote><h2 id="experimental-environment"><a class="markdownIt-Anchor" href="#experimental-environment"></a> Experimental Environment</h2><ul><li>OS：Archlinux 5.16.1-arch1-1</li><li>Software：Python 3.10, Cuda 11.5</li><li>Hardware: Intel CORE i5 8th Gen, NVIDIA Geforce GTX 1060</li></ul><h2 id="experimental-problems"><a class="markdownIt-Anchor" href="#experimental-problems"></a> Experimental Problems</h2><ol><li>According to the <a href="https://arxiv.org/abs/1802.03268">paper</a> and the <a href="https://github.com/RualPerez/AutoML">paper reproduction code</a>, please add comments of key step codes.</li><li>Improve the deep reinforcement learning algorithm of reproducing code in this paper. The improved part needs to be different from the policy gradient algorithm of the original paper reproduction code.</li><li>Apply the improved algorithm practical tasks, and illustrate the necessity and superiority of the improved algorithm for practical tasks.</li></ol><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="what-is-neural-architecture-searchnas"><a class="markdownIt-Anchor" href="#what-is-neural-architecture-searchnas"></a> What is Neural Architecture Search(NAS)</h3><p>As is implied by the name, it’s a searching problem. To solve some problems using reinforcement learning methods such as Q-learning, we need to design a network structure to train. Obviously, the quality of the training datas and parameters such as learning rates will affect the training effect, but the network structure is also an indicator of the training effect. So, it’s significant to design a good network structure. In the past, this task was done manually. Now we want to leave the task to a neural network. Yes, let a neural network generate a neural network!</p><p>The neural network can be abstracted into a graph. The direction of the edges represents the flow direction of the input datas, and the points have an activation function, such as <code>softmax</code> and <code>tanh</code>. All the neural network should do is to generate a directed graph and place a activation function on all the points.</p><h3 id="what-is-efficient-neural-architecture-searchenas"><a class="markdownIt-Anchor" href="#what-is-efficient-neural-architecture-searchenas"></a> What is Efficient Neural Architecture Search(ENAS)</h3><p>Well, it’s still a neural architecture search problem, but it’s efficient. How to understand it? In fact, in order to generate a better network, we need to train this neural network, and we regard it as a Controller. For a network generated by it, how to evaluate whether it is good or bad, that is, reward? Train the network! Because of the expensive cost of time to train a network, which will slow down the training speed of the controller, we need to speed up. For example, if a network generated by controller need <code>10</code> hours to train until it convergent, that is, we need <code>10</code> hours to get a reward of the action made by controller. Imagine that you play a game, do an action, and then give you feedback for <code>10</code> hours before you can make the next action, isn’t it very uncomfortable?</p><p>So, how to speed up? We can start with the trained network. The purpose of training the network is to obtain good parameters. Note that the structure of the generated network is similar sometimes, and some parameters can be retained so that there is no need for retraining, which can speed up the convergence of the network. Therefore, the key to improvement is parameter sharing.</p><h3 id="the-framework-of-enas"><a class="markdownIt-Anchor" href="#the-framework-of-enas"></a> The Framework of ENAS</h3><p>According to the <a href="https://arxiv.org/abs/1802.03268">paper</a>, it’s a searching problem. So there will be a searching space. For example, there is a complete graph with four points in the following Figure.</p><p><img src="1.png" alt="A search space" /></p><p>The controller is a Recurrent Neural Network, RNN, which has a flexible length of output and memory of the network outputing before. The task the controller should do is select edges and the activation function on the points. The following Figure is an example of the output of controller: <code>['tanh', 1, 'ReLU', 2, 'ReLU', 1, 'tanh']</code></p><p><img src="2.png" alt="Example output" /></p><p>The first activation function is on the <code>Node 1</code>. And the next two is about the information of <code>Node 2</code>: the data from <code>Node 1</code> will flow to <code>Node 2</code>, and the activation function on <code>Node 2</code> is <code>ReLU</code>, and so on. <code>Node 0</code> is the input and the data on it will always flow to <code>Node 1</code>. And the points which has no output edge is regarded as End Node, and we will mean all the data in End Node and flow to Output Node to get the result.</p><p>From the search space we can see that all the parameters<code>(W, b)</code> of the neural network are on the edges, and when we select an edge at one time and train it. Next time we again select the same edge, the previously trained parameters can be reused.</p><p>So, here is the steps of the whole framework:</p><ol><li>The Controller generate a network, that is, output a sequence such<br />as <code>['tanh', 1, 'ReLU', 2, 'ReLU', 1, 'tanh']</code></li><li>Generate the network according to the sequence.</li><li>Train the network.</li><li>Evaluate the network, get the accuracy</li><li>Controller get the reward, and learning.</li></ol><h3 id="problems-in-the-paper-reproduction-code"><a class="markdownIt-Anchor" href="#problems-in-the-paper-reproduction-code"></a> Problems in the paper reproduction code</h3><p>Frankly speaking, this <a href="https://github.com/RualPerez/AutoML">code</a> is NOT a reproduction of the ENAS parameter sharing paper based on the above introduction at all.</p><h4 id="it-cannt-run"><a class="markdownIt-Anchor" href="#it-cannt-run"></a> It cann’t run</h4><p>This shocked me the most, although the reason why it cann’t run was not fatal.</p><p>For example, in <a href="https://github.com/RualPerez/AutoML/blob/master/training.py">training.py</a>, <code>Line 67</code>, there is a variable named <code>val_freq</code>, but it’s undefined. Also, in <a href="https://github.com/RualPerez/AutoML/blob/master/training.py">training.py</a> and <a href="https://github.com/RualPerez/AutoML/blob/master/childNet.py">chileNet.py</a>, there are some codes using <code>numpy</code> package, which is not imported.</p><h4 id="it-doesnt-have-parameter-sharing"><a class="markdownIt-Anchor" href="#it-doesnt-have-parameter-sharing"></a> It doesn’t have parameter sharing</h4><p>I noticed the <a href="https://github.com/RualPerez/AutoML/issues/28">issues</a>, and I read the <a href="https://github.com/RualPerez/AutoML/blob/master/article.pdf">article</a> written by the author carefully. It doesn’t mention the parameter sharing. Good.</p><p>Every time the controller generate a network, and train it, it will call <code>net.apply(weight_reset)</code> to reset the parameter. See more in <a href="https://github.com/RualPerez/AutoML/blob/master/childNet.py">childNet.py</a>, <code>Line 167</code>.</p><p>It’s just a simple NAS, even a simplified version, which will explain next.</p><h4 id="its-searching-space-is-slightly-different"><a class="markdownIt-Anchor" href="#its-searching-space-is-slightly-different"></a> Its searching space is slightly different</h4><p>Its searching space consist of hidden units, instead of points. That is, its Controller will generate a sequence such as <code>[2, 8, 'tanh', 16, 4 'ReLU', 8, 2]</code>, which means there are six hidden units, whose output size are <code>2, 8, 16, 4, 8, 2</code>. Suppose the input size is <code>10</code>, then it will become size <code>2</code> through the first hidden units, and <code>8</code> through the second hidden units, and activate by <code>tanh</code> function, and become size <code>16</code> through the third hidden units, and so on.</p><p>See more in <a href="https://github.com/RualPerez/AutoML/blob/master/childNet.py">childNet.py</a>, the <code>__init__</code> function of <code>Net</code>.</p><p>Yes, this is a serial network structure, which, in graph terms, is a chain!</p><h4 id="there-is-some-difference-between-code-and-artical"><a class="markdownIt-Anchor" href="#there-is-some-difference-between-code-and-artical"></a> There is some difference between code and artical</h4><p>It encodes the hidden units and activation function into one vector. And for every output probability vector the controller gives, it will sample it by the probability, which means at every time, it’s possible to select a hidden unit or activation function.</p><p>However, in the <a href="https://github.com/RualPerez/AutoML/blob/master/article.pdf">artical</a> it says the data to controller will switch.</p><blockquote><p><em>The lists will be switched depending on the nature of the iteration<br />step, so, for an odd number, the number of hidden units will be fed as<br />the input and for an even number, the type of the activation function<br />chosen is fed as the input to the memory cell of the recurrent neural<br />network.</em></p></blockquote><p>If it is the same as what is said in this article, the output of the controller should be a hidden layer, and the activation functions appear alternately. Obviously, it didn’t.</p><p>See more in <a href="https://github.com/RualPerez/AutoML/blob/master/policy.py">policy.py</a>, <code>forward</code> function.</p><h4 id="redundant-dependency-in-requirementtxt"><a class="markdownIt-Anchor" href="#redundant-dependency-in-requirementtxt"></a> Redundant dependency in requirement.txt</h4><p>The <a href="https://github.com/RualPerez/AutoML/blob/master/requirements.txt">requirements.txt</a> contains so many packages that it didn’t depend. It just needs less than ten packages.</p><h3 id="improvement"><a class="markdownIt-Anchor" href="#improvement"></a> Improvement</h3><p>The main idea of the code is: define a class PolicyNet named Controller, define a class childNet which include a network. Controller generates a network information and give childNet, childNet analies the information and trains the network, gives the network accuracy as reward to Controller. Controller learns using Reinforcement learning and repeated.</p><h4 id="add-parameters-sharing-feature"><a class="markdownIt-Anchor" href="#add-parameters-sharing-feature"></a> Add parameters sharing feature</h4><p>To add this feature, we need to construct a graph. But here is a problem.</p><p>All the points in the graph MUST have the SAME sizes of input and output. For example, the following Figure show the graph we construct with <code>5</code> points.</p><p><img src="3.png" alt="Graph with 5 points" /></p><p>If we select an edge from <code>Node 1</code> to <code>Node 3</code>, it requires that the output size of <code>Node 1</code> and the input size of <code>Node 3</code> <strong>MUST</strong> be the same. The same as <code>Node 1</code> and <code>Node 2</code>, therefor the <code>Node 2</code> and <code>Node 3</code> and so on. All the points must have the same input size and output size, except the input size of <code>Node 1</code> because the data from <code>Node 0</code>, which is our input, will only flow to <code>Node 1</code>.</p><p>Also, the direction of edge is always from small Node to large Node, which can confirm the graph is valid, that is, a connected acyclic graph.</p><p>I construct a Net when define chileNet.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">input_edge = nn.Linear(num_features, hidden_features).to(<span class="variable language_">self</span>.__device)</span><br><span class="line">hidden_edge = [nn.Linear(hidden_features, hidden_features).to(<span class="variable language_">self</span>.__device) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(layer_limit * (layer_limit - <span class="number">1</span>) // <span class="number">2</span>)]</span><br><span class="line">output_edge = nn.Linear(hidden_features, num_classes).to(<span class="variable language_">self</span>.__device)</span><br><span class="line"><span class="variable language_">self</span>.net = nn.ModuleList([input_edge, *hidden_edge, output_edge]).to(<span class="variable language_">self</span>.__device)</span><br></pre></td></tr></table></figure><p>The parameters on the edges will not be reseted every training. So it’s parameters sharing.</p><h4 id="change-chains-to-graph"><a class="markdownIt-Anchor" href="#change-chains-to-graph"></a> Change chains to Graph</h4><p>For the network information named layers given by Controller, childNet will analizy it and train the network.</p><p>For example, suppose the layers be <code>[&quot;tanh&quot;, 1, &quot;ReLU&quot;]</code>. For the odd position, it should be the source Node, and for the even position, it should be the activation function.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> pos, layer <span class="keyword">in</span> <span class="built_in">enumerate</span>(layers):</span><br><span class="line">        <span class="keyword">if</span> layer == <span class="string">&#x27;EOS&#x27;</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> pos &amp; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(layer, <span class="built_in">str</span>):</span><br><span class="line">                <span class="keyword">raise</span> Exception(<span class="string">&quot;Network WRONG! Expect int but found str&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> layer <span class="keyword">not</span> <span class="keyword">in</span> value_node:</span><br><span class="line">                <span class="keyword">raise</span> Exception(<span class="string">&quot;Network WRONG! Index Large&quot;</span>)</span><br><span class="line">            <span class="comment"># data flow from layer to index_node</span></span><br><span class="line">            val[index_node] = <span class="variable language_">self</span>.net[<span class="variable language_">self</span>.hidden_edge(layer, index_node)](val[layer])</span><br><span class="line">            <span class="comment"># now index_node has value</span></span><br><span class="line">            value_node.add(index_node)</span><br><span class="line">            <span class="comment"># the data from layer is translated to index_node, so the layer&#x27;s data cann&#x27;t be the result data</span></span><br><span class="line">            <span class="keyword">if</span> layer <span class="keyword">in</span> end_node:</span><br><span class="line">                end_node.remove(layer)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(layer, <span class="built_in">int</span>):</span><br><span class="line">                <span class="keyword">raise</span> Exception(<span class="string">&quot;Network WRONG! Expect str but found int&quot;</span>)</span><br><span class="line">            <span class="comment"># activate the value of index_node</span></span><br><span class="line">            val[index_node] = activation_functions[layer](val[index_node])</span><br><span class="line"></span><br><span class="line">            index_node = index_node + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>Function <code>hidden_edge(st, ed)</code> will give back the network edge which starting from Node st to Node ed.</p><p>Acutually, we need to control the data flow in network because it’s not serial. So we need to record the values on EVERY point instead of the current point.</p><p>And finally, get the average of all the values of End Node and get the result, finishing one whole forwarding.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># just let result be the same variable type as x</span><br><span class="line">result = val[1]</span><br><span class="line">for end in end_node:</span><br><span class="line">    # sum up all value of the end node</span><br><span class="line">    result = result + val[end]</span><br><span class="line">result = result - val[1];</span><br><span class="line"></span><br><span class="line"># calculate the mean</span><br><span class="line">result = result / len(end_node)</span><br><span class="line"></span><br><span class="line"># calculate the output(classes)</span><br><span class="line">return self.net[-1](result)</span><br></pre></td></tr></table></figure><p>It seems little complex, because the network structure isn’t serial anymore, and we need to forward it manually.</p><h4 id="use-priority-replay"><a class="markdownIt-Anchor" href="#use-priority-replay"></a> Use Priority Replay</h4><p>There is something special in this problem. We can get the reward only after the whole actions made. So the criti-actor network may not be useful to improve the performance of the controller. Besides Policy Grident, which the Controller uses, there are other methods like Proximal Policy Optimization(PPO), an off-policy method, and Deterministic Policy Gradient(DPG), and more, Deep Deterministic Policy Gradient(DDPG), an continuous-action-suitable method. Here I implement a method similar to Proximal Policy Optimization, that is, reuse the past experience.</p><p>Because some experience may be important, such as high-reward action, we should let the controller learning from them sometimes so that it can performan better. So for every some eposes, we will let controller sample from memory.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># get the result</span></span><br><span class="line"><span class="keyword">if</span> i &gt; Memory_replay <span class="keyword">and</span> i % Memory_replay == <span class="number">0</span>:</span><br><span class="line">    m_index, prob, actions, m_reward, _ = memory_pool.sample(batch_size)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    prob, actions = policy(training)</span><br></pre></td></tr></table></figure><p>Every experience has a priority defined by its reward, and sampled in a probabilistic manner according to the priority.</p><p>We use a data structure named sumtree to implementation, as shown in the following Figure. Its idea is simple: cut a line into many parts and place the experience on it. And the length of the part depend on its priority. And randomly chose a position, and sample the experience to which the position belongs. And we use a tree structure to maintain the experience adding and priority updating.</p><p><img src="sumtree.png" alt="Sumtree" /></p><h4 id="using-cuda-to-speed-up-training"><a class="markdownIt-Anchor" href="#using-cuda-to-speed-up-training"></a> Using Cuda to Speed up training</h4><p>It is very common to use GPU to speed up training, and thanks to <a href="https://pytorch.org">Pytorch</a>, it’s very easy to train it on GPU, that is, transfer the data from RAM to GPU, and let GPU process.</p><p>According to the actual measurement, which will explain next, it takes <code>16 hours</code> to complete <code>500 eposes</code> of training with CPU and only <code>2 hours</code> with GPU. It’s nearly eight times faster.</p><h3 id="result"><a class="markdownIt-Anchor" href="#result"></a> Result</h3><p>In order to better show the effect of the improvement, I will test them in emotion classification, a typical problem in the field of Natural Language Processing(NLP).</p><p>The <a href="https://www.kaggle.com/lakshmi25npathi/imdb-dataset-of-50k-movie-reviews">data(click to download)</a><br />are reviews of movies, and they are all labled to indicate whether they are positive or negative. We need to train a neural network so that for a movie review, the network can tell us whether it is positive or negative.</p><p>And the task the controller should do is to generate a good network structure.</p><p>And the task we should do is to train the controller so that it will generate a good network with good parameters.</p><p>After the cleaning of data and encoding using <a href="https://dl.fbaipublicfiles.com/fasttext/vectors-english/wiki-news-300d-1M.vec.zip">word2vec</a>, we get a vector represented a review which can be input into network.</p><p>Due to the limitation of time and the performance of GPU, I use the first <code>1000</code> reviews, in which the first <code>600</code> is used as trained datas and the next <code>400</code> is used as test datas. After <code>500</code> eposes, and batch size <code>4</code>, using three version: origin version, improved version, improved + replay version, here is the result.</p><p><img src="accuracy.png" alt="Accuracy" /></p><p>The above Figure show the accuracy of the network generated by Controller and the following Figure  show the reward and loss of Controller.</p><p><img src="reward.png" alt="reward" /></p><p><img src="loss.png" alt="loss" /></p><p>It’s clearly that the <a href="https://github.com/RualPerez/AutoML">origin version</a> is very funny. Although it trains very fast—only 30 minutes using CPU, but seems to learn nothing. I just fix the bugs mention above and run it. And the version with replay performs slightly better than the version without replay. It can see that in eposes 500 the version with replay still has an upward trend.</p><h3 id="conclusion"><a class="markdownIt-Anchor" href="#conclusion"></a> Conclusion</h3><p>From this result, I know the necessity of my improvement: modify the network structure, increase parameter sharing, and add memory replay. Maybe the reason of the poor performance at starting is the insufficient training due to the device performance limited. But thanks to the parameters sharing, the parameters can be trained next time the new network generated, the accuracy and the reward will improve. Also, with reinforcement learning, the Controller can learn from network structure better. From the NLP practics, it’s useful for us to find a good network structure using the improved Controller.</p><p>Use a neural network to generate a neural network is an amazing thing. There is still some thing can be improved such as loading trained model, using more efficient policy gradient.</p><p>You can access the code in <a href="https://github.com/Lanly109/ENAS">my github</a>.</p><h3 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> Reference</h3><ul><li>Xuanyi Dong,David Jacob Kedziora, Katarzyna Musial, and Bogdan Gabrys. Automated deep learning: Neural architecture search is not the end. CoRR, abs/2112.09245, 2021.</li><li>Zhenhan Huang, Chunheng Jiang, Pin-Yu Chen, and Jianxi Gao. Network graph based neural architecture search. CoRR, abs/2112.07805, 2021.</li><li>Hieu Pham, Melody Y. Guan, Barret Zoph, Quoc V. Le, and Jeff Dean. Efficient neural architecture search via parameter sharing. CoRR, abs/1802.03268, 2018.</li><li>Kaixiong Zhou, Qingquan Song, Xiao Huang, and Xia Hu. Auto-gnn: Neural architec- ture search of graph neural networks. CoRR, abs/1909.03184, 2019.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 强化学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ENAS </tag>
            
            <tag> Python </tag>
            
            <tag> Cuda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webots——Fianl大作业</title>
      <link href="/posts/10a3c0f3.html"/>
      <url>/posts/10a3c0f3.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Webots期末大作业的实验报告</p></blockquote><p>仓库地址：<a href="https://github.com/Lanly109/Webots-Homework/tree/master/Final_project">github</a></p><h3 id="一-实验工作"><a class="markdownIt-Anchor" href="#一-实验工作"></a> 一、实验工作</h3><p>本次实验我们根据要求并尝试拓展，我们完成了以下部分工作：</p><ul><li>自己设计了一套基于<code>Lidar</code>的感知方法，基本思想是通过延迟统计，将累计击中一定次数的点判断为障碍物，以消除局部畸变带来的影响（没有直接使用助教提供的感知方法）；</li><li>动态路径规划部分采用了<code>D*</code>算法，在能完成动态路径规划的基本功能外考虑时间空间开销，使每次规划只需要考虑变化的局部情况，达到更快更好的相应效果；</li><li>运动控制部分采用了<code>PID</code>闭环控制，并尝试了多种<code>PID</code>，包括单环<code>PID</code>（位置环<code>PID</code>、速度环<code>PID</code>），以及双环<code>PID</code>（<code>位置-速度串级PID</code>）。在比较之后以小车当前位姿信息为反馈控制量构成闭环 PID 控制算法。</li></ul><h3 id="二-实验环境"><a class="markdownIt-Anchor" href="#二-实验环境"></a> 二、实验环境</h3><ul><li><code>OS</code>：Windows 11、MacOS</li><li><code>仿真平台</code>：Webots 2021a</li><li><code>编程语言</code>：C++</li></ul><h3 id="三-webots元件"><a class="markdownIt-Anchor" href="#三-webots元件"></a> 三、Webots元件</h3><p>小车采用麦克纳姆轮，一种全向轮的方式前进，避免了小车旋转行为，简化了雷达建模操作。</p><p>小车用到的元件有：</p><ul><li>麦克纳姆轮，提供全方位的行走</li><li>GPS，提供小车的位置，便于在离散化的图中定位以及解析雷达数据</li><li>inertial，提供小车的方向，便于判断和保持小车方向不变</li><li>lidar，感知周围障碍物的距离，建立局部地图</li><li>display，用于显示小车感知的障碍物（红色），小车的轨迹（蓝色），小车目前搜寻的最优路径（绿色）</li></ul><h3 id="四-感知部分"><a class="markdownIt-Anchor" href="#四-感知部分"></a> 四、感知部分</h3><p>本次实验采用激光雷达对环境进行感知。</p><h4 id="41-算法介绍"><a class="markdownIt-Anchor" href="#41-算法介绍"></a> 4.1 算法介绍</h4><p>感知算法参考的是<a href="https://baike.baidu.com/item/SLAM/7661974">SLAM技术原理</a>。</p><p>这里利用的是webots的lidar元件，设置为全向感知，感知层为1，去除了高度信息，以生成一张二维地图。设置项<code>horizontalResolution</code>表示感知的精度，<code>maxrange</code>表示感知的范围。</p><p><img src="lidar.png" alt="lidar" /></p><p>lidar的返回值可以通过函数<code>const float *dis = lidar-&gt;getRangeImage();</code>获得，其数组表示的是雷达检测到的各方向的距离障碍物的距离。</p><p><img src="zhangai.png" alt="zhangai" /></p><p>如图所示，<code>dis[0]</code>表示的值为箭头方向，然后随着下标变大，表示的方向为顺时针方向变化。其中如果某方向没有障碍物的话，其距离值同<code>maxrange</code>。</p><p>但由于雷达数据不稳定以及运动会造成雷达数据的畸变，我们采取了如下操作来生成一张较为完好的图。</p><ul><li>保证小车的方向不变。因为雷达数据的解析是基于上述小车，一旦小车方向发生偏转，其解析的雷达数据的方位也发生相应的偏转，因此首要做的是保证小车的方向稳定。</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> *yaw = inertial-&gt;<span class="built_in">getRollPitchYaw</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">fabs</span>(yaw[<span class="number">0</span>] - front) &gt;= <span class="number">0.05</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> dir = (yaw[<span class="number">0</span>] &lt; front &amp;&amp; yaw[<span class="number">0</span>] &gt; -front ? <span class="number">-1</span> : <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        speed3[i] = speed_rightCircle[i] * dir;</span><br><span class="line">        motors[i]-&gt;<span class="built_in">setVelocity</span>(speed3[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">        speed3[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>inertial</code>获取小车当前的角度<code>yaw</code>，一旦与我们预设的角度<code>front</code>发生了偏转，则停止当前所有的行为，优先对小车进行旋转，姿态调整回原来的状态，并且会根据当前偏离角度选择最快的方向调整回来。</p><ul><li>保证小车方向不变后，对于每次时间戳，我们解析雷达数据，并转换到离散坐标系下，但此时并不作障碍物的判断，仅仅增加某位置障碍物的计数。</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">count++;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> *pos = gps-&gt;<span class="built_in">getValues</span>();</span><br><span class="line"><span class="type">const</span> <span class="type">float</span> *dis = lidar-&gt;<span class="built_in">getRangeImage</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算障碍的计数</span></span><br><span class="line">slam.<span class="built_in">add</span>(lidar_point_count, dis, pos[<span class="number">0</span>], pos[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加计数, 计数大于一定阈值才判定为障碍</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> total, <span class="type">const</span> <span class="type">float</span> *dis, <span class="type">double</span> x, <span class="type">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; total; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sign</span>(dis[i] - max_range) == <span class="number">0</span>)<span class="comment">// 此处无障碍</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">auto</span> [ny, nx] = <span class="built_in">real_to_pic</span>(x + dis[i] * <span class="built_in">cos</span>(st - i * unit),</span><br><span class="line">                                    y + dis[i] * <span class="built_in">sin</span>(st - i * unit));</span><br><span class="line">        <span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; ny &lt; m)</span><br><span class="line">            cnt[nx][ny]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>每隔一定时间<code>update_up</code>后，再更新地图。在这里是每采取<code>update_up</code>次雷达数据后，对某位置有<code>up</code>次障碍物记录的位置才标记为障碍物，并在<code>display</code>中绘制出来。</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (count == update_up)</span><br><span class="line">&#123;</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    slam.<span class="built_in">update</span>(display);<span class="comment">// 更新地图</span></span><br><span class="line">    pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; tmp = slam.<span class="built_in">real_to_pic</span>(pos[<span class="number">0</span>], pos[<span class="number">1</span>]);<span class="comment">// 当前位置</span></span><br><span class="line">    dstar.<span class="built_in">update</span>(tmp.first, tmp.second, display);<span class="comment">// 重新规划路径</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">loadPath</span>(&amp;dstar, &amp;path);</span><br><span class="line"></span><br><span class="line">    idx = <span class="number">0</span>; <span class="comment">// 下标重置</span></span><br><span class="line">    pos_pid.<span class="built_in">init</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过计数更新障碍</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(Display *display)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    display-&gt;<span class="built_in">setColor</span>(RED);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt[i][j] &gt;= up)<span class="comment">// 当前位置超过up次记录有障碍物</span></span><br><span class="line">            &#123;</span><br><span class="line">                occupy[i][j] = <span class="number">1</span>;</span><br><span class="line">                display-&gt;<span class="built_in">drawPixel</span>(j, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="built_in">memset</span>(cnt[i], <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="type">int</span>) * m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绘制出的示例图如下。</p><p><img src="example.png" alt="example" /></p><h3 id="五-规划部分"><a class="markdownIt-Anchor" href="#五-规划部分"></a> 五、规划部分</h3><h4 id="51-算法介绍"><a class="markdownIt-Anchor" href="#51-算法介绍"></a> 5.1 算法介绍</h4><p>D* 算法全称为 dYnamic A* 算法, 最初由 AnthonY Stentz 于论文 ““Optimal and Efficient Path Planning for PartiallY-Known Environments”” 中提出. D* 算法是一种启发式的路径搜索算法,适合面对周围环境未知或者周围环境存在动态变化的场景, 所以它特别契合于本次实验的要求.</p><p>具体介绍 D* 算法的论文链接为: <a href="http://web.mit.edu/16.412j/www/html/papers/original_dstar_icra94.pdf">点击</a></p><p>与 Dijkstra 的算法和 A* 一样,D* 维护着一个要评估的节点列表,称为&quot;OPEN list&quot;. 它是按照节点到达终点的代价来进行排序的, 节点到达终点的代价越小, 优先级越大. 节点被标记为具有以下几种状态之一：</p><ul><li>NEW,这意味着它从未被列入开放列表</li><li>OPEN,表示它当前在 OPEN 列表中</li><li>CLOSED,这意味着它已经进入 OPEN 列表并被 OPEN 列表所移除</li></ul><p>D* 算法基于 A* 算法进行规划, 工作原理是每一轮从 OPEN 列表中迭代选择一个优先级最高, 也就是代价最低的节点并对其进行评估和邻居的拓展.</p><p>与 A* 算法不同的是,  D* 算法是从终点开始进行反向搜索的, 这也体现了为什么 D* 算法适用于感知周围未知环境的原因. D* 首先会进行一条初始路径的找寻, 并对于每个节点都维护一条指向终点的路径. 具体来说, 从作为根节点的终点出发, 每个节点都指向其到达终点路径上的下一个节点作为其父节点. 这个过程基于 A* 算法的思路, 我们将到达终点的欧几里得距离作为启发函数, 并最终搜索到起点为止.</p><p>之后小车按照初始路径进行行进, 行进过程中不断感知周围的环境. 在周围环境发生变化需要重新规划的时候, 也就是小车发现当前节点指向的下一个节点是一个无法逾越的障碍时, 它就会在局部寻找其他的能够到达终点的节点, 重新更改它为当前节点指向的父节点, 这个过程是递归的过程, 会像一条波浪一样重新影响到整一条路径, 并最终到达终点, 从而实现了路径的重新规划操作.</p><p>根据节点状态的变化情况具体来说, 当其 cost 高于上次在 OPEN 列表中时设其为 RAISE 状态, 表示其 cost 小于等于上次在 OPEN 列表中时设其为 LOWER 状态. 当沿预期路径检测到障碍物时,所有受影响的点将再次放置在 OPEN 列表中,这次标记为 RAISE.但是,在 RAISE 节点成本增加之前,该算法会检查其邻居并检查它是否可以降低节点的成本.如果不是,则将 RAISE 状态传播到所有节点的后代,即具有指向它的到达终点路径上指向的节点.然后对这些节点进行评估,并将 RAISE 状态传递,形成波浪.当可以减少 RAISE 节点时,将更新其路径上的父节点,并将 LOWER 状态传递给其邻居.这些上升和降低状态的波浪是 D* 的核心.此时,一系列其他点被海浪&quot;触及&quot;.因此,该算法仅适用于受成本变化影响的点.</p><p>D* 算法和 A* 算法另一个区别就是 D* 算法能够快速的进行重新规划. 在小车遇到障碍后, A* 算法需要进行全局的重新规划, 而 D* 算法只需要进行局部的更改就能够生成新的路径, D* 算法的效率较高. 美国火星探测器核心的寻路算法就是采用的 D* 算法.</p><h4 id="52-算法详细说明"><a class="markdownIt-Anchor" href="#52-算法详细说明"></a> 5.2 算法详细说明</h4><h5 id="521-符号及函数说明"><a class="markdownIt-Anchor" href="#521-符号及函数说明"></a> 5.2.1 符号及函数说明</h5><p>D* 算法维护一个 OPEN list, 它是一个可以用来做广度优先搜索的队列. 由于我们从终点开始反向搜索, 所以一开始 OPEN list 中只有一个终点.</p><p>节点的标识tag分为三类：没有加入过open表的(<strong>new</strong>)、在open表的(<strong>open</strong>)、曾经在open表但现在已经被移走的 (<strong>closed</strong>). 一开始所有的节点都设置为 new 状态.</p><p>每个节点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> 到终点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span> 的代价为函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span> 所计.两个节点之间的开销为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><mi>s</mi><mi>t</mi><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">cost(X,Y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span></span></span>,节点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> 到终点的代价 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span>为上一个节点(父节点)<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h(Y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span></span></span> 到终点的代价加上两个节点之间的开销. 所以我们有下列式子成立.</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><mi>h</mi><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>+</mo><mi>c</mi><mi>o</mi><mi>s</mi><mi>t</mi><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h(X)=h(Y)+cost(X,Y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span></span></span></span></p><p>对于每个节点来说, 我们除了维护它的实际代价, 还需要维护它的的最小代价, 用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 进行表示. 更准确的说, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">k(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span> 表示了节点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> 在全图环境中到目标 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span> 点的最小代价.</p><p>在计算和更新过程中,</p><ul><li>对于标识为 new 的点,我们设置 k 与 h 相等, 即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mi>h</mi></mrow><annotation encoding="application/x-tex">k=h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span></span></span></span>.</li><li>对于标识为 open 的点,对于新到来的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span></span></span></span> 值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub></mrow><annotation encoding="application/x-tex">h_{new}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, 我们设置 k 为 h 的历史最小值, 即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>k</mi><mo separator="true">,</mo><msub><mi>h</mi><mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">k=min(k,h_{new})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>.</li><li>对于closed的点,对于新到来的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span></span></span></span> 值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub></mrow><annotation encoding="application/x-tex">h_{new}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, 我们设置 k 为原来 h 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub></mrow><annotation encoding="application/x-tex">h_{new}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的较小值,  我们有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>h</mi><mo separator="true">,</mo><msub><mi>h</mi><mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">k=min(h,h_{new})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>.</li></ul><p>之后会把受影响的节点状态设置为 OPEN, 并放到 OPEN list 中. 这个过程通过下列函数实现.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向 OPEN list 插入更新的节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> Y, <span class="type">double</span> h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> k;</span><br><span class="line">    <span class="keyword">if</span> (state[Y][x] == NEW)</span><br><span class="line">    &#123;</span><br><span class="line">        k = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (state[Y][x] == OPEN)</span><br><span class="line">    &#123;</span><br><span class="line">        k = <span class="built_in">min</span>(kscore[Y][x], h);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (state[Y][x] == CLOSED)</span><br><span class="line">    &#123;</span><br><span class="line">        k = <span class="built_in">min</span>(hscore[Y][x], h);</span><br><span class="line">    &#125;</span><br><span class="line">    kscore[Y][x] = k;</span><br><span class="line">    hscore[Y][x] = h;</span><br><span class="line">    state[Y][x] = OPEN;</span><br><span class="line">    OPEN list.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(Y, x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法最主要的是函数是 process_state 函数,前者用于计算到目标G的最优路径. 它的具体细节我们会在后面介绍.</p><h5 id="522-首次搜索"><a class="markdownIt-Anchor" href="#522-首次搜索"></a> 5.2.2 首次搜索</h5><p>将终点置于 OPEN list 中,采用 A* 算法进行搜索,直到搜索到了起点,整个过程结束.搜索结束后,每个搜索过的节点标识为closed,每个节点的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mi>h</mi></mrow><annotation encoding="application/x-tex">k=h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span></span></span></span>,其父节点为邻域中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 值最小的那个.</p><p>当搜索结束后,可以通过从起点开始找父节点,一路搜索到终点.若搜索结束时 OPEN list 不为空,则里头的节点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span></span></span></span> 的值必然不必起点的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span></span></span></span> 值小. 也就是说, 搜索到起点离开 OPEN list时, 首次搜索就已经结束了, 我们得到了一条从起点到达终点的路径. 但是 OPEN list 中还可能存在着代价比起点更高的节点仍未被拓展.</p><h5 id="523-碰到障碍"><a class="markdownIt-Anchor" href="#523-碰到障碍"></a> 5.2.3 碰到障碍</h5><p>若当前点的下一个点（父节点）为障碍,修改其 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span></span></span></span> 值并将其放入 OPEN list 中(如果是墙的话就修改为墙的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span></span></span></span> 值,比如无穷大),但其<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 值仍旧不变,即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>k</mi><mo separator="true">,</mo><msub><mi>h</mi><mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">k=min(k,h_{new})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>,所以该点会被优先取出并且扩散展开.</p><p>扩散过程需要利用到论文中的伪代码 process-state,直到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>≤</mo><msub><mi>k</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">h\le k_{min}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> . 也就是如果扩散到某个节点的时候,计算后的h值不比其上次的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 值小,该点就可以结束对外扩散了.</p><h5 id="524-整体框架"><a class="markdownIt-Anchor" href="#524-整体框架"></a> 5.2.4 整体框架</h5><p>D* 算法实现的整体框架如下所示.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dstar</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> start_x, start_y, end_x, end_y, cur_x, cur_y;<span class="comment">// 开始位置, 结束位置, 当前位置</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m, n;<span class="comment">// 地图大小</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> stay, flag, turn;<span class="comment">// 用来解决卡墙问题的变量</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> **state, **nxt_x, **nxt_y;<span class="comment">// 节点当前状态</span></span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> **hscore, **kscore;<span class="comment">// h值和k值</span></span><br><span class="line"></span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; openlist;<span class="comment">// OPEN list</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 八个方向的邻居</span></span><br><span class="line">    <span class="type">int</span> dx[<span class="number">8</span>] = &#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    dy[<span class="number">8</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; path;<span class="comment">// 记录路径</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存初始化</span></span><br><span class="line">    <span class="built_in">Dstar</span>(<span class="type">int</span> start_x, <span class="type">int</span> start_y, <span class="type">int</span> end_x, <span class="type">int</span> end_y, <span class="type">int</span> m, <span class="type">int</span> n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回收内存</span></span><br><span class="line">    ~<span class="built_in">Dstar</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到OPEN list中最小k值</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">get_mink</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到OPEN list中最小k值对应的节点</span></span><br><span class="line">    <span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">get_min_state</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向 OPEN list 插入更新的节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">double</span> h)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点处理函数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">process_state</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制路径</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">(Display *display)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除上次绘制的路径, 实现路径的动态变化</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">drawclear</span><span class="params">(Display *display)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成路径</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">generate_path</span><span class="params">(Display *display)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化路径</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">(Display *display)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取路径</span></span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">get_path</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遇到障碍物时进行路径更新</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> cur_x, <span class="type">int</span> cur_y, Display *display)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新计算节点cost</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify_cost</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新计算节点cost, 并递归更新受影响的其他节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断一个点是否在障碍上</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">obstacle</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算两点之间的距离</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">calDis</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="525-process_state-函数"><a class="markdownIt-Anchor" href="#525-process_state-函数"></a> 5.2.5 process_state 函数</h5><p>process_state 函数是 D* 算法中的关键函数. 它用于处理节点之间的状态改变, 分支中包含了首次搜索以及遇到障碍物时的节点处理操作. 伪代码如下所示.</p><p><img src="https://www.freesion.com/images/662/656a42495900768b814698d011c125d6.png" alt="" /></p><p>一开始从 OPEN list 中获取<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>值最小的节点,并移除该点.对该点进行分类处理,遍历其邻域,看是否需要修改父节点、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span></span></span></span> 值及添加到 OPEN list 中,分类大体如下：<br />首先进行一次 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>k</mi><mrow><mi>o</mi><mi>l</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">k_{old}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span> 的判断,看 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> 的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span></span></span></span> 值是否需要调整：如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>k</mi><mrow><mi>o</mi><mi>l</mi><mi>d</mi></mrow></msub><mo>&lt;</mo><mi>h</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">k_{old}&lt;h(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span> : 说明该节点受到障碍的影响,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> 处于 RAISE 状态,可以设想 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> 突变为墙时 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span></span></span></span> 值上升,或者其父节点受到突变为墙的节点影响,导致 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span></span></span></span> 值升高,最后影响到了它. 然后遍历其邻域,如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> 点的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span></span></span></span> 值没有上升,并且 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> 的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span></span></span></span> 值能通过该点变得更小.上述情况,那就修改 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> 的父节点为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>, 重置其 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span></span></span></span> 的值.</p><p>然后再重新判断,看 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> 的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span></span></span></span> 值是否需要调整：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>k</mi><mrow><mi>o</mi><mi>l</mi><mi>d</mi></mrow></msub><mo>=</mo><mi>h</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">k_{old}=h(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span>: 处于第一遍遍历的阶段,或者该节点x并没有受到障碍影响. 然后遍历其邻域,if 后面的判断代表：</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> 第一次被遍历到；</li><li>或者 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> 的父节点是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>,但是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h(Y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>+</mo><mi>c</mi><mi>o</mi><mi>s</mi><mi>t</mi><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h(X)+cost(X,Y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span></span></span> 值却不等, 由于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>k</mi><mrow><mi>o</mi><mi>l</mi><mi>d</mi></mrow></msub><mo>=</mo><mi>h</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">k_{old}=h(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span> ,这说明 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h(Y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span></span></span> 被更改了,但是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span> 还没有变；</li><li>又或者 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> 的父节点不是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>, 但是如果让X成为其父节点将拥有更小的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h(Y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span></span></span> 值.</li></ul><p>上述三种情况都应该根据 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> 的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span></span></span></span> 值调整 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> 的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h(Y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span></span></span> 值,并将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> 作为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> 的父节点,并将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> 添加到 OPEN list中.</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>k</mi><mrow><mi>o</mi><mi>l</mi><mi>d</mi></mrow></msub><mo mathvariant="normal">≠</mo><mi>h</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">k_{old}\neq h(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span>: 说明该节点受到影响,遍历其邻域.</p><ul><li>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> 为第一次遍历到的点；或者 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> 的父节点, 但是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h(Y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>+</mo><mi>c</mi><mi>o</mi><mi>s</mi><mi>t</mi><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h(X)+cost(X,Y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span></span></span> 值却不等, 这说明 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span> 被更改了,但是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h(Y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span></span></span> 还没有变；</li></ul><p>上述情况应该根据 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> 的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span></span></span></span> 值调整 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> 的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h(Y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span></span></span> 值,并将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> 作为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> 的父节点,并将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> 添加到 OPEN list中.</p><ul><li>如果 Y 的父节点不是X,但是让X成为其父节点将拥有更小的h(Y)值.上述情况应该应该调整x的h值,并将x添加到open表中.</li><li>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> 的父节点不是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>,但是让Y成为X父节点, X将拥有更小的h(x)值,并且Y被已经被open表移除,且h(Y)值在上升(即Y受到影响).</li></ul><p>上述情况应该应该调整Y的h值,并将Y添加到open表中.</p><p>具体代码如下所示.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 节点处理函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">process_state</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 取所有节点中 k 值最小的</span></span><br><span class="line">    pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; tmp = <span class="built_in">get_min_state</span>();</span><br><span class="line">    <span class="type">int</span> Y = tmp.first, x = tmp.second;</span><br><span class="line">    <span class="comment">// OPEN list 为空,结束</span></span><br><span class="line">    <span class="keyword">if</span> (Y == <span class="number">-1</span> &amp;&amp; x == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得该点k值,并将该点弹出Openlist队列</span></span><br><span class="line">    <span class="type">double</span> h = hscore[Y][x], k = kscore[Y][x];</span><br><span class="line">    state[Y][x] = CLOSED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该点 X 处于 RAISE 状态</span></span><br><span class="line">    <span class="keyword">if</span> (k &lt; h)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//遍历邻域节点 Y</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (x + dx[i] &lt; <span class="number">0</span> || x + dx[i] &gt;= m)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (Y + dY[i] &lt; <span class="number">0</span> || Y + dY[i] &gt;= n)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> extend_x = x + dx[i], extend_Y = Y + dY[i];</span><br><span class="line">            <span class="type">double</span> cost = <span class="built_in">calDis</span>(x, Y, extend_x, extend_Y);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遇到障碍重新设置其 h 值和 k 值</span></span><br><span class="line">            <span class="keyword">if</span> (stop[extend_Y][extend_x] || <span class="built_in">obstacle</span>(extend_x, extend_Y))</span><br><span class="line">            &#123;</span><br><span class="line">                hscore[extend_Y][extend_x] = kscore[extend_Y][extend_x] =</span><br><span class="line">                    <span class="number">1e6</span>;</span><br><span class="line">                stop[extend_Y][extend_x] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Y 不处于RAISE 状态,且用其更新x后,X 的 h 值更小, 那么就更新 X 的父节点及其 h 值</span></span><br><span class="line">            <span class="keyword">if</span> (hscore[extend_Y][extend_x] &lt;= k &amp;&amp;</span><br><span class="line">                hscore[Y][x] &gt; hscore[extend_Y][extend_x] + cost)</span><br><span class="line">            &#123;</span><br><span class="line">                nxt_x[Y][x] = extend_x, nxt_Y[Y][x] = extend_Y;</span><br><span class="line">                hscore[Y][x] = hscore[extend_Y][extend_x] + cost;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该点 X 处于 LOWER 状态</span></span><br><span class="line">    <span class="keyword">if</span> (k == h)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 遍历邻域节点Y</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (x + dx[i] &lt; <span class="number">0</span> || x + dx[i] &gt;= m)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (Y + dY[i] &lt; <span class="number">0</span> || Y + dY[i] &gt;= n)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> extend_x = x + dx[i], extend_Y = Y + dY[i];</span><br><span class="line">            <span class="type">int</span> back_flag = (nxt_x[extend_Y][extend_x] == x &amp;&amp;</span><br><span class="line">                             nxt_Y[extend_Y][extend_x] == Y);</span><br><span class="line">            <span class="type">double</span> cost = <span class="built_in">calDis</span>(x, Y, extend_x, extend_Y);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 分以下三种情况</span></span><br><span class="line">            <span class="comment">// Y是首次添加到OPEN list并处理</span></span><br><span class="line">            <span class="comment">// Y是X的子节点,并且其h值不需要改变</span></span><br><span class="line">            <span class="comment">// Y不是X的子节点,并且其h值可以变得更小</span></span><br><span class="line">            <span class="keyword">if</span> (state[extend_Y][extend_x] == NEW ||</span><br><span class="line">                (back_flag &amp;&amp;</span><br><span class="line">                 hscore[extend_Y][extend_x] != hscore[Y][x] + cost) ||</span><br><span class="line">                (!back_flag &amp;&amp;</span><br><span class="line">                 hscore[extend_Y][extend_x] &gt; hscore[Y][x] + cost))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 将X作为Y的父节点,修改其h值,并将Y点添加到Openlist中</span></span><br><span class="line">                nxt_x[extend_Y][extend_x] = x,</span><br><span class="line">                nxt_Y[extend_Y][extend_x] = Y;</span><br><span class="line">                <span class="built_in">insert</span>(extend_x, extend_Y, hscore[Y][x] + cost);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 遍历邻域节点Y</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (x + dx[i] &lt; <span class="number">0</span> || x + dx[i] &gt;= m)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (Y + dY[i] &lt; <span class="number">0</span> || Y + dY[i] &gt;= n)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> extend_x = x + dx[i], extend_Y = Y + dY[i];</span><br><span class="line">            <span class="type">int</span> back_flag = (nxt_x[extend_Y][extend_x] == x &amp;&amp;</span><br><span class="line">                             nxt_Y[extend_Y][extend_x] == Y);</span><br><span class="line">            <span class="type">double</span> cost = <span class="built_in">calDis</span>(x, Y, extend_x, extend_Y);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 分以下两种情况</span></span><br><span class="line">            <span class="comment">// Y是首次添加到OPEN list并处理</span></span><br><span class="line">            <span class="comment">// Y是X的子节点,并且其h值不需要改变</span></span><br><span class="line">            <span class="keyword">if</span> (state[extend_Y][extend_x] == NEW ||</span><br><span class="line">                (back_flag &amp;&amp;</span><br><span class="line">                 hscore[extend_Y][extend_x] != hscore[Y][x] + cost))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 将X作为Y的父节点,修改其h值,并将Y点添加到Openlist中</span></span><br><span class="line">                nxt_x[extend_Y][extend_x] = x,</span><br><span class="line">                nxt_Y[extend_Y][extend_x] = Y;</span><br><span class="line">                <span class="built_in">insert</span>(extend_x, extend_Y, hscore[Y][x] + cost);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//Y不是X的子节点,并且其h值可以变得更小</span></span><br><span class="line">                <span class="keyword">if</span> (!back_flag &amp;&amp;</span><br><span class="line">                    hscore[extend_Y][extend_x] &gt; hscore[Y][x] + cost)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//修改X的h值,并将其点添加到Openlist中</span></span><br><span class="line">                    <span class="built_in">insert</span>(x, Y, hscore[Y][x]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//Y不是X的子节点,并且其h值可以变得更小, 并且Y不在Openlist中,且h值处于上升状态</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!back_flag &amp;&amp;</span><br><span class="line">                         hscore[Y][x] &gt;</span><br><span class="line">                         hscore[extend_Y][extend_x] + cost &amp;&amp;</span><br><span class="line">                         state[extend_Y][extend_x] == CLOSED &amp;&amp;</span><br><span class="line">                         hscore[extend_Y][extend_x] &gt; k)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//修改Y的h值,并将其点添加到Openlist中</span></span><br><span class="line">                    <span class="built_in">insert</span>(extend_x, extend_Y, hscore[extend_Y][extend_x]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回该点k值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get_mink</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他的函数详见代码注释.</p><p>经过遇到障碍时对障碍节点的 h 和 k 值的设定为无限大以及状态处理函数的处理, 小车在遇到障碍时就能够快速的重新规划出路径.</p><h3 id="六-运动控制部分"><a class="markdownIt-Anchor" href="#六-运动控制部分"></a> 六、运动控制部分</h3><h4 id="61-需求分析"><a class="markdownIt-Anchor" href="#61-需求分析"></a> 6.1 需求分析</h4><p>运动控制部分的工作目标是通过获取规划部分得到的规划后路径，设计控制算法，使小车沿着期望的规划路径行驶。那么为了达到较好的控制效果，势必要采取闭环控制系统，<code>PID</code>就是老师不断推荐的一个很好的闭环控制算法，但<code>PID</code>本身也有很多分支，单环双环等，因此我们都实现了一下择效果最好的选用。</p><h4 id="62-算法分析"><a class="markdownIt-Anchor" href="#62-算法分析"></a> 6.2 算法分析</h4><h5 id="621-pid原理分析"><a class="markdownIt-Anchor" href="#621-pid原理分析"></a> 6.2.1 PID原理分析</h5><p>PID控制器（比例-积分-微分控制器），由比例单元（Proportional）、积分单元（Integral）和微分单元（Derivative）组成。可以通过调整这三个单元的增益<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>P</mi></msub><mtext>、</mtext><msub><mi>K</mi><mi>i</mi></msub><mtext>、</mtext><msub><mi>K</mi><mi>d</mi></msub></mrow><annotation encoding="application/x-tex">K_P、K_i、K_d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>来调定其特性。PID控制器主要适用于基本上线性，且动态特性不随时间变化的系统。</p><p>PID控制器是一个在工业控制应用中常见的反馈回路部件。这个控制器把收集到的数据和一个参考值进行比较，然后把这个差别用于计算新的输入值，这个新的输入值的目的是可以让系统的数据达到或者保持在参考值。PID控制器可以根据历史数据和差别的出现率来调整输入值，使系统更加准确而稳定。 PID控制器的比例单元(P)、积分单元(I)和微分单元(D)分别对应目前误差、过去累计误差及未来误差。若是不知道受控系统的特性，一般认为PID控制器是最适用的控制器。借由调整PID控制器的三个参数，可以调整控制系统，设法满足设计需求。控制器的响应可以用控制器对误差的反应快慢、控制器过冲的程度及系统震荡的程度来表示。不过使用PID控制器不一定保证可达到系统的最佳控制，也不保证系统稳定性。 有些应用只需要PID控制器的部分单元，可以将不需要单元的参数设为零即可。因此PID控制器可以变成PI控制器、PD控制器、P控制器或I控制器。其中又以PI控制器比较常用，因为D控制器对回授噪声十分敏感，而若没有I控制器的话，系统不会回到参考值，会存在一个误差量。</p><p><img src="tu.png" alt="tu" /></p><h5 id="622-串级pid"><a class="markdownIt-Anchor" href="#622-串级pid"></a> 6.2.2 串级PID</h5><p>串级PID相比于普通PID，多了一个环的考虑，因而产生了内环外环的区分。</p><p>两个个PID控制器可以组合在一起，得到较佳的效果，这称为串级PID控制。以两个PID控制器组成的串级PID控制为例，其中一个PID控制器在外回路，控制像液面高度或是速度等主要的物理量，另一个PID控制器是内回路，以外回路PID控制器的输出做为其目标值，一般是控制较快速变化的参数，例如流量或加速度等。若利用串级PID控制，可以增加控制器的工作频率，并降低其时间常数。</p><p>例如一个温控的循环水浴设备有二个串级的PID控制器，分别有各自的热电偶温度感测器。外回路的控制器控制水温，其感测器距加热器很远，直接量测整体水温，其误差量是理想水温及整体水温的差值。外回路PID控制器的输出即为内回路控制器的目标值，内回路控制器控制加热器，其感测器是在加热器上，其误差量是加热器的理想温度及量测到温度的差值，其输出会使加热器维持在设定值附近。 内外回路控制器的参数可能会差很多，外回路的PID控制器有较长的时间常数，对应所有的水加热或是冷却需要的时间。内回路的PID控制器反应会比较快。每个控制器可以调整到符合其真正控制的系统，例如水槽中所有的水，或是加热器本身。</p><p><img src="tu2.png" alt="tu2" /></p><h4 id="63-实验思路与方案选择"><a class="markdownIt-Anchor" href="#63-实验思路与方案选择"></a> 6.3 实验思路与方案选择</h4><h5 id="631-pid分析"><a class="markdownIt-Anchor" href="#631-pid分析"></a> 6.3.1 PID分析</h5><p>实验中会从规划部分得到一系列期望路径上的点，因此每次控制的最终目标其实都是小车的位置，因此存在一个位置环。但程序对小车赋值控制其运动的又是小车四个轮子的速度，因此这里有个速度环。其实驱动小车轮子转动应该还有个电流环，但电流环的工作<code>Webots</code>已经帮我们做好了，因此无需考虑这一环，因此就存在下面三种设计方式：</p><ul><li>采用基于位置环的单环PID，控制小车到达期望位置，并以每次的当前位置进行修正</li><li>采用基于速度环的单环PID，控制小车达到期望速度，以每次当前速度进行修正</li><li>采用速度环+位置环的双环PID，速度环做外环，位置环做内环，速度的变化会导致位置的变化，形成一个串级PID</li></ul><p>分别尝试了三种实践后发现，当加入速度环的考量有个问题就是，走的过程会时而很快时而很慢。因为路径并不是连续的，二是一个一个离散的点多次追寻的结果，因此如果想使每一次到达目标位置具有目标速度(比如0)，那么在离目标位置远的时候速度会很快，到目标位置近的时候速度会降下来，但接下来又要去一个新的目标位置了，因此产生了时而很快时而很慢的效果。而采用位置环进行单环PID没有这个缺陷且能达到较好效果。因此我们最后采用基于位置环的单环PID进行实验。</p><h5 id="632-pid参数分析"><a class="markdownIt-Anchor" href="#632-pid参数分析"></a> 6.3.2 PID参数分析</h5><p>本系统采用 PID 算法来控制小车达到期望位置。小车行驶过程中，<code>gps</code>模块不断采集小车自身位置信息，并与期望位置进行比较使得小车的位置趋向目标位置，PID参数在本实验的含义大致如下：</p><ul><li>P：对小车当前的位置偏差进行调整，系数越大调节速度越快，减小误差，但是过大的比例，会造成小车速度状态的突变，从而导致小车状态不稳定，变得帕金森。</li><li>I：加入积分调节，可以消除系统的稳态误差，提高无误差度。但系统的稳定性下降，动态响应变慢。</li><li>D：微分调节反应的是小车的速度，可以预见偏差变化的趋势具有可预见性因而可以产生超前调节，加入微分调节可以改善系统的动态性能。</li></ul><h4 id="64-具体设计"><a class="markdownIt-Anchor" href="#64-具体设计"></a> 6.4 具体设计</h4><h5 id="641-pid类的封装"><a class="markdownIt-Anchor" href="#641-pid类的封装"></a> 6.4.1 PID类的封装</h5><p>根据前面的算法分析和实验思路，封装了一个<code>PID</code>控制器类，代码及注释如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PID</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Coordinates SetPoint; <span class="comment">//  设定目标 Desired Value</span></span><br><span class="line">    Coordinates SumError; <span class="comment">//误差累计</span></span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> Proportion; <span class="comment">//  比例常数 Proportional Const</span></span><br><span class="line">    <span class="type">double</span> Integral;   <span class="comment">//  积分常数 Integral Const</span></span><br><span class="line">    <span class="type">double</span> Derivative; <span class="comment">//  微分常数 Derivative Const</span></span><br><span class="line"></span><br><span class="line">    Coordinates LastError; <span class="comment">//  Error[-1]</span></span><br><span class="line">    Coordinates PrevError; <span class="comment">//  Error[-2]</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">PID</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        Proportion = Integral = Derivative = SetPoint.x = SetPoint.y =</span><br><span class="line">            SumError.x = SumError.y = LastError.x = LastError.y = PrevError.x =</span><br><span class="line">                PrevError.y = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 设置期望点</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param setpoint 期望点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PID_SetPoint</span><span class="params">(Coordinates *setpoint)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        SetPoint.x = setpoint-&gt;x;</span><br><span class="line">        SetPoint.y = setpoint-&gt;y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        SetPoint.x = SetPoint.y = SumError.x = SumError.y = LastError.x =</span><br><span class="line">            LastError.y = PrevError.x = PrevError.y = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        Proportion = <span class="number">0.97</span>;</span><br><span class="line">        Integral = <span class="number">0.05</span>;</span><br><span class="line">        Derivative = <span class="number">50</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="642-pid反馈量计算函数设计"><a class="markdownIt-Anchor" href="#642-pid反馈量计算函数设计"></a> 6.4.2 PID反馈量计算函数设计</h5><p>因为小车的位置是个二维坐标，因此x轴方向和y轴方向均可分别看作一个PID，分别进行反馈量计算，具体函数实现及注释如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief x方向PID算法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param CurPoint 当前位置</span></span><br><span class="line"><span class="comment"> * @return double PID反馈量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">PID_x_PosLocCalc</span><span class="params">(Coordinates* CurPoint)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> iError_x, dError_x;</span><br><span class="line"></span><br><span class="line">    iError_x = SetPoint.x - CurPoint-&gt;x;  <span class="comment">// 偏差</span></span><br><span class="line">    SumError.x += iError_x;               <span class="comment">// //累计偏差，用于积分</span></span><br><span class="line">    <span class="keyword">if</span> (SumError.x &gt; <span class="number">10.0</span>)                <span class="comment">//积分限幅10</span></span><br><span class="line">        SumError.x = <span class="number">10.0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (SumError.x &lt; <span class="number">-10.0</span>)</span><br><span class="line">        SumError.x = <span class="number">-10.0</span>;</span><br><span class="line">    dError_x = iError_x - LastError.x;  <span class="comment">// 当前微分</span></span><br><span class="line">    LastError.x = iError_x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">double</span>)(Proportion * iError_x    <span class="comment">// 比例项</span></span><br><span class="line">                    + Integral * SumError.x  <span class="comment">// 积分项</span></span><br><span class="line">                    + Derivative * dError_x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief y方向PID算法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param CurPoint 当前位置</span></span><br><span class="line"><span class="comment"> * @return double PID反馈量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">PID_y_PosLocCalc</span><span class="params">(Coordinates* CurPoint)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> iError_y, dError_y;</span><br><span class="line"></span><br><span class="line">    iError_y = SetPoint.y - CurPoint-&gt;y;  <span class="comment">// 偏差</span></span><br><span class="line">    SumError.y += iError_y;               <span class="comment">// //累计偏差，用于积分</span></span><br><span class="line">    <span class="keyword">if</span> (SumError.y &gt; <span class="number">10.0</span>)                <span class="comment">//积分限幅10</span></span><br><span class="line">        SumError.y = <span class="number">10.0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (SumError.y &lt; <span class="number">-10.0</span>)</span><br><span class="line">        SumError.y = <span class="number">-10.0</span>;</span><br><span class="line">    dError_y = iError_y - LastError.y;  <span class="comment">// 当前微分</span></span><br><span class="line">    LastError.y = iError_y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">double</span>)(Proportion * iError_y    <span class="comment">// 比例项</span></span><br><span class="line">                    + Integral * SumError.y  <span class="comment">// 积分项</span></span><br><span class="line">                    + Derivative * dError_y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="643-运动控制部分整体设计"><a class="markdownIt-Anchor" href="#643-运动控制部分整体设计"></a> 6.4.3 运动控制部分整体设计</h5><p>首先，对于每个时间戳，通过<code>gps</code>获取小车当前位置，再调用PID函数，根据当前位置作为反馈量，得到应该到达的位置：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置PID目标值</span></span><br><span class="line">pos_pid.<span class="built_in">PID_SetPoint</span>(path[idx]);</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> cx = pos[<span class="number">0</span>];</span><br><span class="line"><span class="type">double</span> cy = pos[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录当前位置</span></span><br><span class="line"><span class="keyword">auto</span> [curx, cury] = slam.<span class="built_in">real_to_pic</span>(pos[<span class="number">0</span>], pos[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="function">Coordinates <span class="title">cur</span><span class="params">(curx, cury)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据当前位置作为反馈量进行PID控制计算，并加到当前位置中</span></span><br><span class="line"><span class="type">double</span> pid_x = pos_pid.<span class="built_in">PID_x_PosLocCalc</span>(&amp;cur) + cur.x;</span><br><span class="line"><span class="type">double</span> pid_y = pos_pid.<span class="built_in">PID_y_PosLocCalc</span>(&amp;cur) + cur.y;</span><br></pre></td></tr></table></figure><p>计算得到PID的期望位置后，控制速度去逼近期望位置</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据PID反馈量进行决策</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;cur: &quot;</span> &lt;&lt; curx &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; cury &lt;&lt; endl;</span><br><span class="line">keyValue1 = <span class="built_in">action_x</span>(pid_x, curx);</span><br><span class="line">keyValue2 = <span class="built_in">action_y</span>(pid_y, cury);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">action_x</span><span class="params">(<span class="type">double</span> pid, <span class="type">int</span> cur)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> d = pid - cur;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(d) &lt;= <span class="number">1</span>)  <span class="keyword">return</span> <span class="string">&#x27;N&#x27;</span>;</span><br><span class="line">    <span class="type">char</span> ret;</span><br><span class="line">    ret = d &gt; <span class="number">0</span> ? <span class="string">&#x27;S&#x27;</span> : <span class="string">&#x27;W&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">action_y</span><span class="params">(<span class="type">double</span> pid, <span class="type">int</span> cur)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> d = pid - cur;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(d) &lt;= <span class="number">1</span>)  <span class="keyword">return</span> <span class="string">&#x27;N&#x27;</span>;</span><br><span class="line">    <span class="type">char</span> ret;</span><br><span class="line">    ret = d &gt; <span class="number">0</span> ? <span class="string">&#x27;A&#x27;</span> : <span class="string">&#x27;D&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于每达到一个<code>update_up</code>，要重新规划并重置PID：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 进行地图的更新和路径的重新规划</span></span><br><span class="line"><span class="keyword">if</span> (count == update_up) &#123;</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    slam.<span class="built_in">update</span>(display);                                   <span class="comment">// 更新地图</span></span><br><span class="line">    pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; tmp = slam.<span class="built_in">real_to_pic</span>(pos[<span class="number">0</span>], pos[<span class="number">1</span>]);  <span class="comment">// 当前位置</span></span><br><span class="line">    dstar.<span class="built_in">update</span>(tmp.first, tmp.second, display);  <span class="comment">// 重新规划路径</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转储Path</span></span><br><span class="line">    <span class="built_in">loadPath</span>(&amp;dstar, &amp;path);</span><br><span class="line"></span><br><span class="line">    idx = <span class="number">0</span>;         <span class="comment">// 下标重置</span></span><br><span class="line">    pos_pid.<span class="built_in">init</span>();  <span class="comment">// 初始化PID控制器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转储函数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 将目标路径存储到Path中，传给运动控制部分</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param dstar 规划控制器</span></span><br><span class="line"><span class="comment"> * @param path 路径存储结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loadPath</span><span class="params">(Dstar *dstar, vector&lt;Coordinates *&gt; *path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (*path).<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dstar-&gt;path.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        Coordinates *ls =</span><br><span class="line">            <span class="keyword">new</span> <span class="built_in">Coordinates</span>(dstar-&gt;path[i].first, dstar-&gt;path[i].second);</span><br><span class="line">        (*path).<span class="built_in">push_back</span>(ls);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="七-实验结果"><a class="markdownIt-Anchor" href="#七-实验结果"></a> 七、实验结果</h3><p>演示视频：<a href="https://www.bilibili.com/video/BV1pm4y1Z7ee/">bilibili</a></p><h3 id="八-改进空间"><a class="markdownIt-Anchor" href="#八-改进空间"></a> 八、改进空间</h3><p>限于时间，本次实验对于门的处理比较粗糙，如果检测到了关上的门，那么门重新打开不会做“障碍清除”操作，这里我们简要讲述一下我们的改进思路：</p><p>感知部分可以通过实时感知和简单记忆知道某些点是原本为障碍但后面变成非障碍了，感知部分可以记录这些变成非障碍的点，并传给路径规划模块，路径规划重新调整这些点的h和k值并做D*算法的局部调整，重新规划路径，即可解决门的动态开合。</p><h3 id="九-实验感想"><a class="markdownIt-Anchor" href="#九-实验感想"></a> 九、实验感想</h3><p>本次实验作为机器人导论的最后大作业，花的时间不少，学到的东西也挺多。之前基本没有接触过这种综合性的机器人实践项目，从无到有逐渐学习，先进行需求分析，然后进行算法基本思想设计，最后通过自己实践编程完成基本功能，再针对项目的不足不断优化补充，最终取得了比较理想的结果。过程是一个不断学习的过程，在完成实践的过程中，也理解温习了老师课上讲到的内容，作为一次终期课程设计起到了很好的效果。</p><p>总的来说收获颇丰，本学期的机器人导论课程学到了不少东西，让我们这些之前对机器人、控制系统几乎一无所知的小白对这方面有了一定的理解，激发了兴趣、开阔了视野，希望以后能再接再厉。</p>]]></content>
      
      
      <categories>
          
          <category> 机器人导论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Webots </tag>
            
            <tag> SLAM </tag>
            
            <tag> D* </tag>
            
            <tag> PID </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webots——RRT算法</title>
      <link href="/posts/e7f15f8.html"/>
      <url>/posts/e7f15f8.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>RRT路径规划的实验报告</p></blockquote><p>仓库地址：<a href="https://github.com/Lanly109/Webots-Homework/tree/master/RRT_planning">github</a></p><h2 id="实验目标"><a class="markdownIt-Anchor" href="#实验目标"></a> 实验目标</h2><ul><li>实现<code>RRT</code>路径规划算法，并让小车依照规划的路线进行行走，从起点到终点。</li></ul><h2 id="实验环境"><a class="markdownIt-Anchor" href="#实验环境"></a> 实验环境</h2><ul><li><p>开发环境：macOS Monterey 12.0.1</p></li><li><p>开发工具：Webots 2021b, OpenCV 4, clang-1300.0.29.3</p></li></ul><h2 id="实验内容"><a class="markdownIt-Anchor" href="#实验内容"></a> 实验内容</h2><p>本实验内容主要是两个：</p><ul><li><p>运用<code>RRT</code>算法规划出一条从起点到终点的最短路线</p></li><li><p>让小车依照此路线从起点走到终点</p></li></ul><p>限于系统原因，<code>OpenCV</code>安装时所编译的动态链接库为<code>Arm</code>架构，而<code>Webots</code>暂未对<code>MacOS</code>的<code>M1</code>类型适配，其动态链接库均为<code>x86_64</code>架构。这将导致<code>Webots</code>在生成项目时，在链接动态链接库阶段出现找不到<code>OpenCV</code>相关成员变量的<code>x86_64</code>的动态库，而在手动用命令行编译时，亦出现找不到<code>Webots</code>相关成员变量的<code>Arm</code>的动态库。因此这里将这两个代码分开，即路径规划和巡线代码为不同文件，其中路径规划代码引用了<code>OpenCV</code>库，在命令行编译下能够正常编译成功运行，巡线代码在<code>Webots</code>下亦能正常编译成功运行。而理论上它们在<code>Linux</code>或<code>Windows</code>应能融洽在同一个代码中。</p><p><img src="error1.png" alt="链接错误arm" /></p><p><img src="error2.png" alt="链接错误arm" /></p><p>本次实验提供了一个已经制作好的迷宫的世界。</p><h3 id="rrt路径规划"><a class="markdownIt-Anchor" href="#rrt路径规划"></a> RRT路径规划</h3><p>首先是进行<code>RRT</code>路径规划的实现。</p><p>本次实验的平面图如图下图所示。</p><p><img src="maze.png" alt="Maze" /></p><p>右上角绿色圈圈为起点，左下角红色圈圈为终点。</p><p>通过<code>OpenCV</code>的<code>cv::imread(s.c_str(), cv::IMREAD_COLOR);</code>函数，以彩色方式读取该图像，输出其长宽发现是一张<code>800\times 600</code>的图像，将其输入的三通道像素数输出到文件<code>qwq</code>进行分析，可以得到起点的绿色圈圈的色素值为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">(</mo><mn>76</mn><mo separator="true">,</mo><mn>76</mn><mo separator="true">,</mo><mn>76</mn><mo fence="true">)</mo></mrow><annotation encoding="application/x-tex">\left( 76,76,76 \right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord">7</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span><span class="mord">6</span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span>，终点的红色圈圈的色素值为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">(</mo><mn>36</mn><mo separator="true">,</mo><mn>36</mn><mo separator="true">,</mo><mn>36</mn><mo fence="true">)</mo></mrow><annotation encoding="application/x-tex">\left( 36,36,36 \right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord">3</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord">6</span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span>，对全图遍历找到可以找到起点和终点像素位置并保存。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">maze = cv::<span class="built_in">imread</span>(s.<span class="built_in">c_str</span>(), cv::IMREAD_COLOR);</span><br><span class="line">cols = maze.cols;</span><br><span class="line">rows = maze.rows;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; ++ i)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; cols; ++ j)&#123;</span><br><span class="line">        <span class="type">int</span> b = maze.<span class="built_in">at</span>&lt;cv::Vec3b&gt;(i, j)[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> g = maze.<span class="built_in">at</span>&lt;cv::Vec3b&gt;(i, j)[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> r = maze.<span class="built_in">at</span>&lt;cv::Vec3b&gt;(i, j)[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (b == ST &amp;&amp; sx == <span class="number">-1</span>)&#123;</span><br><span class="line">            sx = i;</span><br><span class="line">            sy = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (b == ED)&#123;</span><br><span class="line">            ex = i;</span><br><span class="line">            ey = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (b != ST &amp;&amp; b != ED &amp;&amp; b != <span class="number">255</span>)&#123; <span class="comment">// 障碍物</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> x = -REC; x &lt;= REC; ++ x)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> y = -REC; y &lt;= REC; ++ y)</span><br><span class="line">                    obs.<span class="built_in">insert</span>(<span class="built_in">two2one</span>(i + x, j + y));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>同时将一切像素值不是<code>255</code>的点都视为障碍物。虽然这不太精确，但是考虑到小车是有实际体积而非质点，而规划路径时力求最短路，会很大可能造成规划出来的路径贴墙，因此将非<code>255</code>的视为障碍物能够一定程度地将墙边缘的像素视为障碍物，让规划出来的路径尽可能不贴着墙。</p><p>这里相比上次实验代码加上了优化，在判障碍物时将障碍物方圆<code>REC</code>的切比雪夫距离的像素均视为障碍物，这虽然增加了些许图像处理时间，但对下面运用<code>RRT</code>算法求解路径时带来了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>E</mi><msup><mi>C</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">REC^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>倍的速度提升，意义重大。</p><p>这里将障碍物的二维坐标转换成一维坐标，并保存在<code>set</code>中。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">two2one</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * cols + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OpenCV的运行结果如下图所示。其输出了起点和终点坐标。</p><p><img src="opencv.png" alt="OpenCV" /></p><p><code>RRT</code>算法一共三个步骤：</p><ul><li><p>图上随机采样点<code>a</code></p></li><li><p>找到与该点距离最近的点<code>b</code>，让点<code>b</code>往点<code>a</code>方向步长距离<code>step</code>，得到新点<code>c</code>，建立有向边<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>→</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">b\to c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">c</span></span></span></span></p></li><li><p>重复以上操作，直到走到终点</p></li></ul><p>值得注意的是，<code>RRT</code>算法生成出来的是一棵树。众所周知，树上两点路径唯一。</p><p>由于朴素的<code>RRT</code>算法存在诸多问题，比如收敛速度慢，因此加上了概率选择目标点作为采样点的方案；但也有难以求解最优的可行路的问题，因此这里实现的是<code>RRT*</code>算法。</p><p><code>RRT*</code>算法相比朴素的<code>RRT</code>算法，多了两个步骤：重新选择父节点过程和重布线随机树过程，总的过程如下：</p><ul><li><p>图上随机采样点<code>a</code></p></li><li><p>找到与该点距离最近的点<code>b</code>，让点<code>b</code>往点<code>a</code>方向步长距离<code>step</code>，得到新点<code>c</code></p></li><li><p>在点<code>c</code>方圆<code>dis1</code>距离找到点<code>d</code>，使得从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>t</mi><mo>→</mo><mi>d</mi><mo>→</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">st\to d\to c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">c</span></span></span></span>的距离最小（重新选择父节点），建立有向边<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo>→</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">d\to c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">c</span></span></span></span>（重新选择父节点，即不一定选点<code>b</code>作为父节点），其中<code>st</code>表示起点</p></li><li><p>在点<code>c</code>方圆<code>dis2</code>距离找到符合条件的点<code>e</code>，使得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>t</mi><mo>→</mo><mi>c</mi><mo>→</mo><mi>e</mi></mrow><annotation encoding="application/x-tex">st\to c\to e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">e</span></span></span></span>距离小于原<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>t</mi><mo>→</mo><mi>e</mi></mrow><annotation encoding="application/x-tex">st\to e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">e</span></span></span></span>的距离，更改点<code>e</code>的父亲为点<br /><code>c$</code>即从点<code>c</code>走到点<code>e</code>），删去原先的有向边<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>a</mi><mo stretchy="false">[</mo><mi>e</mi><mo stretchy="false">]</mo><mo>→</mo><mi>e</mi></mrow><annotation encoding="application/x-tex">fa[e]\to e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">a</span><span class="mopen">[</span><span class="mord mathnormal">e</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">e</span></span></span></span>，新建有向边<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>→</mo><mi>e</mi></mrow><annotation encoding="application/x-tex">c\to e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">e</span></span></span></span>，同时更新点<code>e</code>的子树的所有点的距离。其中<code>fa[i]</code>表示点<code>i</code>的父亲。（重布线随机数）</p></li><li><p>重复以上操作，直到走到终点</p></li></ul><p>新增的两个步骤都是优化最短路。以下是一个简单的例子。</p><p><img src="1.png" alt="重新布线" /></p><p>在上图里，这里通过采样后从右边的点拓展了一个点，此时在方圆距离寻找一个距离起点最近的点。</p><p><img src="2.png" alt="重新布线" /></p><p>如蓝色线所示，事实上左边的点距离起点最近，因此重新选择父节点为左边的点。如上图所示。</p><p><img src="3.png" alt="重新布线" /></p><p>重新选择父节点后，进行重新布线操作。同样以采样点方圆距离寻找是否有点通过该点能以更近的距离到达起点，如上图所示。</p><p><img src="4.png" alt="重新布线" /></p><p>发现蓝色线回到起点跟红色线回到起点近，于是删除原先父边，建立新边，如上图所示。这就是重布线操作。当然如果其点还有后继点，需要沿路更新最短距离到叶子。</p><p>以下是代码讲解。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">findPath</span><span class="params">()</span></span>&#123; </span><br><span class="line">    fa.<span class="built_in">resize</span>(rows * cols);</span><br><span class="line">    <span class="built_in">fill</span>(fa.<span class="built_in">begin</span>(), fa.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 距离起点的数据</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">distance</span><span class="params">(rows * cols, <span class="number">1e9</span> + <span class="number">7</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 记录从父亲走向儿子的有向边</span></span><br><span class="line">    edge.<span class="built_in">resize</span>(rows * cols);</span><br><span class="line">    <span class="type">int</span> st = <span class="built_in">two2one</span>(sx, sy);</span><br><span class="line">    distance[st] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ed = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 已扩展点集</span></span><br><span class="line">    pointSet.<span class="built_in">insert</span>(st);</span><br></pre></td></tr></table></figure><p>核心函数<code>findPath</code>，前面均为初始化。然后开始扩展。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="comment">// 随机采样点</span></span><br><span class="line">    <span class="type">int</span> samplePoint = <span class="built_in">randPoint</span>();</span><br><span class="line">    <span class="comment">// 在点集中找到距离采样点最近的点</span></span><br><span class="line">    <span class="type">int</span> nearstPoint = <span class="built_in">getNearestPoint</span>(samplePoint, pointSet);</span><br><span class="line">    <span class="comment">// 以采样点方向以stepDistance步长得到新点，valid表示该点是否合法，即该点是否位于障碍物或超出界，或已在扩展点集里，或沿途有障碍物</span></span><br><span class="line">    <span class="keyword">auto</span> [valid, newPoint] = <span class="built_in">goStep</span>(nearstPoint, samplePoint);</span><br><span class="line">    <span class="keyword">if</span> (!valid)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">// 重新选择父亲点，选一条从st -&gt; fatherPoint -&gt; newPoint最近的fatherPoint</span></span><br><span class="line">    <span class="type">int</span> fatherPoint = <span class="built_in">getBestFatherPoint</span>(newPoint, pointSet, distance);</span><br><span class="line">    <span class="comment">// 指定父亲</span></span><br><span class="line">    fa[newPoint] = fatherPoint;</span><br><span class="line">    <span class="comment">// 更新距离</span></span><br><span class="line">    distance[newPoint] = distance[fatherPoint] + <span class="built_in">dis</span>(newPoint, fatherPoint);</span><br><span class="line">    <span class="comment">// 建立新有向边</span></span><br><span class="line">    edge[fatherPoint].<span class="built_in">insert</span>(newPoint);</span><br><span class="line">    <span class="comment">// 扩展点集合</span></span><br><span class="line">    pointSet.<span class="built_in">insert</span>(newPoint);</span><br><span class="line">    <span class="comment">// 重布线操作</span></span><br><span class="line">    <span class="built_in">rewrite</span>(newPoint, pointSet, distance);</span><br><span class="line">    <span class="comment">// 判断是否在终点附近</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">nearTargetPoint</span>(newPoint))&#123;</span><br><span class="line">        ed = newPoint;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤也如上述所说的，先采样点，然后从点集中找到距离最近的点，往采样点方向进行扩展，然后重新选择父节点和进行重布线操作。</p><p>随机采样点函数很简单。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 随机生成点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">randPoint</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="built_in">rand</span>() % rows;</span><br><span class="line">    <span class="type">int</span> y = <span class="built_in">rand</span>() % cols;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">two2one</span>(x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>two2one</code>函数是将点二维坐标转换成一维。</p><p>寻找距离最近的点的函数也很简单。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 寻找pointSet中距离point最近的点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getNearestPoint</span><span class="params">(<span class="type">int</span> point, set&lt;<span class="type">int</span>&gt; &amp;pointSet)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> target = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">double</span> targetDis = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> p : pointSet)&#123;</span><br><span class="line">        <span class="type">double</span> distance = <span class="built_in">dis</span>(point, p);</span><br><span class="line">        <span class="keyword">if</span> (distance &lt; targetDis)&#123;</span><br><span class="line">            targetDis = distance;</span><br><span class="line">            target = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步长扩展点函数稍有点复杂。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">pair&lt;<span class="type">bool</span>, <span class="type">int</span>&gt; <span class="title">goStep</span><span class="params">(<span class="type">int</span> curPoint, <span class="type">int</span> dirPoint)</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> distance = <span class="built_in">dis</span>(curPoint, dirPoint);</span><br><span class="line">    <span class="keyword">auto</span> [curX, curY] = <span class="built_in">one2two</span>(curPoint);</span><br><span class="line">    <span class="keyword">auto</span> [dirX, dirY] = <span class="built_in">one2two</span>(dirPoint);</span><br><span class="line">    <span class="comment">// 比例关系</span></span><br><span class="line">    <span class="type">int</span> nxtX = curX + <span class="number">1.0</span> * (dirX - curX) * stepDistance / distance;</span><br><span class="line">    <span class="type">int</span> nxtY = curY + <span class="number">1.0</span> * (dirY - curY) * stepDistance / distance;</span><br><span class="line">    <span class="type">int</span> nxtPoint = <span class="built_in">two2one</span>(nxtX, nxtY);</span><br><span class="line">    <span class="comment">// 扩展点不在障碍物，未出界，连线无障碍，非点集点</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="built_in">valid</span>(nxtX, nxtY) &amp;&amp; <span class="built_in">checkLine</span>(nxtX, nxtY, curX, curY) &amp;&amp; pointSet.<span class="built_in">find</span>(nxtPoint) == pointSet.<span class="built_in">end</span>(), nxtPoint&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要是判断扩展的点是否合法，除了判断是否在障碍物，出界，以及连线无障碍之外，还要判断是否在点集里，在的话也视为非法，因为已经扩展的点就没必要在此扩展了，在早期版本中，<code>pointSet</code>还是<code>vector</code>类型，就发生了栈溢出的现象，主要是重复点加进来太多爆内存了。</p><p><code>valid</code>函数如下。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">valid</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123; <span class="comment">// 判断当前点是否合法，即是否越界或者是否在障碍物边缘</span></span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= rows)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (y &lt; <span class="number">0</span> || y &gt;= cols)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> obs.<span class="built_in">find</span>(<span class="built_in">two2one</span>(x, y)) == obs.<span class="built_in">end</span>();</span><br><span class="line">    <span class="comment">// 大大的优化，速度提升了REC*REC倍</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上个实验代码里对点判越界写错了，原先写的<br />是与关系，这里已修正为或关系。以及正如前文所说，原先这里需要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo fence="true">(</mo><mi>R</mi><mi>E</mi><msup><mi>C</mi><mn>2</mn></msup><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">O\left( REC^2 \right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.20001em;vertical-align:-0.35001em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span></span></span></span><br />次判断来判断是否在障碍物附近，由于在处理图像时已经进行了预处理，故此处优化成只需<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>次了。实测运行速度大幅提升。</p><p><code>checkline</code>函数如上次一致。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">checkLine</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span></span>&#123; <span class="comment">// 判断一条直线上是否有障碍物</span></span><br><span class="line">    <span class="type">double</span> k = <span class="number">0.01</span>;</span><br><span class="line">    <span class="keyword">for</span>(; k &lt;= <span class="number">1</span>; k += <span class="number">0.01</span>)</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">valid</span>(x1 + (x2 - x1) * k, y1 + (y2 - y1) * k))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新选择父亲的函数如下。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重新选择父亲</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getBestFatherPoint</span><span class="params">(<span class="type">int</span> point, set&lt;<span class="type">int</span>&gt;&amp; pointSet, vector&lt;<span class="type">double</span>&gt;&amp; pointDistance)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> target = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> targetDis = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> p : pointSet)&#123; <span class="comment">// 枚举点集的点</span></span><br><span class="line">        <span class="type">double</span> distance = <span class="built_in">dis</span>(point, p);</span><br><span class="line">        <span class="comment">// 距离在方圆内，且从该点到起点距离更小</span></span><br><span class="line">        <span class="keyword">if</span> (distance &lt; fatherDistance &amp;&amp; <span class="built_in">checkLine</span>(point, p) &amp;&amp; pointDistance[p] + distance &lt; targetDis)&#123;</span><br><span class="line">            targetDis = pointDistance[p] + distance;</span><br><span class="line">            target = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这跟寻找最近点的距离很类似，但判断的条件不同。距离最近的就单纯地看距离最近，而最好的父亲节点是到起点最近的节点。</p><p>重布线函数如下。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rewrite</span><span class="params">(<span class="type">int</span> point, set&lt;<span class="type">int</span>&gt;&amp; pointSet, vector&lt;<span class="type">double</span>&gt;&amp; pointDistance)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> p : pointSet)&#123; <span class="comment">// 枚举点集的点</span></span><br><span class="line">        <span class="type">double</span> distance = <span class="built_in">dis</span>(point, p);</span><br><span class="line">        <span class="comment">// 判断距离是否在方圆内，且之间连边无障碍物</span></span><br><span class="line">        <span class="keyword">if</span> (distance &gt; rewriteDistance || !<span class="built_in">checkLine</span>(point, p))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 如果距离更优</span></span><br><span class="line">        <span class="keyword">if</span> (pointDistance[p] &gt; pointDistance[point] + distance)&#123;</span><br><span class="line">            <span class="comment">// 更新距离</span></span><br><span class="line">            pointDistance[p] = pointDistance[point] + distance;</span><br><span class="line">            <span class="comment">// 删除原先边</span></span><br><span class="line">            edge[fa[p]].<span class="built_in">erase</span>(p);</span><br><span class="line">            fa[p] = point;</span><br><span class="line">            <span class="comment">// 建立新的边</span></span><br><span class="line">            edge[point].<span class="built_in">insert</span>(p);</span><br><span class="line">            <span class="comment">// 更新点p之后的点的最短距离</span></span><br><span class="line">            <span class="built_in">update</span>(p, pointDistance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line">从新扩展的点的方圆点中寻找可以更新距离的点，一旦可以更新就删去原有边，并新增边，且通过`update`函数更新沿途下去的所有点的最短距离。</span><br><span class="line">```cpp</span><br><span class="line"><span class="comment">// 更新距离</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> point, vector&lt;<span class="type">double</span>&gt;&amp; pointDistance)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> nxtPoint : edge[point])&#123;</span><br><span class="line">        pointDistance[nxtPoint] = <span class="built_in">dis</span>(point, nxtPoint) + pointDistance[point];</span><br><span class="line">        <span class="built_in">update</span>(nxtPoint, pointDistance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>距离更新就通过<code>edge</code>储存的父亲到儿子到有向边进行递归更新。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算到终点距离，判断是否在终点附近</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">nearTargetPoint</span><span class="params">(<span class="type">int</span> point)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dis</span>(point, <span class="built_in">two2one</span>(ex, ey)) &lt; targetDistance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断是否到达终点距离的函数就比较简单了。一旦到达终点附近，求解路径就算结束了。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> point = ed; point != st; point = fa[point])</span><br><span class="line">    path.<span class="built_in">push_back</span>(point);</span><br><span class="line">path.<span class="built_in">push_back</span>(st);</span><br><span class="line"><span class="built_in">reverse</span>(path.<span class="built_in">begin</span>(), path.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><p>最后根据<code>fa</code>数组关系记录最短路径即可。</p><p>以下是一些跑出来的效果图。</p><p><img src="example_point_far.png" alt="早期稀有路径" /></p><p><img src="example_nei_far.png" alt="早期稀有路径" /></p><p><img src="example_path_far.png" alt="早期稀有路径" /></p><p>如第一次结果所示，尽管有众多优化，<code>RRT</code>算法能有可能会找到较远路径，尽管概率很小，此为稀有路径了。</p><p><img src="example_point_norewrite.png" alt="无重布线操作路径" /></p><p><img src="example_nei_no_rewrite.png" alt="无重布线操作路径" /></p><p><img src="example_path_norewrite.png" alt="无重布线操作路径" /></p><p>这三张图是无重布线操作<code>RRT</code>。</p><p><img src="example_point.png" alt="有重布线操作路径" /></p><p><img src="example_nei.png" alt="有重布线操作路径" /></p><p><img src="example_path.png" alt="有重布线操作路径" /></p><p>这三张图是有重布线操作<code>RRT</code>。</p><p>从图中可以很好的看出，不带重布线操作的连边情况犹如一棵正常的树一样，且得到的路径稍有摆动。而带有重布线操作的连边情况像是放射性一般，且得到的路径非常平整。</p><h3 id="小车巡线"><a class="markdownIt-Anchor" href="#小车巡线"></a> 小车巡线</h3><p>此部分与上一次<code>PRM</code>实验报告相一致，本次实验未改动，直接沿用上次代码。在此就不重复赘述，具体详情参见<a href="https://blog.lanly.vip/article/8">PRM算法</a></p><h2 id="实验结果"><a class="markdownIt-Anchor" href="#实验结果"></a> 实验结果</h2><p>演示视频：<a href="https://www.bilibili.com/video/BV1uL4y1s7yv">bilibili</a></p><h2 id="实验总结"><a class="markdownIt-Anchor" href="#实验总结"></a> 实验总结</h2><p>通过本次实验，我了解到了<code>RRT</code>算法实现的具体流程，明白了<code>RRT</code>算法的重要意义：连续变离散化。由于世界是连续的，<code>RRT</code>算法通过对世界采样将其离散化，往采样点方向前进。这非常类似于人对现实环境的探索。而且通过对世界随机采样点，再以采样点的方向行走，这在一定程度上能保证探索到的地方尽可能平均尽可能多。因为比如当前位置在世界的最左边，通过采样点的方向前进，则有非常大的概率会往右边走，因为会往右边走的采样点远多于会往左边走的点，避免一头撞到墙然后不动了。但这其实也有点不太好的地方就是，如果终点在某个角落，则可能会难以走到终点，因为每次接近终点时，采样点方向远离终点的概率就很大，从而不往终点那边走。因此才有会以一定概率选择终点为采样点，加快收敛速度的方法。为了解决<code>RRT</code>探索出来的路径一般不会是最优路径以及无意义的路径摆动，又增加了重新选择父节点和重新布线的方法，而从实验结果可以看出重布线的方案能有效较少路径无意义地摆动的情况，让路径尽可能平坦。</p><p>本次实验未改动过控制器部分代码，仅仅修改路径规划的核心代码，控制器可以不加修改地直接复用，这也体现了人类抽象能力的伟大。</p>]]></content>
      
      
      <categories>
          
          <category> 机器人导论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Webots </tag>
            
            <tag> Pure Pursuit </tag>
            
            <tag> OpenCV </tag>
            
            <tag> RRT* </tag>
            
            <tag> Rapidly-exploring Random Trees </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webots——PRM算法</title>
      <link href="/posts/d2cfe463.html"/>
      <url>/posts/d2cfe463.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>PRM路径规划的实验报告</p></blockquote><p>仓库地址：<a href="https://github.com/Lanly109/Webots-Homework/tree/master/PRM_planning">github</a></p><h2 id="实验目标"><a class="markdownIt-Anchor" href="#实验目标"></a> 实验目标</h2><ul><li>实现<code>PRM</code>路径规划算法，并让小车依照规划的路线进行行走，从起点到终点。</li></ul><h2 id="实验环境"><a class="markdownIt-Anchor" href="#实验环境"></a> 实验环境</h2><ul><li><p>开发环境：macOS Monterey 12.0.1</p></li><li><p>开发工具：Webots 2021b, OpenCV 4, clang-1300.0.29.3</p></li></ul><h2 id="实验内容"><a class="markdownIt-Anchor" href="#实验内容"></a> 实验内容</h2><p>本实验内容主要是两个：</p><ul><li><p>运用<code>PRM</code>算法规划出一条从起点到终点的最短路线</p></li><li><p>让小车依照此路线从起点走到终点</p></li></ul><p>限于系统原因，<code>OpenCV</code>安装时所编译的动态链接库为<code>Arm</code>架构，而<code>Webots</code>暂未对<code>MacOS</code>的<code>M1</code>类型适配，其动态链接库均为<code>x86_64</code>架构。这将导致<code>Webots</code>在生成项目时，在链接动态链接库阶段出现找不到<code>OpenCV</code>相关成员变量的<code>x86_64</code>的动态库，而在手动用命令行编译时，亦出现找不到<code>Webots</code>相关成员变量的<code>Arm</code>的动态库。因此这里将这两个代码分开，即路径规划和巡线代码为不同文件，其中路径规划代码引用了<code>OpenCV</code>库，在命令行编译下能够正常编译成功运行，巡线代码在<code>Webots</code>下亦能正常编译成功运行。而理论上它们在<code>Linux</code>或<code>Windows</code>应能融洽在同一个代码中。</p><p><img src="error1.png" alt="链接错误arm" /></p><p><img src="error2.png" alt="链接错误arm" /></p><p>本次实验提供了一个已经制作好的迷宫的世界。</p><h3 id="prm路径规划"><a class="markdownIt-Anchor" href="#prm路径规划"></a> PRM路径规划</h3><p>首先是进行<code>PRM</code>路径规划的实现。</p><p>本次实验的平面图如下图所示</p><p><img src="maze.png" alt="Maze" /></p><p>右上角绿色圈圈为起点，左下角红色圈圈为终点。</p><p>通过<code>OpenCV</code>的<code>cv::imread(s.c_str(), cv::IMREAD_COLOR)</code>;函数，以彩色方式读取该图像，输出其长宽发现是一张<code>800\times 600</code>的图像，将其输入的三通道像素数输出到文件<code>qwq</code>进行分析，可以得到起点的绿色圈圈的色素值为<br /><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">(</mo><mn>76</mn><mo separator="true">,</mo><mn>76</mn><mo separator="true">,</mo><mn>76</mn><mo fence="true">)</mo></mrow><annotation encoding="application/x-tex">\left( 76,76,76 \right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord">7</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span><span class="mord">6</span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span>，终点的红色圈圈的色素值为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">(</mo><mn>36</mn><mo separator="true">,</mo><mn>36</mn><mo separator="true">,</mo><mn>36</mn><mo fence="true">)</mo></mrow><annotation encoding="application/x-tex">\left( 36,36,36 \right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord">3</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord">6</span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span>，对全图遍历找到可以找到起点和终点像素位置并保存。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">maze = cv::<span class="built_in">imread</span>(s.<span class="built_in">c_str</span>(), cv::IMREAD_COLOR);</span><br><span class="line">cols = maze.cols;</span><br><span class="line">rows = maze.rows;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; ++ i)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; cols; ++ j)&#123;</span><br><span class="line">        <span class="type">int</span> b = maze.<span class="built_in">at</span>&lt;cv::Vec3b&gt;(i, j)[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> g = maze.<span class="built_in">at</span>&lt;cv::Vec3b&gt;(i, j)[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> r = maze.<span class="built_in">at</span>&lt;cv::Vec3b&gt;(i, j)[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (b == ST &amp;&amp; sx == <span class="number">-1</span>)&#123;</span><br><span class="line">            sx = i;</span><br><span class="line">            sy = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (b == ED)&#123;</span><br><span class="line">            ex = i;</span><br><span class="line">            ey = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (b != ST &amp;&amp; b != ED &amp;&amp; b != <span class="number">255</span>)</span><br><span class="line">            obs.<span class="built_in">insert</span>(<span class="built_in">two2one</span>(i, j));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>同时将一切像素值不是<code>255</code>的点都视为障碍物。虽然这不太精确，但是考虑到小车是有实际体积而非质点，而规划路径时力求最短路，会很大可能造成规划出来的路径贴墙，因此将非<code>255</code>的视为障碍物能够一定程度地将墙边缘的像素视为障碍物，让规划出来的路径尽可能不贴着墙。</p><p>这里将障碍物的二维坐标转换成一维坐标，并保存在set中。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">two2one</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * cols + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>OpenCV</code>的运行结果如下图所示。其输出了起点和终点坐标。</p><p><img src="opencv.png" alt="OpenCV" /></p><p><code>PRM</code>算法一共三个步骤：</p><ul><li>随即均匀撒点</li><li>相邻无障碍物点间连边</li><li>运用最短路算法求出一条最短路</li></ul><h4 id="随机均匀撒点"><a class="markdownIt-Anchor" href="#随机均匀撒点"></a> 随机均匀撒点</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">randGenPoint</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; i += disX)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; cols; j += disY)&#123;</span><br><span class="line">            <span class="type">int</span> attempCnt = <span class="number">25</span>;</span><br><span class="line">            <span class="keyword">while</span>(attempCnt--)&#123;</span><br><span class="line">                <span class="type">int</span> x = <span class="built_in">rand</span>() % disX;</span><br><span class="line">                <span class="type">int</span> y = <span class="built_in">rand</span>() % disY;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">valid</span>(x + i, j + y))&#123;</span><br><span class="line">                    point.<span class="built_in">push_back</span>(&#123;x + i, y + j&#125;);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里将图以<code>disX,disY</code>步长切分，在每块中尝试<code>25</code>次点的生成。其中<code>valid</code>函数如下。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">valid</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> &amp;&amp; x &gt;= rows)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (y &lt; <span class="number">0</span> &amp;&amp; y &gt;= cols)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = -REC; i &lt;= REC; ++ i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = -REC; j &lt;= REC; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (obs.<span class="built_in">find</span>(<span class="built_in">two2one</span>(x + i, y + j)) != obs.<span class="built_in">end</span>())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数判断点是否合法，一是判断是否出界，而是判断以该点为中心的<code>REC</code>范围内是否有障碍物像素点存在。之所以这么处理也是因为上述提到的原因，即尽可能让规划出的路线不贴墙走，因为小车还有具体体积的缘故。</p><p>以下两张图分别展示了<code>REC</code>为<code>0</code>和<code>15</code>时随机生成点的情况。</p><p><img src="example_point.png" alt="REC=15" /></p><p><img src="example_n_point.png" alt="REC=15" /></p><h4 id="相邻无障碍物点间连边"><a class="markdownIt-Anchor" href="#相邻无障碍物点间连边"></a> 相邻无障碍物点间连边</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">connectNei</span><span class="params">()</span></span>&#123;</span><br><span class="line">    edge.<span class="built_in">resize</span>(rows * cols);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [x, y] : point)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [nx, ny] : point)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nx == x &amp;&amp; ny == y)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">dis</span>(x, y, nx, ny) &lt; neiDis &amp;&amp; <span class="built_in">checkLine</span>(x, y, nx, ny))&#123;</span><br><span class="line">                edge[<span class="built_in">two2one</span>(x, y)].<span class="built_in">push_back</span>(<span class="built_in">two2one</span>(nx, ny));</span><br><span class="line">                edge[<span class="built_in">two2one</span>(nx, ny)].<span class="built_in">push_back</span>(<span class="built_in">two2one</span>(x, y));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路比较简单，从生成出的点集里选出两个点，判断其连线是否存在障碍物像素以及距离是否小于预设值<code>neiDis</code>。并把合法连线保存到数组<code>edge</code>中。</p><p>其中判线是否有障碍物的<code>checkline</code>函数如下。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">checkLine</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> k = <span class="number">0.01</span>;</span><br><span class="line">    <span class="keyword">for</span>(; k &lt;= <span class="number">1</span>; k += <span class="number">0.01</span>)</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">valid</span>(x1 + (x2 - x1) * k, y1 + (y2 - y1) * k))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就运用直线的参数方程那样判断沿途的个个像素是否存在障碍物像素。</p><p>以下两张图分别展示了<code>REC</code>为<code>0</code>和<code>15</code>时连线的情况。</p><p><img src="example_nei.png" alt="REC=15" /></p><p><img src="example_n_nei.png" alt="REC=15" /></p><h4 id="运用最短路算法求出一条最短路"><a class="markdownIt-Anchor" href="#运用最短路算法求出一条最短路"></a> 运用最短路算法求出一条最短路</h4><p>得到了图的连边后，就是一个简单的最短路问题了。这里运用<code>dijkstra</code>算法进行求解。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pre</span><span class="params">(cols * rows)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">vis</span><span class="params">(cols * rows, <span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="type">double</span> oo = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">distance</span><span class="params">(cols * rows, oo)</span></span>;</span><br><span class="line">priority_queue&lt;pair&lt;<span class="type">double</span>, <span class="type">int</span>&gt;&gt; team;</span><br><span class="line">team.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="built_in">two2one</span>(sx, sy)&#125;);</span><br><span class="line">distance[<span class="built_in">two2one</span>(sx, sy)] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!team.<span class="built_in">empty</span>())&#123;</span><br><span class="line">    <span class="keyword">auto</span> [_, u] = team.<span class="built_in">top</span>();</span><br><span class="line">    team.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span> (vis[u])</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : edge[u])&#123;</span><br><span class="line">        <span class="type">double</span> w = <span class="built_in">dis</span>(u, v);</span><br><span class="line">        <span class="keyword">if</span> (distance[v] &gt; distance[u] + w)&#123;</span><br><span class="line">            distance[v] = distance[u] + w;</span><br><span class="line">            pre[v] = u;</span><br><span class="line">            team.<span class="built_in">push</span>(&#123;-distance[v], v&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (distance[<span class="built_in">two2one</span>(ex, ey)] == oo)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;WARNING: CANNOT Find a path from start point to target point!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> u = <span class="built_in">two2one</span>(ex, ey); u != <span class="built_in">two2one</span>(sx, sy); u = pre[u])</span><br><span class="line">    path.<span class="built_in">push_back</span>(u);</span><br><span class="line">path.<span class="built_in">push_back</span>(<span class="built_in">two2one</span>(sx, sy));</span><br><span class="line"><span class="built_in">reverse</span>(path.<span class="built_in">begin</span>(), path.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><p><code>dijkstra</code>没什么特别的细节。用<code>pre</code>数组保存最短路中一个点的前继点。最后还判断是否存在一条最短路，存在的话保存一条最短路。因为保存的前继点，压入<code>path</code>数组是从终点到起点，因此最后还需要反转，<code>reverse</code>一下。</p><p>这里 <code>auto [\_, u] = team.top()</code> 是<code>C++17</code>标准的新特性，能够对<br /><code>pair&lt;int,int&gt;</code>进行拆包。</p><p>以下两张图展示了<code>REC</code>为<code>0</code>和<code>15</code>时连线的情况。</p><p><img src="example_path.png" alt="REC=15" /></p><p><img src="example_n_path.png" alt="REC=15" /></p><p>可以看出<code>REC=0</code>时找出来的最短路有好几处是贴着墙走的，这在实际小车寻路时极易与墙发生碰撞，而<code>REC=15</code>则于道路中间。</p><p>下图为一些分割和邻居阈值数据对应的结果。</p><p><img src="maze_10_20.png" alt="分割20，邻居距离30" /></p><p><img src="maze_10_30.png" alt="分割20，邻居距离30" /></p><p><img src="maze_20_30.png" alt="分割20，邻居距离30" /></p><h3 id="小车巡线"><a class="markdownIt-Anchor" href="#小车巡线"></a> 小车巡线</h3><p>运用<code>PRM</code>算法规划出一条路径出来后，便考虑如何进行移动。</p><p>一种简单，能够复用上次代码的实现方式是将路径规划到图上，即将规划的路线画在图上，然后通过摄像头巡线的方式行走。但考虑到这样子会有诸多问题，比如行走速度慢，一旦偏离路线就无法回来等。因此这里采用另一种通过<code>GPS</code>规划小车行走的方式。因为已经事先知晓全局路线，包括直线和转弯路径，因此可以动态调整不同速度。</p><h4 id="pure-pursuit"><a class="markdownIt-Anchor" href="#pure-pursuit"></a> Pure Pursuit</h4><p>运动规划的算法很多，比较简单的是一个叫<code>Pure Pursuit</code>算法，也即纯跟踪算法。其思想比较简单，如下图所示。</p><p><img src="purepursuit.png" alt="Pure Pursuit" /></p><p>我们将所有小车的运动都视为在圆上的运动，包括直线运动其实也是在半径无穷大的圆上运动。这样给定当前位置和目标位置，通过简单的数学计算可以算出圆的半径，进而知道该如何转弯。</p><p>但是这里我们使用的是麦克纳姆轮，一种可以全向运动的轮子。虽然麦克纳姆轮可以实现原地自旋实现转弯，但是经过实验发现没有一般小车转弯那么灵活性，在边行走边转弯非常不稳定。因此这里采用一个非常朴素的做法：以上下左右四个方向为基本方向，然后根据起始点和目标点的位置方向来决定速度方向。</p><p>代码的示例如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> f = nX &lt; X ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> r = nY &gt; Y ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++ i)&#123;</span><br><span class="line">    speed1[i] = f * speed_forward[i] * <span class="built_in">fabs</span>(nX - X);</span><br><span class="line">    speed2[i] = r * speed_rightward[i] * <span class="built_in">fabs</span>(nY - Y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>X，Y</code>表示当前位置，<br /><code>nX，nY</code>表示目标点位置。这里速度还乘上了距离系数，即比如当目标点就在当前点左边，或左边稍微前方时，就只往左边走，或者放慢往前走的速度。</p><p>那么剩下的就是目标点该如何确定。事实上这里借鉴的就是<code>Pure Pursuit</code>的目标点确定的想法：<code>Lookahead distance</code>。</p><h4 id="lookahead-distance"><a class="markdownIt-Anchor" href="#lookahead-distance"></a> Lookahead distance</h4><p>就犹如人开车一样，往前开车会选择一个参考点，但这个参考点会与当前位置保持一定距离。即前方有若干个参考点，一般会选择离自己比较远的。这个距离就是<code>Lookahead distance</code>。对于当前位置方圆<code>Lookahead distance</code>的点会被忽略，而去寻找在这之外的前方最近点的距离。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; <span class="title">findLookheadPoint</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> id = <span class="built_in">findNearestPoint</span>(x, y);</span><br><span class="line">    <span class="keyword">if</span> (id &gt; curPoint)</span><br><span class="line">        curPoint = id;</span><br><span class="line">    <span class="type">int</span> cur = <span class="built_in">two2one</span>(x, y);</span><br><span class="line">    <span class="keyword">while</span>(curPoint + <span class="number">1</span> &lt; path.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">dis</span>(cur, path[curPoint]) &lt; l)&#123;</span><br><span class="line">        ++ curPoint;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">one2two</span>(path[curPoint]);</span><br></pre></td></tr></table></figure><p>首先找到距离自身最近的点，然后再往前寻找第一个距离大于<code>Lookahead distance</code>的点。其中 <code>two2one, one2two</code>函数是将坐标二维转一维或一维转二维的。</p><p>当前这里还有一点修改，正如GTA等著名游戏一样，当前速度很快的话，视线就会变得拉长，能看到的东西就很多，而速度变慢时，视线就会变窄，能看到的东西就比较少。这里参照了这个想法，动态调整<code>Lookahead distance</code>：</p><ul><li><p>当速度快时，<code>Lookahead</code>就变大，参考点就距离自己比较远，这样当遇到转弯时就能提前知道，并做相应的动作。</p></li><li><p>当速度慢时，<code>Lookahead</code>就会变小，参考点就距离自己比较近，这样能有效进行转弯。</p></li></ul><p>而前面提到，为了实现直线速度加快，弯道速度减缓，这里就需要思考如何判断当前是走直线还是走弯道。</p><p>为了实现转弯需要计算出当前圆的半径。我们就可以根据这个半径的大小来判断当前是走直线还是弯道。为方便起见，这里取了个阈值，当半径大于<code>2m</code>时我们就认为走的是直线，速度设定为原来的三倍，否则不变。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> l = maze.<span class="built_in">dis</span>(Y, X, nX, nY);</span><br><span class="line"><span class="type">double</span> R = l * l / <span class="number">2</span> / <span class="built_in">abs</span>(X - nX);</span><br><span class="line"><span class="type">double</span> vv = (R &gt; <span class="number">2</span> ? <span class="number">3</span> : <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++ i)&#123;</span><br><span class="line">    speed1[i] = f * speed_forward[i] * <span class="built_in">fabs</span>(nX - X) * vv;</span><br><span class="line">    speed2[i] = r * speed_rightward[i] * <span class="built_in">fabs</span>(nY - Y) * vv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="小车方向控制"><a class="markdownIt-Anchor" href="#小车方向控制"></a> 小车方向控制</h4><p>上面解决了如何选取目标点以及一些改进和如何向目标点前进的问题，下面是一些额外的问题。</p><p>但在具体实验时发现一个重大问题：注意我们是根据当前位置和目标距离的差值来控制小车的前后速度和左右速度：这里的速度是相对于小车，而不是这个世界的。</p><p>正常情况下，小车不会碰到障碍物，小车能完美地进行路线行走，没有任何问题。</p><p>但由于小车不是质点，有一定的体积，且带有一定的惯性，难免会一定程度偏离预定轨迹，而一旦碰到了障碍物，小车的受力情况就不再只有发动机的力，还有障碍物给予的力，这可能会导致小车的方向偏移，进而导致所谓的小车向前走和向右走的方向与世界参考方向不一致。</p><p>因此小车需要能够自动矫正当前方向的能力。</p><p>其实现起来挺简单，关键要获取小车当前的角度信息，根据小车的角度信息就能够得知是否偏离预定方向，偏离的话该以顺时针还是逆时针旋转能快速归位。</p><p>通过查阅<a href="https://cyberbotics.com/doc/reference/supervisor?tab-language=c++">官方文档</a>，得知可以通过<code>Supervisor</code>获取小车的当前方向。于是通过麦克纳姆轮的自旋就可以实现小车的自动校正方向的能力。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    <span class="type">double</span> orix = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">double</span> oriy = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> oriz = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> curx = robot-&gt;<span class="built_in">getSelf</span>()-&gt;<span class="built_in">getOrientation</span>()[<span class="number">0</span>];</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> cury = robot-&gt;<span class="built_in">getSelf</span>()-&gt;<span class="built_in">getOrientation</span>()[<span class="number">1</span>];</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> curz = robot-&gt;<span class="built_in">getSelf</span>()-&gt;<span class="built_in">getOrientation</span>()[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(curx - orix) &gt; <span class="number">0.1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (cury &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;LEFT rec\n&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++ i)&#123;</span><br><span class="line">                speed1[i] *= <span class="number">0.01</span>;</span><br><span class="line">                speed2[i] *= <span class="number">0.01</span>;</span><br><span class="line">                speed3[i] = speed_leftCircle[i] * <span class="built_in">abs</span>(curx - orix);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;RIGHT rec\n&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++ i)&#123;</span><br><span class="line">                speed1[i] *= <span class="number">0.01</span>;</span><br><span class="line">                speed2[i] *= <span class="number">0.01</span>;</span><br><span class="line">                speed3[i] = speed_rightCircle[i] * <span class="built_in">abs</span>(curx - orix);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++ i)</span><br><span class="line">            speed3[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line">当小车进行方向矫正时，会降低原来行进的速度，优先进行矫正方向行为。</span><br><span class="line"></span><br><span class="line">当然事后通过与同学交流，可以采用另一种行走的方法，即用两个`gps`，分别安置于车头和车身，通过目标点与车头和车身所形成的向量夹角（可以通过叉积求得）来判断当前是否转向且该往哪个方向转。个人觉得这样的方式非常挺好的，能够有效适应方向偏离情形。不过鉴于麦克纳姆轮为全向轮，这样实现也是可以的。</span><br><span class="line"></span><br><span class="line">#### 障碍物检测 </span><br><span class="line"></span><br><span class="line">矫正方向可以有效防止因障碍物碰撞带来的方向偏移问题，但是也存在一些情景会有小车撞在障碍物上。比如目标点在小车位置的左前方，但小车前方已经撞在障碍物上了，这导致小车虽然有前方和左方向的力，但还是会固定在墙上不动了。为了解决这样的情形我们应当减小小车前进的速度，因为前往已有障碍物，这样小车就能先往左边走，走出障碍物再往前走。</span><br><span class="line"></span><br><span class="line">参考官方文档提供的[DistanceSensor](https:<span class="comment">//cyberbotics.com/doc/reference/distancesensor?tab-language=c++)，可以对障碍物距离进行检测，里面有个`Lookup Table`相当于一个距离与值的映射，如下图所示。</span></span><br><span class="line"></span><br><span class="line">![Lookup Table](lookuptable.png)</span><br><span class="line"></span><br><span class="line">这里设置当距离小于`<span class="number">0.1</span>m`时值为`<span class="number">0</span>`，大于`<span class="number">0.2</span>m`时值为`<span class="number">1</span>`，中间值用线性函数表示。给小车分别安置前后左右四个方向的传感器，这样在代码中用`getValue`函数就能获取当前距离对应的值的结果。</span><br><span class="line">```cpp</span><br><span class="line"><span class="type">char</span> distanceNames[<span class="number">4</span>][<span class="number">8</span>] = &#123;<span class="string">&quot;front&quot;</span>, <span class="string">&quot;back&quot;</span>, <span class="string">&quot;left&quot;</span>, <span class="string">&quot;right&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    dismotors[i] = robot-&gt;<span class="built_in">getDistanceSensor</span>(distanceNames[i]);</span><br><span class="line">    dismotors[i]-&gt;<span class="built_in">enable</span>(<span class="number">1</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++ i)&#123;</span><br><span class="line">    dismo[i] = dismotors[i]-&gt;<span class="built_in">getValue</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++ i)&#123;</span><br><span class="line">    speed1[i] = f * speed_forward[i] * <span class="built_in">fabs</span>(nX - X) * vv * <span class="built_in">min</span>(<span class="number">1.0</span>, (f == <span class="number">1</span> ? dismo[<span class="number">0</span>] : dismo[<span class="number">1</span>]));</span><br><span class="line">    speed2[i] = r * speed_rightward[i] * <span class="built_in">fabs</span>(nY - Y) * vv * <span class="built_in">min</span>(<span class="number">1.0</span>, (r == <span class="number">1</span> ? dismo[<span class="number">3</span>] : dismo[<span class="number">2</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样当前小车的速度值就由四个参数决定：前后还是左右，距离目标点距离，当前行进的半径，与障碍物的距离。</p><h4 id="坐标转换"><a class="markdownIt-Anchor" href="#坐标转换"></a> 坐标转换</h4><p>上述解决了大部分运动规划的问题，还剩下一些小细节问题，其中一个是坐标转换。</p><p>先前我们通过<code>OpenCV</code>读取迷宫图像并规划出路线，其坐标是像素坐标：<code>800x600</code>的一个坐标系。而在模拟世界是以<code>m</code>为单位计算的。我们需要将像素位置转换成模拟世界的位置。</p><p>通过研究模拟世界的坐标，其原点在正中间，不同于图片的左上角。量取真实世界的长宽为<code>6</code>米和<code>4.5</code>米，通过简单的数学换算就可以进行转换了。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; <span class="title">real2pic</span><span class="params">(<span class="type">double</span> X, <span class="type">double</span> Y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="built_in">int</span>((<span class="number">3</span> - X) / <span class="number">6</span> * <span class="number">800</span>), <span class="built_in">int</span>((Y + <span class="number">2.25</span>) / <span class="number">4.5</span> * <span class="number">600</span>)&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt; <span class="title">pic2real</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="number">3</span> - <span class="number">6</span> * x * <span class="number">1.0</span> / <span class="number">800</span>, <span class="number">-2.25</span> + <span class="number">4.5</span> * y * <span class="number">1.0</span> / <span class="number">600</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="可视化路线"><a class="markdownIt-Anchor" href="#可视化路线"></a> 可视化路线</h4><p>为了能够更好地看到小车正在追踪的点的位置，我们可以将其标记出来。</p><p>参考官网文档提供的<a href="https://cyberbotics.com/doc/reference/display?tab-language=c++">display</a>元件，按照文档的说明通过对其设置一个<code>shape</code>，就可以让原本显示在一个小窗口的图像显示在<code>shape</code>上，实现标记点的效果。</p><p>参考官方给出的<a href="https://github.com/cyberbotics/webots/blob/released/projects/samples/devices/controllers/display_supervisor/display_supervisor.c">控制器示例</a>和<a href="https://github.com/cyberbotics/webots/blob/released/projects/samples/devices/worlds/display.wbt">世界文件示例</a>。这里需要另一个<code>robot</code>充当<code>display</code>的载体，里面的一个<code>children</code>为<code>display</code>充当图像的绘制，再给<code>display</code>的<code>children</code>来一个<code>shape</code>来显示绘制的图像。</p><p>具体实现这个效果遇到的最大的问题就是坐标的定位。注意到<code>display</code>也有<code>width</code>和<code>height</code>属性，因此要绘制的坐标要依靠这个属性来确定，原点同样在左上角，这里就需要一个坐标转换公式。之前一直以为是模拟世界的坐标就一直弄不出效果。</p><p>还有一个小车圈圈的动态移动的实现，这里运用的是图像的保存和重绘制。即在绘制小车圈圈前保存当前图像，然后再绘制下一次小车圈圈时先还原图像，再绘制下一个圈圈，否则前后圈圈会相互重叠。</p><p>还有一个大问题就是通信。由于<code>display</code>在另一个<code>robot</code>上，这个<code>robot</code>与前面实现的<code>robot</code>不是同一个<code>robot</code>，需要用不同的<code>controller</code>程序。那么寻路小车当前追随的目标点信息只保存在那个程序里，在<code>display</code>的<code>robot</code>程序不得而知。由于网上关于<code>webots</code>的<code>display</code>教程几乎没有，官方提供的示例仅仅是小车的位置，而这个可以通过先前提到的<code>supervisor</code>获得。因此，由于不太会进程间的通信，这里实现的方式是在<code>display</code>的<code>robot</code>也模拟同样的行为：根据小车的位置获取最近的目标点。虽然会消耗一定的不必要计算资源但也是个可行的解决方案。</p><h2 id="实验结果"><a class="markdownIt-Anchor" href="#实验结果"></a> 实验结果</h2><p>演示视频：<a href="https://www.bilibili.com/video/BV1pL4y1s7MV">bilibili</a></p><h2 id="实验总结"><a class="markdownIt-Anchor" href="#实验总结"></a> 实验总结</h2><p>通过本次实验，我了解到了<code>PRM</code>算法实现的具体流程，明白了<code>PRM</code>算法的重要意义：连续变离散化。由于世界是连续的，<code>PRM</code>算法通过对世界采样将其离散化，然后在离散化的点之间建立连边，就变成了算法课上学到的图论中的图，然后应用最短路算法就可以解决了。除此之外还了解到了如何对规划的路径进行行走，在网上搜索资料的时候，除了<code>Pure Pursuit</code>算法之外，貌似还有另一种叫<code>MPC</code>算法，一种精度更高但需要更大计算量的算法。除此之外还有对环境实时感知，就犹如老师上课演示的一个视频，未知区域默认无障碍物下的路径规划行走情景，但探查到有障碍物后再进一步修正路线，所采取的<code>SLAM</code>算法，起初在思考这类情形的时候，觉得最棘手的就是如何通过小车的视觉传感器（？或者可能用其他的）去构建平面图，这里精度误差是关键，但未能想到好的方案，即如何从画面中的障碍物转换到平面地图，包括位置和障碍物的长度。虽然感觉用相关的视觉数学知识可以转换但稍感到复杂。</p><p>尽管如此，结合麦克纳姆轮的特性，这里就只借鉴了<code>Pure Pursuit</code>的<code>Lookahead distance</code>的思想，以及结合自己曾经玩过的游戏的一些视觉感受，增加了动态调整<code>Lookahead distance</code>以及可视化路径跟踪过程。期间遇到的最大的问题就是进程间的通信，限于<code>Webots</code>的实现，暂时没能想到好的向<code>display</code>的<code>robot</code>传输行走的<code>robot</code>的相关信息，只能让<code>display</code>也模拟其行为。为了实现相关功能，参考最多的就是<code>Webots</code>官方文档，尤其是<code>display</code>相关的知识，只有官方文档的英文说明，其余的资料几乎没有。但最后还是根据说明和官方给出的C语言的示例代码，编写出了相应的<code>C++</code>的控制器，还是颇有成就感的。只是期间些许问题，尤其是坐标定位，只能琢磨官方给的文档和代码，网上也没其他资料了。</p><p>总之，本次实验收获颇丰，进一步熟悉了<code>Webots</code>的软件，以及知晓了机器人的路径规划和行路的流程。</p>]]></content>
      
      
      <categories>
          
          <category> 机器人导论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Webots </tag>
            
            <tag> PRM </tag>
            
            <tag> Probabilistic Roadmaps </tag>
            
            <tag> Pure Pursuit </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滚榜程序Resolver源码阅读</title>
      <link href="/posts/7b2538bb.html"/>
      <url>/posts/7b2538bb.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文简单记录下阅读icpc resolver源码的经历<br />因为在resolver的说明文档里所说的支持CDP的格式，其链接已经404了，在2.1版本试出来的格式又不支持，在网上搜寻他人使用Resolver的经验无果后迫不得已尝试阅读resolver的源码，以期待找出其支持的CDP格式。</p></blockquote><p>从<a href="https://tools.icpc.global/docs/Resolver.pdf">Resolver的文档</a>可以得知，Resolver支持两种形式的滚榜数据：以CDS为数据源的通过网络方式获取的，和以CDP为数据源的通过本地方式获取的。由于颁奖典礼的地方经常没有网络，而滚榜时也想加入队伍照片的展示，因此采用CDP格式是比较好的。</p><h2 id="cdp格式"><a class="markdownIt-Anchor" href="#cdp格式"></a> CDP格式</h2><p>先说结果吧，Resolver2.4版本支持的CDP格式如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── config              // 非必需</span><br><span class="line">│   ├── contest.yaml    // 从domjudge Import/export页面导出即可</span><br><span class="line">│   ├── groups.tsv      // 从domjudge Import/export页面导出即可</span><br><span class="line">│   ├── problemset.yaml</span><br><span class="line">│   └── teams.tsv       // 从domjudge Import/export页面导出即可</span><br><span class="line">├── contest</span><br><span class="line">│   ├── banner.png      // resolver无用，但在cds放置于此就可显示banner</span><br><span class="line">│   └── logo.png        // resolver主页面的图片&amp;无照片队伍的默认照片</span><br><span class="line">├── events.xml          // 滚榜数据</span><br><span class="line">├── <span class="built_in">groups</span>              // Categories照片，但在resolver似乎没起到作用</span><br><span class="line">│   └── 3               // Categories的<span class="built_in">id</span></span><br><span class="line">│       └── logo.png</span><br><span class="line">├── organizations       // Affiliations照片，只要某Affiliations的队伍有logo，其他同Affiliations的队伍就都是该logo</span><br><span class="line">│   ├── 3000            // 该Affiliations所对应的任一队伍的<span class="built_in">id</span></span><br><span class="line">│   │   └── logo.png</span><br><span class="line">│   ├── 3001</span><br><span class="line">│   │   └── logo.png</span><br><span class="line">│   ├── 3012</span><br><span class="line">│   │   └── logo.png</span><br><span class="line">│   ├── 3017</span><br><span class="line">│   │   ├── country_flag.png    // 照源码里是这样放置的，但在resolver似乎没起到作用</span><br><span class="line">│   │   └── logo.png</span><br><span class="line">│   └── 3187</span><br><span class="line">│       └── logo.png</span><br><span class="line">└── teams               // 队伍照片</span><br><span class="line">    ├── 3000            // 队伍的<span class="built_in">id</span></span><br><span class="line">    │   └── photo.png   // 照片名字固定是photo</span><br><span class="line">    ├── 3001</span><br><span class="line">    │   └── photo.png</span><br><span class="line">    ├── 3009</span><br><span class="line">    │   └── photo.png</span><br><span class="line">    └── 3010</span><br><span class="line">        └── photo.png</span><br></pre></td></tr></table></figure><p>其中<code>problemset.yaml</code>格式如下：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">problems:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">letter:</span>     <span class="string">A</span></span><br><span class="line">    <span class="attr">short-name:</span> <span class="string">A</span></span><br><span class="line">    <span class="attr">color:</span>      <span class="string">yellow</span></span><br><span class="line">    <span class="attr">rgb:</span>        <span class="string">&#x27;#ffff00&#x27;</span></span><br><span class="line">  </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">letter:</span>     <span class="string">B</span></span><br><span class="line">    <span class="attr">short-name:</span> <span class="string">B</span></span><br><span class="line">    <span class="attr">color:</span>      <span class="string">red</span></span><br><span class="line">    <span class="attr">rgb:</span>        <span class="string">&#x27;#ff0000&#x27;</span></span><br><span class="line">  </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">letter:</span>     <span class="string">C</span></span><br><span class="line">    <span class="attr">short-name:</span> <span class="string">C</span></span><br><span class="line">    <span class="attr">color:</span>      <span class="string">green</span></span><br><span class="line">    <span class="attr">rgb:</span>        <span class="string">&#x27;#00ff00&#x27;</span></span><br></pre></td></tr></table></figure><p>该文件非必需。需有该文件，请务必确保其<code>short-name</code>为题号，因为<code>resolver</code>的一血奖’first-to-solve-A’中的<code>A</code>与该<code>short-name</code>对应，而不是与<code>letter</code>对应。</p><hr /><p>Resolver 2.1版本的CDP格式如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── config          // 非必需</span><br><span class="line">│   ├── contest.yaml</span><br><span class="line">│   ├── groups.tsv</span><br><span class="line">│   ├── problemset.yaml</span><br><span class="line">│   └── teams.tsv</span><br><span class="line">├── events.xml      // 滚榜数据，其与2.4版少了个&lt;penalty&gt;属性，2.4无此属性直接报ERROR（而2.1没事</span><br><span class="line">└── images</span><br><span class="line">    ├── logo        // Affiliations的logo，数字为属于该Affiliations的任意队伍的<span class="built_in">id</span></span><br><span class="line">    │   └── 3001.png</span><br><span class="line">    └── team        // 队伍照片</span><br><span class="line">        ├── 3001.jpg    // 数字为队伍的<span class="built_in">id</span></span><br><span class="line">        ├── 3002.jpg</span><br><span class="line">        ├── 3003.jpg</span><br><span class="line">        ├── 3004.jpg</span><br><span class="line">        └── 3005.jpg</span><br></pre></td></tr></table></figure><p>其中滚榜数据<code>events.xml</code>的生成脚本可以用这个：<a href="https://github.com/Lanly109/icpc-resolver-from-domjudge">https://github.com/Lanly109/icpc-resolver-from-domjudge</a>。</p><h2 id="源码阅读"><a class="markdownIt-Anchor" href="#源码阅读"></a> 源码阅读</h2><h3 id="帮助"><a class="markdownIt-Anchor" href="#帮助"></a> 帮助</h3><p>帮助文案就在比较显而易见的地方：<code>Resolver/src/org/icpc/tools/resolver/Resolver.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showHelp</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Usage: resolver.bat/sh contestURL user password [options]&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;   or: resolver.bat/sh contestPath [options]&quot;</span>);</span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(<span class="string">&quot;  General options:&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;     --info&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;         Show additional info to presenter client&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;     --speed speedFactor&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;         Resolution delay multiplier. e.g. 0.5 will be twice&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;         as fast, 2 will be twice as slow&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;     --singleStep startRow&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;         Require a click for each step starting at a specific&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;         row, or for entire contest if no row specified&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;     --rowDisplayOffset numRows&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;         Move the display up the screen by some number of&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;         rows (default 4)&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;     --display #&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;         Use the specified display&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;         1 = primary display, 2 = secondary display, etc.&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;     --multi-display p@wxh&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;         Stretch the presentation across multiple clients. Use \&quot;2@3x2\&quot;&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;         to indicate this client is position 2 (top middle) in a 3x2 grid&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;     --display_name template&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;         Change the way teams are displayed using a template. Parameters:&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;         &#123;team.display_name), &#123;team.name), &#123;org.formal_name&#125;, and &#123;org.name&#125;&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;     --groups&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;         Resolve only the groups in the given regex pattern for ids&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;         If multiple groups are given, each is resolved separately&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;     --pause #&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;         Start at the given pause #. Useful for testing/preview&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;     --judgeQueue&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;         Start the resolution using a judge queue. Must have at least one list award&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;     --test&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;         Test on an unfinished contest. Ignores (removes) all unjudged runs&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;     --light&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;         Use light mode&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;     --help&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;         Shows this message&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;     --version&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;         Displays version information&quot;</span>);</span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(<span class="string">&quot;  Client options:&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;     --presenter&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;         connect to a CDS and control it&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;     --client&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;         connect to a CDS in slave (view-only) mode&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;     --side&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;         same as --client, but displays logos suitable for&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;         a lower resolution/side display&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;     --team&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;         same as --client, but displays minimal content, e.g.&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;         to display on all team machines&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(<span class="string">&quot;  Keyboard shortcuts:&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;     Ctrl-Q - Quit&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;     r      - Rewind&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;     0      - Restart (jump to beginning)&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;     2      - Fast forward (jump one step without delays)&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;     1      - Fast rewind (jump one step back without delays)&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;     +/up   - Speed up (reduce resolution delay)&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;     -/down - Slow down (increase resolution delay)&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;     j      - Reset resolution speed&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;     p      - Pause/unpause scrolling&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;     i      - Toggle additional info&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面提到了个选项judgeQueue，但我运行时加上这个参数似乎没什么效果，我以为是像在<a href="https://www.bilibili.com/video/BV15b411u7z6?p=2&amp;t=7702">2018 ICPC World Final</a>滚榜前展示的那个各队提交的通过情况judge queue一览。可能是我姿势不对。</p><h3 id="xml文件读取"><a class="markdownIt-Anchor" href="#xml文件读取"></a> xml文件读取</h3><p>其代码位于<code>ContestModel/src/org/icpc/tools/contest/model/feed/XMLFeedParser.java</code></p><p>上述<code>events.xml</code>可以参照该源码所给定的格式编写。</p><p>从第179行<code>protected void createContestObject(Contest contest, String name, List&lt;Property&gt; list) </code>处可以看到它对各属性进行解析。</p><p><code>xml</code>整体结构如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">contest</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">info</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">info</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">problem</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">problem</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">region</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">region</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">team</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">team</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">judgement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">judgement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">run</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">run</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">award</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">award</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalized</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">finalized</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">contest</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="contest-info"><a class="markdownIt-Anchor" href="#contest-info"></a> contest INFO</h4><p><code>info</code>的结构如下</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">info</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contest-id</span>&gt;</span>4<span class="tag">&lt;/<span class="name">contest-id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Contest Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">short-title</span>&gt;</span>Contest Short Name<span class="tag">&lt;/<span class="name">short-title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">length</span>&gt;</span>4:00:00.000<span class="tag">&lt;/<span class="name">length</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scoreboard-freeze-length</span>&gt;</span>1:00:00.000<span class="tag">&lt;/<span class="name">scoreboard-freeze-length</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">starttime</span>&gt;</span>1650686700.0<span class="tag">&lt;/<span class="name">starttime</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">penalty</span>&gt;</span>20<span class="tag">&lt;/<span class="name">penalty</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">info</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对应源码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (INFO.equals(name)) &#123;</span><br><span class="line">    <span class="type">Info</span> <span class="variable">info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Info</span>();</span><br><span class="line">    <span class="keyword">for</span> (Property p : list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;contest-id&quot;</span>.equals(p.name))</span><br><span class="line">            add(info, ID, p.value);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;title&quot;</span>.equals(p.name))</span><br><span class="line">            add(info, <span class="string">&quot;formal_name&quot;</span>, p.value);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;short-title&quot;</span>.equals(p.name))</span><br><span class="line">            add(info, <span class="string">&quot;name&quot;</span>, p.value);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;starttime&quot;</span>.equals(p.name)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> Double.parseDouble(p.value);</span><br><span class="line">                add(info, <span class="string">&quot;start_time&quot;</span>, Timestamp.format((<span class="type">long</span>) (d * <span class="number">1000.0</span>)));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// ignore</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;length&quot;</span>.equals(p.name))</span><br><span class="line">            add(info, <span class="string">&quot;duration&quot;</span>, p.value);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;scoreboard-freeze-length&quot;</span>.equals(p.name))</span><br><span class="line">            add(info, <span class="string">&quot;scoreboard_freeze_duration&quot;</span>, p.value);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;penalty&quot;</span>.equals(p.name))</span><br><span class="line">            add(info, <span class="string">&quot;penalty_time&quot;</span>, p.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (info.getId() == <span class="literal">null</span>)</span><br><span class="line">        add(info, ID, <span class="string">&quot;id-&quot;</span> + Math.random());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (info.getName() == <span class="literal">null</span>)</span><br><span class="line">        add(info, <span class="string">&quot;name&quot;</span>, info.getActualFormalName());</span><br><span class="line"></span><br><span class="line">    contest.add(info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="problem"><a class="markdownIt-Anchor" href="#problem"></a> Problem</h4><p><code>problem</code>结构如下</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">problem</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>1<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span>A<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Problem_Name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">problem</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对应源码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (PROBLEM.equals(name)) &#123;</span><br><span class="line">    <span class="type">Problem</span> <span class="variable">problem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Problem</span>();</span><br><span class="line">    <span class="keyword">for</span> (Property p : list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ID.equals(p.name)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                add(problem, <span class="string">&quot;ordinal&quot;</span>, (Integer.parseInt(p.value) - <span class="number">1</span>) + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                add(problem, <span class="string">&quot;ordinal&quot;</span>, p.value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (LABEL.equals(p.name))</span><br><span class="line">            add(problem, LABEL, p.value);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (LETTER.equals(p.name))</span><br><span class="line">            add(problem, LABEL, p.value);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (NAME.equals(p.name))</span><br><span class="line">            add(problem, NAME, p.value);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;color&quot;</span>.equals(p.name))</span><br><span class="line">            add(problem, <span class="string">&quot;color&quot;</span>, p.value);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;rgb&quot;</span>.equals(p.name))</span><br><span class="line">            add(problem, <span class="string">&quot;rgb&quot;</span>, p.value);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;test_data_count&quot;</span>.equals(p.name))</span><br><span class="line">            add(problem, <span class="string">&quot;test_data_count&quot;</span>, p.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find a problem with matching ordinal</span></span><br><span class="line">    IProblem[] probs = contest.getProblems();</span><br><span class="line">    <span class="keyword">for</span> (IProblem p : probs) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p.getOrdinal() == problem.getOrdinal()) &#123;</span><br><span class="line">            add(problem, ID, p.getId());</span><br><span class="line">            <span class="keyword">if</span> (problem.getLabel() == <span class="literal">null</span>)</span><br><span class="line">                add(problem, LABEL, p.getLabel());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (problem.getId() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// assume ordinal is an index</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// if no id, assume ordinal A = 0, B = 1, etc.</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> problem.getOrdinal();</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; i &lt; LETTERS.length()) &#123;</span><br><span class="line">                add(problem, ID, LETTERS.charAt(i) + <span class="string">&quot;&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (problem.getLabel() == <span class="literal">null</span>)</span><br><span class="line">                    add(problem, LABEL, LETTERS.charAt(i) + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// ignore</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// last attempt: if no label, use the id</span></span><br><span class="line">    <span class="keyword">if</span> (problem.getLabel() == <span class="literal">null</span>)</span><br><span class="line">        add(problem, LABEL, problem.getId());</span><br><span class="line"></span><br><span class="line">    contest.add(problem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它会和<code>problemset.yaml</code>读取到的<code>problem</code>进行对应，对应方式是就是出现序号<code>id</code>。</p><h4 id="regision"><a class="markdownIt-Anchor" href="#regision"></a> regision</h4><p><code>regision</code>即<code>group</code>即<code>category</code>，其结构如下</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">region</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">external-id</span>&gt;</span>3<span class="tag">&lt;/<span class="name">external-id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Participants<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">region</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对应源码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (REGION.equals(name)) &#123;</span><br><span class="line">    <span class="type">Group</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Group</span>();</span><br><span class="line">    <span class="keyword">for</span> (Property p : list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;external-id&quot;</span>.equals(p.name)) &#123;</span><br><span class="line">            add(group, ICPC_ID, p.value);</span><br><span class="line">            add(group, ID, p.value);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (NAME.equals(p.name))</span><br><span class="line">            add(group, NAME, p.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    contest.add(group);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="team"><a class="markdownIt-Anchor" href="#team"></a> team</h4><p><code>team</code>的结构如下</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">team</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>3000<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">external-id</span>&gt;</span>3000<span class="tag">&lt;/<span class="name">external-id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>请问你今天要来点拿铁吗(Is_the_order_a_Honor)<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">university</span>&gt;</span>兔之镇大学<span class="tag">&lt;/<span class="name">university</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">university-short-name</span>&gt;</span>兔之镇大学<span class="tag">&lt;/<span class="name">university-short-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">region</span>&gt;</span>Girls<span class="tag">&lt;/<span class="name">region</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">team</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对应源码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (TEAM.equals(name)) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">instId</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Organization</span> <span class="variable">org</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Organization</span>();</span><br><span class="line">    <span class="keyword">for</span> (Property p : list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ID.equals(p.name)) &#123;</span><br><span class="line">            add(org, ID, p.value);</span><br><span class="line">            instId = p.value;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;university&quot;</span>.equals(p.name)) &#123;</span><br><span class="line">            add(org, <span class="string">&quot;formal_name&quot;</span>, p.value);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;university-short-name&quot;</span>.equals(p.name)) &#123;</span><br><span class="line">            add(org, <span class="string">&quot;name&quot;</span>, p.value);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;nationality&quot;</span>.equals(p.name)) &#123;</span><br><span class="line">            add(org, <span class="string">&quot;country&quot;</span>, p.value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (org.getName() == <span class="literal">null</span>)</span><br><span class="line">        add(org, <span class="string">&quot;name&quot;</span>, org.getActualFormalName());</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">exists</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (IOrganization org2 : contest.getOrganizations()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (org2.getActualFormalName().equals(org.getActualFormalName())) &#123;</span><br><span class="line">            exists = <span class="literal">true</span>;</span><br><span class="line">            instId = org2.getId();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (org.getName() == <span class="literal">null</span> || org.getName().isEmpty())</span><br><span class="line">        add(org, <span class="string">&quot;name&quot;</span>, org.getActualFormalName());</span><br><span class="line">    <span class="keyword">if</span> (!exists)</span><br><span class="line">        contest.add(org);</span><br><span class="line"></span><br><span class="line">    <span class="type">Team</span> <span class="variable">team</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Team</span>();</span><br><span class="line">    <span class="keyword">for</span> (Property p : list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ID.equals(p.name)) &#123;</span><br><span class="line">            add(team, ID, p.value);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;external-id&quot;</span>.equals(p.name))</span><br><span class="line">            add(team, ICPC_ID, p.value);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (NAME.equals(p.name))</span><br><span class="line">            add(team, NAME, p.value);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;region&quot;</span>.equals(p.name)) &#123;</span><br><span class="line">            IGroup[] groups = contest.getGroups();</span><br><span class="line">            <span class="keyword">for</span> (IGroup g : groups) &#123;</span><br><span class="line">                <span class="keyword">if</span> (g.getName().equals(p.value))</span><br><span class="line">                    add(team, <span class="string">&quot;group_id&quot;</span>, g.getId());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    add(team, <span class="string">&quot;organization_id&quot;</span>, instId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we already have a team name, let it stand</span></span><br><span class="line">    <span class="type">ITeam</span> <span class="variable">existing</span> <span class="operator">=</span> contest.getTeamById(team.getId());</span><br><span class="line">    <span class="keyword">if</span> (existing != <span class="literal">null</span> &amp;&amp; existing.getName() != <span class="literal">null</span>)</span><br><span class="line">        add(team, NAME, existing.getName());</span><br><span class="line"></span><br><span class="line">    contest.add(team);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述<code>xml</code>结构里没有<code>nationality</code>字段，但源码会对该字段解析，因此<code>xml</code>也可以加上这个信息<s>只是似乎没用</s>。</p><h4 id="judgement"><a class="markdownIt-Anchor" href="#judgement"></a> judgement</h4><p><code>judgement</code>就是表示评测结果，其结构如下</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">judgement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">acronym</span>&gt;</span>CE<span class="tag">&lt;/<span class="name">acronym</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">judgement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对应源码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (JUDGEMENT.equals(name)) &#123;</span><br><span class="line">    <span class="type">JudgementType</span> <span class="variable">type</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JudgementType</span>();</span><br><span class="line">    <span class="keyword">for</span> (Property p : list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;acronym&quot;</span>.equals(p.name)) &#123;</span><br><span class="line">            add(type, ID, p.value);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (NAME.equals(p.name)) &#123;</span><br><span class="line">            add(type, NAME, p.value);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;penalty&quot;</span>.equals(p.name)) &#123;</span><br><span class="line">            add(type, <span class="string">&quot;penalty&quot;</span>, p.value);</span><br><span class="line">            inferJudgementTypes = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;solved&quot;</span>.equals(p.name)) &#123;</span><br><span class="line">            add(type, <span class="string">&quot;solved&quot;</span>, p.value);</span><br><span class="line">            inferJudgementTypes = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    contest.add(type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>penalty</code>一般默认都是20分钟，<code>solved</code>字段没试过用来干嘛的，可能是表示另一种同样表示过题的状态？</p><h4 id="run"><a class="markdownIt-Anchor" href="#run"></a> run</h4><p>一份<code>run</code>就是一次选手代码提交的信息，其<code>xml</code>结构如下</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">run</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>1906<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">problem</span>&gt;</span>1<span class="tag">&lt;/<span class="name">problem</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">team</span>&gt;</span>3021<span class="tag">&lt;/<span class="name">team</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">judged</span>&gt;</span>true<span class="tag">&lt;/<span class="name">judged</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span>&gt;</span>WA<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">solved</span>&gt;</span>false<span class="tag">&lt;/<span class="name">solved</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">penalty</span>&gt;</span>true<span class="tag">&lt;/<span class="name">penalty</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">time</span>&gt;</span>286.296<span class="tag">&lt;/<span class="name">time</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">run</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对应源码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (RUN.equals(name)) &#123;</span><br><span class="line">    <span class="type">Submission</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Submission</span>();</span><br><span class="line">    <span class="keyword">for</span> (Property p : list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ID.equals(p.name)) &#123;</span><br><span class="line">            add(s, ID, p.value);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;language&quot;</span>.equals(p.name)) &#123;</span><br><span class="line">            ILanguage[] langs = contest.getLanguages();</span><br><span class="line">            <span class="keyword">for</span> (ILanguage l : langs) &#123;</span><br><span class="line">                <span class="keyword">if</span> (l.getName().equals(p.value))</span><br><span class="line">                    add(s, <span class="string">&quot;language_id&quot;</span>, l.getId());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;problem&quot;</span>.equals(p.name)) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">pId</span> <span class="operator">=</span> p.value;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                pId = (Integer.parseInt(pId) - <span class="number">1</span>) + <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">            &#125;</span><br><span class="line">            IProblem[] probs = contest.getProblems();</span><br><span class="line">            <span class="keyword">for</span> (IProblem pp : probs) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pId.equals(pp.getOrdinal() + <span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">                    pId = pp.getId();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            add(s, <span class="string">&quot;problem_id&quot;</span>, pId);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;team&quot;</span>.equals(p.name)) &#123;</span><br><span class="line">            add(s, <span class="string">&quot;team_id&quot;</span>, p.value);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (TIME.equals(p.name)) &#123;</span><br><span class="line">            add(s, CONTEST_TIME, RelativeTime.format(RelativeTime.parseOld(p.value)));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (TIMESTAMP.equals(p.name)) &#123;</span><br><span class="line">            add(s, TIME, Timestamp.format(Timestamp.parseOld(p.value)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// don&#x27;t change submission time</span></span><br><span class="line">    <span class="type">ISubmission</span> <span class="variable">oldS</span> <span class="operator">=</span> contest.getSubmissionById(s.getId());</span><br><span class="line">    <span class="keyword">if</span> (oldS != <span class="literal">null</span>)</span><br><span class="line">        add(s, TIME, Timestamp.format(oldS.getTime()));</span><br><span class="line"></span><br><span class="line">    checkContestState(contest, s.getContestTime());</span><br><span class="line">    contest.add(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Property pp : list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;judged&quot;</span>.equals(pp.name) &amp;&amp; <span class="string">&quot;true&quot;</span>.equalsIgnoreCase(pp.value)) &#123;</span><br><span class="line">            <span class="type">Judgement</span> <span class="variable">sj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Judgement</span>();</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">solved</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">penalty</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">IJudgementType</span> <span class="variable">type</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (Property p : list) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ID.equals(p.name)) &#123;</span><br><span class="line">                    add(sj, ID, p.value);</span><br><span class="line">                    add(sj, <span class="string">&quot;submission_id&quot;</span>, p.value);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (TIME.equals(p.name)) &#123;</span><br><span class="line">                    add(sj, START_CONTEST_TIME, RelativeTime.format(RelativeTime.parseOld(p.value)));</span><br><span class="line">                    add(sj, END_CONTEST_TIME, RelativeTime.format(RelativeTime.parseOld(p.value)));</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (TIMESTAMP.equals(p.name)) &#123;</span><br><span class="line">                    add(sj, START_TIME, Timestamp.format(Timestamp.parseOld(p.value)));</span><br><span class="line">                    add(sj, END_TIME, Timestamp.format(Timestamp.parseOld(p.value)));</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;result&quot;</span>.equals(p.name)) &#123;</span><br><span class="line">                    add(sj, <span class="string">&quot;judgement_type_id&quot;</span>, p.value);</span><br><span class="line">                    type = contest.getJudgementTypeById(p.value);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;solved&quot;</span>.equals(p.name)) &#123;</span><br><span class="line">                    solved = <span class="string">&quot;true&quot;</span>.equalsIgnoreCase(p.value);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;penalty&quot;</span>.equals(p.name)) &#123;</span><br><span class="line">                    penalty = <span class="string">&quot;true&quot;</span>.equalsIgnoreCase(p.value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (inferJudgementTypes &amp;&amp; type != <span class="literal">null</span> &amp;&amp; (solved || penalty)) &#123;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">update</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="type">JudgementType</span> <span class="variable">typeMatch</span> <span class="operator">=</span> (JudgementType) ((JudgementType) type).clone();</span><br><span class="line">                <span class="keyword">if</span> (solved &amp;&amp; !typeMatch.isSolved()) &#123;</span><br><span class="line">                    add(typeMatch, <span class="string">&quot;solved&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">                    update = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (penalty &amp;&amp; !typeMatch.isPenalty()) &#123;</span><br><span class="line">                    add(typeMatch, <span class="string">&quot;penalty&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">                    update = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (update)</span><br><span class="line">                    contest.add(typeMatch);</span><br><span class="line">            &#125;</span><br><span class="line">            checkContestState(contest, sj.getStartContestTime());</span><br><span class="line">            checkContestState(contest, sj.getEndContestTime());</span><br><span class="line">            contest.add(sj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这部分没多大细看，应该逻辑也不复杂。</p><h4 id="award"><a class="markdownIt-Anchor" href="#award"></a> award</h4><p><code>award</code>表示颁发的获奖信息，其<code>xml</code>结构如下</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">award</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>gold-medal<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">citation</span>&gt;</span>Gold Medalist<span class="tag">&lt;/<span class="name">citation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">show</span>&gt;</span>true<span class="tag">&lt;/<span class="name">show</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">teamId</span>&gt;</span>3167<span class="tag">&lt;/<span class="name">teamId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">teamId</span>&gt;</span>3204<span class="tag">&lt;/<span class="name">teamId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">teamId</span>&gt;</span>3036<span class="tag">&lt;/<span class="name">teamId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">teamId</span>&gt;</span>3009<span class="tag">&lt;/<span class="name">teamId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">award</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意同类型的获奖的所有队伍都必须写在同一个<code>award</code>中，否则会覆盖。比如前一个<code>award</code>是<code>gold-medal</code>，后一个<code>award</code>也是<code>gold-medal</code>，那么最终颁给<code>gold-medal</code>的队伍是后一个<code>award</code>对应的队伍。</p><p>对应源码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (AWARD.equals(name)) &#123;</span><br><span class="line">    <span class="type">Award</span> <span class="variable">award</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Award</span>();</span><br><span class="line">    List&lt;String&gt; teamIds = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Property p : list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;teamId&quot;</span>.equals(p.name))</span><br><span class="line">            teamIds.add(p.value);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ID.equals(p.name))</span><br><span class="line">            add(award, ID, p.value);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;citation&quot;</span>.equals(p.name))</span><br><span class="line">            add(award, p.name, p.value);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;show&quot;</span>.equals(p.name))</span><br><span class="line">            add(award, <span class="string">&quot;show&quot;</span>, p.value);</span><br><span class="line">    &#125;</span><br><span class="line">    award.add(<span class="string">&quot;team_ids&quot;</span>, <span class="string">&quot;[\&quot;&quot;</span> + String.join(<span class="string">&quot;\&quot;,\&quot;&quot;</span>, teamIds) + <span class="string">&quot;\&quot;]&quot;</span>);</span><br><span class="line"></span><br><span class="line">    contest.add(award);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>id</code>是<code>resolver</code>定义好的一些获奖类型，<code>citation</code>是在滚榜程序显示的文字。</p><h4 id="finalized"><a class="markdownIt-Anchor" href="#finalized"></a> finalized</h4><p><code>finalized</code>由于国内存在打星队伍等情况，一般就没用到了，其<code>xml</code>结构如下</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">finalized</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">last-gold</span>&gt;</span>0<span class="tag">&lt;/<span class="name">last-gold</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">last-silver</span>&gt;</span>0<span class="tag">&lt;/<span class="name">last-silver</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">last-bronze</span>&gt;</span>0<span class="tag">&lt;/<span class="name">last-bronze</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">timestamp</span>&gt;</span>0<span class="tag">&lt;/<span class="name">timestamp</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">finalized</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对应源码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (FINALIZED.equals(name)) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">gold</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">silver</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">bronze</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">for</span> (Property p : list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;last-gold&quot;</span>.equals(p.name))</span><br><span class="line">            gold = Integer.parseInt(p.value);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;last-silver&quot;</span>.equals(p.name))</span><br><span class="line">            silver = Integer.parseInt(p.value);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;last-bronze&quot;</span>.equals(p.name))</span><br><span class="line">            bronze = Integer.parseInt(p.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// convert to actual numbers, not last</span></span><br><span class="line">    bronze -= silver;</span><br><span class="line">    silver -= gold;</span><br><span class="line"></span><br><span class="line">    <span class="type">State</span> <span class="variable">state</span> <span class="operator">=</span> (State) contest.getState();</span><br><span class="line">    <span class="type">Long</span> <span class="variable">startTime</span> <span class="operator">=</span> contest.getStartTime();</span><br><span class="line">    <span class="keyword">if</span> (state != <span class="literal">null</span> &amp;&amp; !state.isFinal() &amp;&amp; startTime != <span class="literal">null</span>) &#123; <span class="comment">// end the contest</span></span><br><span class="line">        state = (State) state.clone();</span><br><span class="line">        <span class="type">Long</span> <span class="variable">time</span> <span class="operator">=</span> startTime + contest.getDuration();</span><br><span class="line">        state.setEnded(time);</span><br><span class="line">        state.setThawed(time);</span><br><span class="line">        state.setFinalized(time);</span><br><span class="line">        contest.add(state);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add awards</span></span><br><span class="line">        AwardUtil.createMedalAwards(contest, gold, silver, bronze);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// end of updates</span></span><br><span class="line">        state = (State) state.clone();</span><br><span class="line">        state.setEndOfUpdates(time);</span><br><span class="line">        contest.add(state);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// contest.add(f);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="其他字段"><a class="markdownIt-Anchor" href="#其他字段"></a> 其他字段</h4><p>除了上述字段之外，从源码中可以看到其实还有其他字段</p><h4 id="testcase"><a class="markdownIt-Anchor" href="#testcase"></a> testcase</h4><p>其源码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (TESTCASE.equals(name)) &#123;</span><br><span class="line">    <span class="type">Run</span> <span class="variable">run</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Run</span>();</span><br><span class="line">    <span class="type">String</span> <span class="variable">i</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">n</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">runId</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (Property p : list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;i&quot;</span>.equals(p.name)) &#123;</span><br><span class="line">            i = p.value;</span><br><span class="line">            add(run, <span class="string">&quot;ordinal&quot;</span>, p.value);</span><br><span class="line">            <span class="comment">// add(run, &quot;i&quot;, p.value);</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;n&quot;</span>.equals(p.name)) &#123;</span><br><span class="line">            n = p.value;</span><br><span class="line">            <span class="comment">// add(run, &quot;n&quot;, p.value);</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;run-id&quot;</span>.equals(p.name)) &#123;</span><br><span class="line">            runId = p.value;</span><br><span class="line">            add(run, <span class="string">&quot;judgement_id&quot;</span>, p.value);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;judgement&quot;</span>.equals(p.name)) &#123;</span><br><span class="line">            add(run, <span class="string">&quot;judgement_type_id&quot;</span>, p.value);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (TIME.equals(p.name)) &#123;</span><br><span class="line">            add(run, CONTEST_TIME, RelativeTime.format(RelativeTime.parseOld(p.value)));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (TIMESTAMP.equals(p.name)) &#123;</span><br><span class="line">            add(run, TIME, Timestamp.format(Timestamp.parseOld(p.value)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    checkContestState(contest, run.getContestTime());</span><br><span class="line">    add(run, ID, runId + <span class="string">&quot;-&quot;</span> + i);</span><br><span class="line"></span><br><span class="line">    <span class="type">ISubmission</span> <span class="variable">s</span> <span class="operator">=</span> contest.getSubmissionById(runId);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">IProblem</span> <span class="variable">p</span> <span class="operator">=</span> contest.getProblemById(s.getProblemId());</span><br><span class="line">        <span class="type">int</span> <span class="variable">nn</span> <span class="operator">=</span> Integer.parseInt(n);</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">null</span> &amp;&amp; p.getTestDataCount() &lt; nn) &#123;</span><br><span class="line">            <span class="type">Problem</span> <span class="variable">pp</span> <span class="operator">=</span> (Problem) ((Problem) p).clone();</span><br><span class="line">            add(pp, <span class="string">&quot;test_data_count&quot;</span>, n);</span><br><span class="line">            contest.add(pp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make sure judgement exists before runs that refer to it</span></span><br><span class="line">    <span class="type">IJudgement</span> <span class="variable">j</span> <span class="operator">=</span> contest.getJudgementById(runId);</span><br><span class="line">    <span class="keyword">if</span> (j == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">Judgement</span> <span class="variable">sj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Judgement</span>();</span><br><span class="line">        add(sj, <span class="string">&quot;id&quot;</span>, runId);</span><br><span class="line">        add(sj, <span class="string">&quot;submission_id&quot;</span>, runId);</span><br><span class="line"></span><br><span class="line">        <span class="type">ISubmission</span> <span class="variable">ss</span> <span class="operator">=</span> contest.getSubmissionById(runId);</span><br><span class="line">        <span class="keyword">if</span> (ss != <span class="literal">null</span>) &#123;</span><br><span class="line">            add(sj, START_CONTEST_TIME, RelativeTime.format(ss.getContestTime()));</span><br><span class="line">            add(sj, START_TIME, Timestamp.format(ss.getTime()));</span><br><span class="line">        &#125;</span><br><span class="line">        contest.add(sj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    contest.add(run);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="clar"><a class="markdownIt-Anchor" href="#clar"></a> clar</h4><p>其源码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (CLAR.equals(name)) &#123;</span><br><span class="line">    <span class="type">Clarification</span> <span class="variable">clar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Clarification</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">question</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">answer</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">team</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">toAll</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (Property p : list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ID.equals(p.name)) &#123;</span><br><span class="line">            id = p.value;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;team&quot;</span>.equals(p.name)) &#123;</span><br><span class="line">            team = p.value;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;problem&quot;</span>.equals(p.name)) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">pId</span> <span class="operator">=</span> p.value;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                pId = (Integer.parseInt(p.value) - <span class="number">1</span>) + <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// ignore</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            IProblem[] probs = contest.getProblems();</span><br><span class="line">            <span class="keyword">for</span> (IProblem pr : probs)</span><br><span class="line">                <span class="keyword">if</span> ((pr.getOrdinal() + <span class="string">&quot;&quot;</span>).equals(pId))</span><br><span class="line">                    add(clar, <span class="string">&quot;problem_id&quot;</span>, pr.getId());</span><br><span class="line">            <span class="keyword">if</span> (clar.getProblemId() == <span class="literal">null</span>)</span><br><span class="line">                add(clar, <span class="string">&quot;problem_id&quot;</span>, pId);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;question&quot;</span>.equals(p.name)) &#123;</span><br><span class="line">            question = p.value;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;answer&quot;</span>.equals(p.name)) &#123;</span><br><span class="line">            answer = p.value;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;to-all&quot;</span>.equals(p.name)) &#123;</span><br><span class="line">            toAll = Boolean.valueOf(p.value);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (TIME.equals(p.name)) &#123;</span><br><span class="line">            add(clar, CONTEST_TIME, RelativeTime.format(RelativeTime.parseOld(p.value)));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (TIMESTAMP.equals(p.name)) &#123;</span><br><span class="line">            add(clar, TIME, Timestamp.format(Timestamp.parseOld(p.value)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (answer != <span class="literal">null</span> &amp;&amp; !answer.trim().isEmpty()) &#123;</span><br><span class="line">        add(clar, ID, id + <span class="string">&quot;-reply&quot;</span>);</span><br><span class="line">        add(clar, <span class="string">&quot;reply_to_id&quot;</span>, id);</span><br><span class="line">        add(clar, <span class="string">&quot;text&quot;</span>, answer);</span><br><span class="line">        <span class="keyword">if</span> (!toAll)</span><br><span class="line">            add(clar, <span class="string">&quot;to_team_id&quot;</span>, team);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        add(clar, ID, id);</span><br><span class="line">        add(clar, <span class="string">&quot;text&quot;</span>, question);</span><br><span class="line">        add(clar, <span class="string">&quot;from_team_id&quot;</span>, team);</span><br><span class="line">    &#125;</span><br><span class="line">    contest.add(clar);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获奖类型"><a class="markdownIt-Anchor" href="#获奖类型"></a> 获奖类型</h3><p>获奖类型的定义在<code>ContestModel/src/org/icpc/tools/contest/model/IAward.java</code></p><p>共有以下十一种获奖类型</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">AwardType</span> <span class="variable">WINNER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AwardType</span>(<span class="string">&quot;Winner&quot;</span>, <span class="string">&quot;winner&quot;</span>);</span><br><span class="line"><span class="type">AwardType</span> <span class="variable">RANK</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AwardType</span>(<span class="string">&quot;Rank&quot;</span>, <span class="string">&quot;rank-.*&quot;</span>);</span><br><span class="line"><span class="type">AwardType</span> <span class="variable">MEDAL</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AwardType</span>(<span class="string">&quot;Medal&quot;</span>, <span class="string">&quot;.*-medal&quot;</span>);</span><br><span class="line"><span class="type">AwardType</span> <span class="variable">FIRST_TO_SOLVE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AwardType</span>(<span class="string">&quot;First to Solve&quot;</span>, <span class="string">&quot;first-to-solve-.*&quot;</span>);</span><br><span class="line"><span class="type">AwardType</span> <span class="variable">GROUP</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AwardType</span>(<span class="string">&quot;Group Winner&quot;</span>, <span class="string">&quot;group-winner-.*&quot;</span>);</span><br><span class="line"><span class="type">AwardType</span> <span class="variable">ORGANIZATION</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AwardType</span>(<span class="string">&quot;Organization Winner&quot;</span>, <span class="string">&quot;organization-winner-.*&quot;</span>);</span><br><span class="line"><span class="type">AwardType</span> <span class="variable">GROUP_HIGHLIGHT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AwardType</span>(<span class="string">&quot;Group Highlight&quot;</span>, <span class="string">&quot;group-highlight-.*&quot;</span>);</span><br><span class="line"><span class="type">AwardType</span> <span class="variable">SOLVED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AwardType</span>(<span class="string">&quot;Solved&quot;</span>, <span class="string">&quot;solved-.*&quot;</span>);</span><br><span class="line"><span class="type">AwardType</span> <span class="variable">TOP</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AwardType</span>(<span class="string">&quot;Top&quot;</span>, <span class="string">&quot;top-.*&quot;</span>);</span><br><span class="line"><span class="type">AwardType</span> <span class="variable">HONORS</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AwardType</span>(<span class="string">&quot;Honors&quot;</span>, <span class="string">&quot;honors-.*&quot;</span>);</span><br><span class="line"><span class="comment">// AwardType HONORABLE_MENTION = new AwardType(&quot;Honorable Mention&quot;, &quot;honorable-mention&quot;);</span></span><br><span class="line"><span class="type">AwardType</span> <span class="variable">OTHER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AwardType</span>(<span class="string">&quot;Other&quot;</span>, <span class="string">&quot;.*&quot;</span>);</span><br><span class="line"></span><br><span class="line">AwardType[] KNOWN_TYPES = <span class="keyword">new</span> <span class="title class_">AwardType</span>[] &#123; WINNER, RANK, MEDAL, FIRST_TO_SOLVE, GROUP, ORGANIZATION,</span><br><span class="line">        GROUP_HIGHLIGHT, SOLVED, TOP, HONORS, OTHER &#125;;</span><br></pre></td></tr></table></figure><p><code>AwardType</code>第二个参数就是正则匹配规则。<s>打铁奖还被注释掉了</s></p><p>不同类型的获奖规则呈现在<code>resolver</code>上的话就是排序顺序和文字颜色和是否粗体的不同。</p><h3 id="yaml文件"><a class="markdownIt-Anchor" href="#yaml文件"></a> yaml文件</h3><p><code>yaml</code>读取的源代码在<code>ContestModel/src/org/icpc/tools/contest/model/internal/YamlParser.java</code></p><h4 id="contestyaml"><a class="markdownIt-Anchor" href="#contestyaml"></a> contest.yaml</h4><p>该文件可以直接从<code>domjudge</code>的<code>import/export</code>页面导出。</p><p>其源码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Info</span> <span class="variable">info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Info</span>();</span><br><span class="line">    info.add(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (Object ob : map.keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ob <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> (String) ob;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">val</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (val != <span class="literal">null</span>)</span><br><span class="line">                value = val.toString();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;name&quot;</span>.equals(key) &amp;&amp; oldFormat)</span><br><span class="line">                    info.add(<span class="string">&quot;formal_name&quot;</span>, value);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;short-name&quot;</span>.equals(key))</span><br><span class="line">                    info.add(<span class="string">&quot;name&quot;</span>, value);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;length&quot;</span>.equals(key) || <span class="string">&quot;duration&quot;</span>.equals(key)) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> RelativeTime.parse(value);</span><br><span class="line">                    <span class="keyword">if</span> (length &gt;= <span class="number">0</span>)</span><br><span class="line">                        info.add(<span class="string">&quot;duration&quot;</span>, RelativeTime.format(length));</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;scoreboard-freeze&quot;</span>.equals(key)) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> RelativeTime.parse(value);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> info.getDuration();</span><br><span class="line">                    <span class="keyword">if</span> (length &gt;= <span class="number">0</span> &amp;&amp; d &gt; <span class="number">0</span>)</span><br><span class="line">                        info.add(<span class="string">&quot;scoreboard_freeze_duration&quot;</span>, RelativeTime.format(d / <span class="number">1000</span> - length));</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;scoreboard-freeze-length&quot;</span>.equals(key)) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> RelativeTime.parse(value);</span><br><span class="line">                    <span class="keyword">if</span> (length &gt;= <span class="number">0</span>)</span><br><span class="line">                        info.add(<span class="string">&quot;scoreboard_freeze_duration&quot;</span>, RelativeTime.format(length));</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;penalty-time&quot;</span>.equals(key)) &#123;</span><br><span class="line">                    info.add(<span class="string">&quot;penalty_time&quot;</span>, value);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;start-time&quot;</span>.equals(key)) &#123;</span><br><span class="line">                    info.add(<span class="string">&quot;start_time&quot;</span>, value);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;banner&quot;</span>.equals(key)) &#123;</span><br><span class="line">                    info.setBanner(parseFileReferenceList((List&lt;?&gt;) val));</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;logo&quot;</span>.equals(key)) &#123;</span><br><span class="line">                    info.setLogo(parseFileReferenceList((List&lt;?&gt;) val));</span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                    info.add(key, value);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                Trace.trace(Trace.ERROR, <span class="string">&quot;Could not parse &quot;</span> + key + <span class="string">&quot;: &quot;</span> + value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从源码可以看出来其实从<code>domjudge</code>导出的<code>contest.yaml</code>有很多字段是没必要的。</p><h4 id="problemsetyaml"><a class="markdownIt-Anchor" href="#problemsetyaml"></a> problemset.yaml</h4><p><code>problemset</code>就要自己编写了。其格式上面提到。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Object o : list) &#123;</span><br><span class="line">    <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map&lt;?, ?&gt;) &#123;</span><br><span class="line">        Map&lt;?, ?&gt; map = (Map&lt;?, ?&gt;) o;</span><br><span class="line"></span><br><span class="line">        <span class="type">Problem</span> <span class="variable">problem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Problem</span>();</span><br><span class="line">        problem.add(<span class="string">&quot;ordinal&quot;</span>, <span class="string">&quot;&quot;</span> + i);</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Object ob : map.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ob <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> (String) ob;</span><br><span class="line">                <span class="type">Object</span> <span class="variable">val</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">                <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (val != <span class="literal">null</span>)</span><br><span class="line">                    value = val.toString();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;letter&quot;</span>.equals(key))</span><br><span class="line">                    problem.add(<span class="string">&quot;label&quot;</span>, value);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;short-name&quot;</span>.equals(key)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (problem.getId() == <span class="literal">null</span>)</span><br><span class="line">                        problem.add(<span class="string">&quot;id&quot;</span>, value);</span><br><span class="line">                    <span class="keyword">if</span> (problem.getName() == <span class="literal">null</span>)</span><br><span class="line">                        problem.add(<span class="string">&quot;name&quot;</span>, value);</span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                    problem.add(key, value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (problem.getId() != <span class="literal">null</span> &amp;&amp; (problem.getTestDataCount() &lt;= <span class="number">0</span> || problem.getTimeLimit() &lt;= <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="type">File</span> <span class="variable">problemFolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(f.getParentFile(), problem.getId());</span><br><span class="line">            <span class="keyword">if</span> (problemFolder.exists()) &#123;</span><br><span class="line">                addProblemTestDataCount(problemFolder, problem);</span><br><span class="line">                addProblemTimeLimit(problemFolder, problem);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    importProblem(problemFolder, problem);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="comment">// ignore for now</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        problems.add(problem);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码可以看出，它是把<code>short-name</code>作为<code>problem</code>的<code>id</code>的。而在分析一血奖时，它会根据<code>first-to-solve-A</code>中的<code>A</code>和该<code>id</code>进行匹配，若未匹配到，则会报告无法解析一血奖。</p><p>分析（呈现）获奖的代码在<code>PresContest/src/org/icpc/tools/presentation/contest/internal/presentations/resolver/TeamAwardPresentation.java</code></p><p>在<code>402</code>行处，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (IAward a : currentCache.awards) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.getAwardType() == IAward.FIRST_TO_SOLVE) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">pId</span> <span class="operator">=</span> a.getId().substring(patternLen);</span><br><span class="line">        <span class="type">IProblem</span> <span class="variable">p</span> <span class="operator">=</span> getContest().getProblemById(pId);</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span>) &#123;</span><br><span class="line">            Trace.trace(Trace.WARNING, <span class="string">&quot;Could not consolidate FTS award: &quot;</span> + a.getId());</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fts.add(p.getLabel());</span><br><span class="line">        <span class="keyword">if</span> (a.getDisplayMode() != <span class="literal">null</span>)</span><br><span class="line">            mode = a.getDisplayMode();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a.getId().contains(<span class="string">&quot;solution&quot;</span>)) &#123;</span><br><span class="line">        hasSolutionAward = <span class="literal">true</span>;</span><br><span class="line">        list.add(a);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.getAwardType() == IAward.MEDAL)</span><br><span class="line">            hasMedal = <span class="literal">true</span>;</span><br><span class="line">        list.add(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若<code>pid</code>未找到则会报告<code>Could not consolidate FTS award</code>。</p><h3 id="资源路径"><a class="markdownIt-Anchor" href="#资源路径"></a> 资源路径</h3><p>资源路径相关的代码位于<code>ContestModel/src/org/icpc/tools/contest/model/feed/DiskContestSource.java</code></p><p>在<code>823</code>行的函数<code>protected FilePattern getLocalPattern(IContestObject.ContestType type, String id, String property)</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> FilePattern <span class="title function_">getLocalPattern</span><span class="params">(IContestObject.ContestType type, String id, String property)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (type == ContestType.CONTEST) &#123;</span><br><span class="line">        <span class="keyword">if</span> (LOGO.equals(property))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FilePattern</span>(<span class="literal">null</span>, id, property, LOGO_EXTENSIONS);</span><br><span class="line">        <span class="keyword">if</span> (BANNER.equals(property))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FilePattern</span>(<span class="literal">null</span>, id, property, LOGO_EXTENSIONS);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == ContestType.TEAM) &#123;</span><br><span class="line">        <span class="keyword">if</span> (PHOTO.equals(property))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FilePattern</span>(type, id, property, PHOTO_EXTENSIONS);</span><br><span class="line">        <span class="keyword">if</span> (VIDEO.equals(property))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FilePattern</span>(type, id, property, <span class="string">&quot;m2ts&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (BACKUP.equals(property))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FilePattern</span>(type, id, property, <span class="string">&quot;zip&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (KEY_LOG.equals(property))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FilePattern</span>(type, id, property, <span class="string">&quot;txt&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (TOOL_DATA.equals(property))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FilePattern</span>(type, id, property, <span class="string">&quot;txt&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == ContestType.PERSON) &#123;</span><br><span class="line">        <span class="keyword">if</span> (PHOTO.equals(property))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FilePattern</span>(type, id, property, PHOTO_EXTENSIONS);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == ContestType.ORGANIZATION) &#123;</span><br><span class="line">        <span class="keyword">if</span> (LOGO.equals(property))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FilePattern</span>(type, id, property, LOGO_EXTENSIONS);</span><br><span class="line">        <span class="keyword">if</span> (COUNTRY_FLAG.equals(property))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FilePattern</span>(type, id, property, LOGO_EXTENSIONS);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == ContestType.SUBMISSION) &#123;</span><br><span class="line">        <span class="keyword">if</span> (FILES.equals(property))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FilePattern</span>(type, id, property, <span class="string">&quot;zip&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (REACTION.equals(property))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FilePattern</span>(type, id, property, <span class="string">&quot;m2ts&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == ContestType.GROUP) &#123;</span><br><span class="line">        <span class="keyword">if</span> (LOGO.equals(property))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FilePattern</span>(type, id, property, LOGO_EXTENSIONS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>contestType</code>定义在<code>ContestModel/src/org/icpc/tools/contest/model/IContestObject.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">ContestType</span> &#123;</span><br><span class="line">CONTEST, LANGUAGE, GROUP, ORGANIZATION, TEAM, STATE, RUN, SUBMISSION, JUDGEMENT, CLARIFICATION, AWARD, JUDGEMENT_TYPE, TEST_DATA, PROBLEM, PAUSE, TEAM_MEMBER, MAP_INFO, START_STATUS, COMMENTARY</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String[] ContestTypeNames = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;contests&quot;</span>, <span class="string">&quot;languages&quot;</span>, <span class="string">&quot;groups&quot;</span>, <span class="string">&quot;organizations&quot;</span>, <span class="string">&quot;teams&quot;</span>, <span class="string">&quot;state&quot;</span>,</span><br><span class="line">        <span class="string">&quot;runs&quot;</span>, <span class="string">&quot;submissions&quot;</span>, <span class="string">&quot;judgements&quot;</span>, <span class="string">&quot;clarifications&quot;</span>, <span class="string">&quot;awards&quot;</span>, <span class="string">&quot;judgement-types&quot;</span>, <span class="string">&quot;testdata&quot;</span>, <span class="string">&quot;problems&quot;</span>,</span><br><span class="line">        <span class="string">&quot;pause&quot;</span>, <span class="string">&quot;team-members&quot;</span>, <span class="string">&quot;map-info&quot;</span>, <span class="string">&quot;start-status&quot;</span>, <span class="string">&quot;commentary&quot;</span> &#125;;</span><br></pre></td></tr></table></figure><p>而大写变量就定义在<code>DiskContestSource.java</code>的开头处</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOGO</span> <span class="operator">=</span> <span class="string">&quot;logo&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PHOTO</span> <span class="operator">=</span> <span class="string">&quot;photo&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">VIDEO</span> <span class="operator">=</span> <span class="string">&quot;video&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BANNER</span> <span class="operator">=</span> <span class="string">&quot;banner&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BACKUP</span> <span class="operator">=</span> <span class="string">&quot;backup&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY_LOG</span> <span class="operator">=</span> <span class="string">&quot;key_log&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TOOL_DATA</span> <span class="operator">=</span> <span class="string">&quot;tool_data&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FILES</span> <span class="operator">=</span> <span class="string">&quot;files&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">REACTION</span> <span class="operator">=</span> <span class="string">&quot;reaction&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">COUNTRY_FLAG</span> <span class="operator">=</span> <span class="string">&quot;country_flag&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] LOGO_EXTENSIONS = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;png&quot;</span>, <span class="string">&quot;svg&quot;</span>, <span class="string">&quot;jpg&quot;</span>, <span class="string">&quot;jpeg&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] PHOTO_EXTENSIONS = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;jpg&quot;</span>, <span class="string">&quot;jpeg&quot;</span>, <span class="string">&quot;png&quot;</span>, <span class="string">&quot;svg&quot;</span> &#125;;</span><br></pre></td></tr></table></figure><hr /><p>以队伍照片为例，为看清它从哪里读取队伍照片，我们找到这个入口，其代码为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (type == ContestType.TEAM) &#123;</span><br><span class="line">    <span class="keyword">if</span> (PHOTO.equals(property))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FilePattern</span>(type, id, property, PHOTO_EXTENSIONS);</span><br></pre></td></tr></table></figure><p><code>FilePattern</code>的定义就在该文件的<code>78</code>行。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">FilePattern</span> &#123;</span><br><span class="line">    <span class="comment">// the folder containing the file</span></span><br><span class="line">    <span class="keyword">protected</span> String folder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the file name, without extension</span></span><br><span class="line">    <span class="keyword">protected</span> String name; <span class="comment">// e.g. &quot;logo&quot; or &quot;files&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// the file extensions</span></span><br><span class="line">    <span class="keyword">protected</span> String[] extensions; <span class="comment">// e.g. &quot;jpg&quot; or &quot;zip&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// the partial url to access the file</span></span><br><span class="line">    <span class="keyword">protected</span> String url;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FilePattern</span><span class="params">(IContestObject.ContestType type, String id, String property, String fileExtension)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(type, id, property, <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; fileExtension &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FilePattern</span><span class="params">(IContestObject.ContestType type, String id, String property, String[] fileExtensions)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.folder = <span class="string">&quot;contest&quot;</span>;</span><br><span class="line">            <span class="built_in">this</span>.url = property;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">typeName</span> <span class="operator">=</span> IContestObject.getTypeName(type);</span><br><span class="line">            <span class="built_in">this</span>.folder = typeName + File.separator + id;</span><br><span class="line">            <span class="built_in">this</span>.url = typeName + <span class="string">&quot;/&quot;</span> + id + <span class="string">&quot;/&quot;</span> + property;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.name = property;</span><br><span class="line">        <span class="built_in">this</span>.extensions = fileExtensions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> folder + <span class="string">&quot; &quot;</span> + name + <span class="string">&quot; &quot;</span> + String.join(<span class="string">&quot;,&quot;</span>, extensions) + <span class="string">&quot; &quot;</span> + url;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从构造函数可以看出，其定义的路径为<code>typeName/id/property</code></p><p>再看传入的参数，<code>type</code>为<code>ContestType.TEAM</code>，即<code>teams</code>，<code>id</code>为队伍的<code>icpc id</code>，<code>property</code>为<code>PHOTO</code>即<code>photo</code>，文件后缀名为<code>PHOTO_EXTENSIONS</code>即<code>jpg, jpeg, png, svg</code>都可以。</p><p>因此队伍的<code>icpc id</code>为<code>3000</code>的队伍照片应放置于<code>teams/3000/photo.png</code>，相对于<code>CDP</code>根目录，即<code>events.xml</code>所在的目录。</p><p>以同样的方式可以得出以下资源的放置路径：</p><ul><li>队伍录像为<code>teams/3000/video.m2ts</code></li><li>队伍备份为<code>teams/3000/backup.zip</code></li><li>队伍KEY_LOG为<code>teams/3000/key_log.txt</code></li><li>队伍TOOL_DATA为<code>teams/3000/tool_data.txt</code></li><li>个人照片为<code>persons/id/photo.png</code>（暂不清楚该<code>id</code>是什么）</li><li>组织（ORGANIZATION、Affiliations）logo为<code>organizations/3000/logo.png</code></li><li>组织（ORGANIZATION、Affiliations）country_flag为<code>organizations/3000/country_flag.png</code></li><li>提交文件为<code>submissions/id/files.zip</code>（暂不清楚该<code>id</code>是什么）</li><li>提交的reaction为<code>submissions/id/reaction.m2ts</code>（暂不清楚该<code>id</code>是什么）</li><li>组别（group、Categories）的logo为<code>groups/id/logo.png</code>（暂不清楚该<code>id</code>是什么）</li><li>比赛的logo为<code>contest/logo.png</code></li><li>比赛的banner为<code>contest/banner.png</code></li></ul><h4 id="读取的yaml"><a class="markdownIt-Anchor" href="#读取的yaml"></a> 读取的yaml</h4><p>该文件再往下看，第<code>974</code>行的函数<code>protected void loadConfigFiles() </code>可以看到其读取的<code>yaml</code>文件有</p><ul><li><code>contest.yaml</code></li><li><code>accounts.yaml</code></li><li><code>problemset.yaml</code></li><li><code>groups.tsv</code></li><li><code>institutions.tsv</code></li><li><code>teams.tsv</code></li><li><code>members.tsv</code></li></ul><h3 id="resolvertsv"><a class="markdownIt-Anchor" href="#resolvertsv"></a> resolver.tsv</h3><p>如果查看<code>resolver</code>的运行日志<code>log</code>的话，会发现一开始<code>resolver</code>似乎在尝试寻找叫<code>resolver.tsv</code>的文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2022.04.30 20:10.03 I Connection failed to resolver.tsv, trying again</span><br><span class="line">java.net.MalformedURLException: no protocol: nullresolver.tsv</span><br><span class="line">at java.base/java.net.URL.&lt;init&gt;(URL.java:674)</span><br><span class="line">at java.base/java.net.URL.&lt;init&gt;(URL.java:569)</span><br><span class="line">at java.base/java.net.URL.&lt;init&gt;(URL.java:516)</span><br><span class="line">at org.icpc.tools.contest.model.feed.RESTContestSource.createConnection(RESTContestSource.java:223)</span><br><span class="line">at org.icpc.tools.contest.model.feed.RESTContestSource.downloadIfNecessaryImpl(RESTContestSource.java:316)</span><br><span class="line">at org.icpc.tools.contest.model.feed.RESTContestSource.downloadIfNecessary(RESTContestSource.java:291)</span><br><span class="line">at org.icpc.tools.contest.model.feed.RESTContestSource.getFile(RESTContestSource.java:244)</span><br><span class="line">at org.icpc.tools.resolver.Resolver.loadSteps(Resolver.java:450)</span><br><span class="line">at org.icpc.tools.resolver.Resolver.main(Resolver.java:199)</span><br><span class="line">2022.04.30 20:10.03 I Connection failed to resolver.tsv again, trying again after 500ms</span><br><span class="line">java.net.MalformedURLException: no protocol: nullresolver.tsv</span><br><span class="line">at java.base/java.net.URL.&lt;init&gt;(URL.java:674)</span><br><span class="line">at java.base/java.net.URL.&lt;init&gt;(URL.java:569)</span><br><span class="line">at java.base/java.net.URL.&lt;init&gt;(URL.java:516)</span><br><span class="line">at org.icpc.tools.contest.model.feed.RESTContestSource.createConnection(RESTContestSource.java:223)</span><br><span class="line">at org.icpc.tools.contest.model.feed.RESTContestSource.downloadIfNecessaryImpl(RESTContestSource.java:316)</span><br><span class="line">at org.icpc.tools.contest.model.feed.RESTContestSource.downloadIfNecessary(RESTContestSource.java:291)</span><br><span class="line">at org.icpc.tools.contest.model.feed.RESTContestSource.getFile(RESTContestSource.java:244)</span><br><span class="line">at org.icpc.tools.resolver.Resolver.loadSteps(Resolver.java:450)</span><br><span class="line">at org.icpc.tools.resolver.Resolver.main(Resolver.java:199)</span><br></pre></td></tr></table></figure><p>在源码中搜索该<code>resolver.tsv</code>的话，在<code>Resolver/src/org/icpc/tools/resolver/Resolver.java</code>中的<code>loadSteps</code>函数可以看到其文件输入会被读入到一个叫<code>predeterminedSteps</code>的变量。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> br.readLine();</span><br><span class="line"><span class="keyword">while</span> (s != <span class="literal">null</span>) &#123;</span><br><span class="line">    String[] st = s.split(<span class="string">&quot;\\t&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (st != <span class="literal">null</span> &amp;&amp; st.length &gt; <span class="number">0</span>)</span><br><span class="line">        predeterminedSteps.add(<span class="keyword">new</span> <span class="title class_">PredeterminedStep</span>(st[<span class="number">0</span>], st[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    s = br.readLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里我们可以看到其格式就是一行用<code>\t</code>分隔开的两个数，从<code>PredeterminedStep</code>的构造函数<code>public PredeterminedStep(String teamId, String problemLabel)</code>我们就可以看出来这两个数分别表示<code>teamid</code>和<code>problemLabel</code>。</p><p>继续搜索该变量名<code>predeterminedSteps</code>，会在<code>ContestModel/src/org/icpc/tools/contest/model/resolver/ResolverLogic.java</code>的<code>getNextResolve</code>函数看到它起到的作用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> SubmissionInfo <span class="title function_">getNextResolve</span><span class="params">()</span> &#123;</span><br><span class="line">    ITeam[] teams = contest.getOrderedTeams();</span><br><span class="line">    <span class="type">int</span> <span class="variable">numProblems</span> <span class="operator">=</span> contest.getNumProblems();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> teams.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">ITeam</span> <span class="variable">team</span> <span class="operator">=</span> teams[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// check for predetermined steps first</span></span><br><span class="line">        <span class="keyword">for</span> (PredeterminedStep ps : predeterminedSteps) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ps.teamId.equals(team.getId())) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">pInd</span> <span class="operator">=</span> contest.getProblemIndexByLabel(ps.problemLabel);</span><br><span class="line">                <span class="keyword">if</span> (pInd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">IResult</span> <span class="variable">r1</span> <span class="operator">=</span> contest.getResult(team, pInd);</span><br><span class="line">                    <span class="keyword">if</span> (r1.getStatus() == Status.SUBMITTED) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SubmissionInfo</span>(team, pInd);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// otherwise, default to pick left</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; numProblems; j++) &#123;</span><br><span class="line">            <span class="type">IResult</span> <span class="variable">r1</span> <span class="operator">=</span> contest.getResult(team, j);</span><br><span class="line">            <span class="keyword">if</span> (r1.getStatus() == Status.SUBMITTED) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SubmissionInfo</span>(team, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从该代码的逻辑可以得知，在滚榜、揭晓各队伍提交结果的时候，一般默认是队伍从左到右的题目的提交结果，而我们通过该<code>resolver.tsv</code>就可以自定义揭晓的顺序，而不是默认的从左到右。</p><h2 id="结尾"><a class="markdownIt-Anchor" href="#结尾"></a> 结尾</h2><p>感谢你能看到最后。相信阅读完这些你会对<code>icpc tools</code>的源码有了进一步的了解。无论是文档是否未跟上，还是文档所引述的标准莫名404了，只要源码是开源的，终有办法摸清其内在的逻辑。无论之后<code>resolver</code>的代码如何变化，本文对阅读其源码，找到自己想要的信息有比较好的指引。</p>]]></content>
      
      
      <categories>
          
          <category> 源码阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ICPC_tools </tag>
            
            <tag> resolver </tag>
            
            <tag> 滚榜 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>委托构造函数</title>
      <link href="/posts/dc521e77.html"/>
      <url>/posts/dc521e77.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>摘自《现代C++语言核心特性解析》，谢丙堃 著</p></blockquote><p>委托构造函数是<code>C++11</code>引入的一个新特性，它细化了构造函数的种类，将原来的构造函数细化为<strong>委托构造函数(<code>delegating constructor</code>)<strong>和</strong>代理构造函数(<code>target constructor</code>)</strong>，旨在解决构造函数代码冗余的问题。</p><h2 id="冗余的构造函数"><a class="markdownIt-Anchor" href="#冗余的构造函数"></a> 冗余的构造函数</h2><p>一个类为了确保所有成员变量的初始化，有很多构造函数是很常见的。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="built_in">X</span>(): <span class="built_in">a_</span>(<span class="number">0</span>), <span class="built_in">b_</span>(<span class="number">0.</span>) &#123; <span class="built_in">CommonInit</span>(); &#125;</span><br><span class="line">    <span class="built_in">X</span>(<span class="type">int</span> a): <span class="built_in">a_</span>(a), <span class="built_in">b_</span>(<span class="number">0.</span>) &#123; <span class="built_in">CommonInit</span>(); &#125;</span><br><span class="line">    <span class="built_in">X</span>(<span class="type">double</span> b): <span class="built_in">a_</span>(<span class="number">0</span>), <span class="built_in">b_</span>(b) &#123; <span class="built_in">CommonInit</span>(); &#125;</span><br><span class="line">    <span class="built_in">X</span>(<span class="type">int</span> a, <span class="type">double</span> b): <span class="built_in">a_</span>(a), <span class="built_in">b_</span>(b) &#123; <span class="built_in">CommonInit</span>(); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CommonInit</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="type">int</span> a_;</span><br><span class="line">    <span class="type">double</span> b_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然该代码没有任何语法问题，但构造函数包含了太多的重复代码，使得维护变得非常困难。当成员变量变多时，所需要的成员变量就变得更多了。</p><p>如果将初始化部分放到<code>CommonInit</code>函数里，即这样：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="built_in">X</span>() &#123; <span class="built_in">CommonInit</span>(<span class="number">0</span>, <span class="number">0.</span>); &#125;</span><br><span class="line">    <span class="built_in">X</span>(<span class="type">int</span> a) &#123; <span class="built_in">CommonInit</span>(a, <span class="number">0.</span>); &#125;</span><br><span class="line">    <span class="built_in">X</span>(<span class="type">double</span> b) &#123; <span class="built_in">CommonInit</span>(<span class="number">0</span>, b); &#125;</span><br><span class="line">    <span class="built_in">X</span>(<span class="type">int</span> a, <span class="type">double</span> b) &#123; <span class="built_in">CommonInit</span>(a, b); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CommonInit</span><span class="params">(<span class="type">int</span> a, <span class="type">double</span> b)</span></span>&#123;</span><br><span class="line">        a_ = a;</span><br><span class="line">        b_ = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> a_;</span><br><span class="line">    <span class="type">double</span> b_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但实际上这样一方面对性能有一些损失，另一方面也有不可行的可能。</p><p>因为在调用<code>CommonInit</code>函数时，变量的初始化已经完毕了（初始化列表进行初始化），在该函数进行赋值，实际上是对变量进行了两次操作（初始化一次，赋值一次）。</p><p>另外，赋值依靠的是赋值运算符，如果有的数据成员被禁用了赋值运算符，则会编译错误。</p><h2 id="委托构造函数"><a class="markdownIt-Anchor" href="#委托构造函数"></a> 委托构造函数</h2><p>因此委托构造函数就是在<strong>初始化列表</strong>中调用其他的构造函数，去委托其他构造函数帮忙初始化。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="built_in">X</span>(): <span class="built_in">X</span>(<span class="number">0</span>, <span class="number">0.</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">X</span>(<span class="type">int</span> a): <span class="built_in">X</span>(a, <span class="number">0.</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">X</span>(<span class="type">double</span> b): <span class="built_in">X</span>(<span class="number">0</span>, b) &#123;&#125;</span><br><span class="line">    <span class="built_in">X</span>(<span class="type">int</span> a, <span class="type">double</span> b): <span class="built_in">a_</span>(a), <span class="built_in">b_</span>(b) &#123; <span class="built_in">CommonInit</span>(); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CommonInit</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="type">int</span> a_;</span><br><span class="line">    <span class="type">double</span> b_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，委托构造函数可以多级委托。</p><p>当定义一个变量时，其执行过程如下。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">X a;</span><br><span class="line"></span><br><span class="line"><span class="built_in">X</span>() -&gt; <span class="built_in">X</span>(<span class="number">0</span>, <span class="number">0.</span>) -&gt; <span class="built_in">CommonInit</span>() -&gt; &#123;&#125; -&gt; 结束</span><br></pre></td></tr></table></figure><p>先调用无参构造函数，然后调用<code>X(int, double)</code>构造函数，然后执行该构造函数的主体，最后再执行<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo stretchy="false">(</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X()</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mopen">(</span><span class="mclose">)</span></span></span></span>的主体。</p><p><strong>谨防递归委托</strong>。</p><p>在初始化列表委托构造函数的话，就不能再初始化其他变量，即以下书写时非法的：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">X</span>(): <span class="built_in">X</span>(<span class="number">0</span>), <span class="built_in">b_</span>(<span class="number">0.</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="委托模板构造函数"><a class="markdownIt-Anchor" href="#委托模板构造函数"></a> 委托模板构造函数</h2><p>委托模板构造函数就是委托的函数时一个模板函数，一个例子。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="title">X</span><span class="params">(T first, T last)</span> : l_(first, last) &#123;</span> &#125;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; l_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>(vector&lt;<span class="type">short</span>&gt;&amp;);</span><br><span class="line">    <span class="built_in">X</span>(deque&lt;<span class="type">int</span>&gt;&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">X::<span class="built_in">X</span>(vector&lt;<span class="type">short</span>&gt;&amp; v) : <span class="built_in">X</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>()) &#123; &#125;</span><br><span class="line">X::<span class="built_in">X</span>(deque&lt;<span class="type">int</span>&gt;&amp; v) : <span class="built_in">X</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>()) &#123; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">short</span>&gt; a&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; b&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="function">X <span class="title">x1</span><span class="params">(a)</span></span>;</span><br><span class="line">    <span class="function">X <span class="title">x2</span><span class="params">(b)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样将用<code>vector</code>和<code>deque</code>初始化的构造函数委托给模板构造函数，就无需编写<code>vector&lt;short&gt;</code>和<code>deque&lt;int&gt;</code>的代理构造函数，只要保证参数类型支持迭代器即可。</p><h2 id="捕获委托构造函数的异常"><a class="markdownIt-Anchor" href="#捕获委托构造函数的异常"></a> 捕获委托构造函数的异常</h2><p>捕获异常的写法我第一次看非常震惊，直接看例子。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>() <span class="keyword">try</span> : <span class="built_in">X</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">int</span> e) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;catch: &quot;</span> &lt;&lt; e &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">X</span>(<span class="type">int</span> a) <span class="keyword">try</span> : <span class="built_in">X</span>(a, <span class="number">0.</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">int</span> e) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;catch: &quot;</span> &lt;&lt; e &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">X</span>(<span class="type">double</span> b) : <span class="built_in">X</span>(<span class="number">0</span>, b) &#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">X</span>(<span class="type">int</span> a, <span class="type">double</span> b) : <span class="built_in">a_</span>(a), <span class="built_in">b_</span>(b) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">throw</span> <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a_;</span><br><span class="line">    <span class="type">double</span> b_;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        X x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">int</span> e) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;catch: &quot;</span> &lt;&lt; e &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其输出结果为</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">catch: 1</span><br><span class="line">catch: 2</span><br><span class="line">catch: 3</span><br></pre></td></tr></table></figure><h2 id="委托参数较少的构造函数"><a class="markdownIt-Anchor" href="#委托参数较少的构造函数"></a> 委托参数较少的构造函数</h2><p>以上注意到我们委托的构造函数一般都是参数更多函数，实际上也可以委托给参数更少的构造函数，这子类跟调用父类构造函数非常类似，由参数更少的构造函数完成一些初始化函数，自己再做别的事情。</p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>为了解决构造两数冗余的问题，C++委员会想了很多办法，本章介绍的委托构造两数就是其中之一，也是最重要的方法。通过委托构造两数，我们可以有效地減少构造两数重复初始化数据成员的问题，将初始化工作统一地交给某个构造西数来完成。这样在需要增减和修改数据成员的时候就只需要修改代理构造两数即可。不止如此，委托构造两数甚至支持通过模板来进一步简化编写多余构造两数的工作，可以说该特性对于复杂类结构是非常高效且实用的。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一次网站的搭建和优化经历</title>
      <link href="/posts/cd8d5fec.html"/>
      <url>/posts/cd8d5fec.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>第一次网站的搭建和优化经历。</p></blockquote><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>上个月接到个任务，需要开发一个代码提交网站，以在这个月的比赛中使用，届时会有将近千名考生提交代码。嗯当时的需求就是如此简洁明了。</p><h2 id="设计"><a class="markdownIt-Anchor" href="#设计"></a> 设计</h2><p>因为之前重构过一次网站，采用的是<code>React+golang</code>，于是这次也采用这样的前后端分离的技术。</p><p>于是花了一个星期，设计了前端样式，前后端数据传输的格式，数据库表结构，并且去<code>github</code>搜索了可行的技术框架，参考别人的一些代码。</p><p>虽然当时预想的是在比赛结束前30分钟或者比赛结束后10分钟开放提交。但考虑到考生应该对系统有熟悉的时间，于是设计时将比赛的<code>active</code>时间和<code>open</code>时间分开，也即考生可以登录的时间和可以提交的时间分开。这样利于考生提前登录熟悉环境，也有利于分散流量。</p><h2 id="编码"><a class="markdownIt-Anchor" href="#编码"></a> 编码</h2><p>在感觉一切确定好后，在某个周末开工，由于先前重构过网站，这两个网站有一定的相似性，和一些类似的<code>demo</code>，通过简单<code>CV</code>和更改，花了一天写完了前端，一天写完了后端。</p><ul><li>在前端方面，</li></ul><p>不得不说<code>react router</code>的升级真的激进，<code>v5</code>跟<code>v6</code>的差别好大，好多函数组建都被改名或弃用了，导致网上参考的别人的代码（采用<code>v5</code>的）都失效了，只能去看<a href="https://reactrouterdotcom.fly.dev/docs/en/v6">官方文档</a>。其余的，<code>react</code>引入的<code>hook</code>是真的香，不用再写一些类，定义一些有的无的东西，简化了代码，感觉非常舒心。不过目前也就只会用<code>useState</code>和<code>useEffect</code>，对于表单<code>form</code>之类的，在数据处理方面写的有些繁琐，表单的每一项都要一个单独的<code>handle</code>函数，提交也是单独一个提交函数，感觉完全割裂了表单数据的整体性，不像之前看到的<code>php</code>写法。听说可以用<code>useForm</code>来解决，下次去看看。</p><p>前端<code>UI</code>库还是沿用了老一辈学长所使用的<code>semantic UI</code>。但这个库感觉过于古老了，以至于在使用上，尤其是错误消息提醒方面的效果和动画渐变效果比较难以实现，不像<code>antd</code>的错误效果有专门的函数，能够实现右上角、中间弹窗消失的效果。不过<code>semantic</code>唯一让我中意的就是<code>table</code>的样式，尤其是单元格的颜色对错时的绿色和红色。</p><ul><li>在后端方面，</li></ul><p>由于要维持用户的登录状态，众所周知这需要<code>cookie</code>，但这个<code>cookie</code>存哪里呢我一直没找到什么解释。故我就采用最原始的存在数据库里并存着失效时间，但这样每次访问都要验证<code>cookie</code>的有效性而查询数据库，感觉效率会大大降低。网上搜到的一些方法如<code>gin</code>也就采用<code>session</code>的方式，但具体原理未能理解。</p><p>其次，在最初的设计中没有考虑后端代码的结构，虽然这次没有像第一次重构时所有代码写到一个文件里导致长达1000行，而是分了不同的文件，但在写的时候还是碰到了冗余代码的问题：在验证用户的权限、提交题目的权限等地方都有多次获取用户所在组等信息。原本设想的是不同地方获取的信息不同，如果统一写的话在不同地方会有冗余信息出来，但像这样，在提交题目时需要获取用户所在比赛的信息，在验证用户是否有权限访问某网站需要用户的身份的信息，特化在特定行为需要特定的信息，就为了那微不足道的性能优化降低了代码的可维护性，大大增加后续代码维护的成本。因此下次，设计时包括后端代码的结构组织，重复代码的提取，不要过早优化性能。</p><p>上周无意间发现了个不错的<code>golang</code>的脚手架<a href="https://github.com/gourouting/singo">singo</a>。采用的<code>MVC</code>组织方式，将<code>api</code>的监听层和事务逻辑层分隔开，层次清晰，同时也学习到了<code>GORM</code>库，将与数据库交互的<code>sql</code>语句进行封装。也学习到了更优美的中间件的使用方式。忽然意识到去年10月用<code>python</code>的<code>django</code>也是采用这样的方式组织代码，有视图层，管理层，序列化层，看样子是一个很好的组织方式。</p><h2 id="优化"><a class="markdownIt-Anchor" href="#优化"></a> 优化</h2><p>写完后，忽然多了个需求想增加个通知界面，能够发布通知和试题压缩包链接之类的，于是很快啊，考虑到通知的增加需求，加了个简单页面，数据库加了个表。</p><p>然后啊，忽然说想让选手可以在整场比赛都可以提交，并且想提前一天开放登录，但不能提交，让他们熟悉下系统。还好之前考虑到这点，区分了这两种行为的时间，就不需要做改动了hhh。</p><p>就绪后，整了个服务器，然后把网站部署了下，测试测试，感觉一切功能良好，然后按了下<code>F12</code>，网络一览忽然发现传输的<code>main.js</code>文件多大<code>1.8MB</code>。</p><p>一个人传输<code>1.8MB</code>，那1000个人就是<code>2G</code>了。这对于区区只有<code>10M</code>带宽的服务器怎么抵得住。</p><p>为了减少这个文件的大小，了解了<code>webpack</code>的作用，通过询问别人得知可以通过<code>source-map-explorer</code>插件查看这个<code>js</code>的内部结构。于是看到了为什么文件会这么大。</p><p><img src="bigbig.png" alt="bigbig" /></p><p>原来是代码高亮插件<code>highlight</code>如此之大，<code>webpack</code>把该插件中适用所有语言的高亮脚本都整进去了，而事实上我们允许提交的语言只有<code>C++</code>，因此只要保留这个语言的高亮脚本就好了。</p><p>明白了第一步的优化方向，剩下的就是如何做到这个。通过网上的搜索，由于我是用<code>create-react-app</code>构建的应用，修改<code>webpack</code>我不想<code>eject</code>内部配置，于是用<code>react-app-rewired</code>和<code>customize-cra</code>（实际这个没用到，因为没有写成模块化的形式）修改。通过如下代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config.plugins.push(</span><br><span class="line">    new webpack.ContextReplacementPlugin(/highlight\.js\/lib\/languages$/, new RegExp(`^./(cpp)$`))</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>但这个代码是在理解了<code>webpack</code>的配置形式才写出来的，相关的参考资料有：<a href="https://juejin.cn/post/6844904190083350542">非常棒的</a>，<a href="https://juejin.cn/post/6969018138591494158">了解的</a>，<a href="https://juejin.cn/post/7046616302521155614#heading-15">优化方向的</a>。</p><p><img src="update.png" alt="update" /></p><p>可以看见<code>highlight</code>插件的大小陡然减少了。</p><p>然后又对一些常用库比如<code>reach, reach-router, axio, ace</code>等库采用<code>cdn</code>引入，同时将原本用的关于时间的插件<code>moment</code>插件换成了更加轻量级的<code>dateformat</code>插件，也减少了体积。最终效果如下。</p><p><img src="result.png" alt="result" /></p><p>而关于<code>cdn</code>的，一开始采用的是<code>https://www.bootcdn.cn</code>，但在实际测试时网站有时加载比较慢，由于从这个网站获取<code>js</code>慢导致的，因此最后还是把这些<code>js</code>库放到了自己的服务器里，用腾讯云的<code>cdn</code>来缓存这些网页文件。新用户能有几十G的流量应该够用的。</p><h2 id="杂项"><a class="markdownIt-Anchor" href="#杂项"></a> 杂项</h2><p>本地开发时数据转发的问题，是解决cookies跨域（？）的问题，在<code>src</code>文件夹下创立<code>setupProxy.js</code>，内容如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const &#123;createProxyMiddleware&#125; = require(&quot;http-proxy-middleware&quot;);</span><br><span class="line">    module.exports = function(app)&#123;</span><br><span class="line">        app.use(</span><br><span class="line">            createProxyMiddleware(&quot;/api&quot;,&#123;</span><br><span class="line">                target:&quot;http://127.0.0.1:9000&quot;,</span><br><span class="line">                changeOrigin:true,</span><br><span class="line">            &#125;)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>关于用<code>react-app-rewired</code>进行<code>webpack</code>的配置的<code>config-overrides.js</code>文件，创立于与<code>package.json</code>同级目录，内容如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var webpack = require(&#x27;webpack&#x27;)</span><br><span class="line">const cssminimizerplugin = require(&quot;css-minimizer-webpack-plugin&quot;)</span><br><span class="line">// const minicssextractplugin = require(&quot;mini-css-extract-plugin&quot;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    webpack: function(config, env) &#123;</span><br><span class="line">        console.log(&#x27;env&#x27;, env);</span><br><span class="line"></span><br><span class="line">        config.plugins.push(</span><br><span class="line">            new webpack.contextreplacementplugin(/highlight\.js\/lib\/languages$/, new regexp(`^./(cpp)$`))</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        // config.plugins.push(</span><br><span class="line">        //     new minicssextractplugin(&#123;</span><br><span class="line">        //         filename: &quot;[name].css&quot;,</span><br><span class="line">        //         chunkfilename: &quot;[id].css&quot;,</span><br><span class="line">        //     &#125;),</span><br><span class="line">        // );</span><br><span class="line"></span><br><span class="line">        // config.module.rules.push(&#123;</span><br><span class="line">        //     test: /\.css$/,</span><br><span class="line">        //     use: [minicssextractplugin.loader, &quot;css-loader&quot;],</span><br><span class="line">        // &#125;);</span><br><span class="line"></span><br><span class="line">        config.optimization.minimizer.push(</span><br><span class="line">            new cssminimizerplugin()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        config.externals = &#123;</span><br><span class="line">            &#x27;react&#x27;: &#x27;react&#x27;,</span><br><span class="line">            &#x27;react-dom&#x27;: &#x27;reactdom&#x27;,</span><br><span class="line">            // &#x27;react-router-dom&#x27;: &#x27;reactrouterdom&#x27;,</span><br><span class="line">            &#x27;ace-builds&#x27;: &#x27;ace&#x27;,</span><br><span class="line">            &#x27;react-ace&#x27;: &#x27;reactace&#x27;,</span><br><span class="line">            &#x27;axios&#x27;: &#x27;axios&#x27;,</span><br><span class="line">            &#x27;highlight.js&#x27;:&#x27;hljs&#x27;,</span><br><span class="line">            &#x27;semantic-ui-react&#x27;: &#x27;semanticuireact&#x27;,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return config;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中引用<code>cdn</code>的写法，也即<code>externals</code>里面编写的形式，在上面提到的<a href="https://juejin.cn/post/6844904190083350542">非常棒的</a>的介绍里有提到。非常感谢这位作者。</p><p>简单来说，冒号前面是包名，后面是该脚本<code>js</code>最终赋值给window的全局变量名称。而这个名称通过查阅该<code>js</code>脚本就可以找到。一般就位于<code>js</code>脚本的开头或结尾。</p><h2 id="结果"><a class="markdownIt-Anchor" href="#结果"></a> 结果</h2><p>最终，网页访问压力都由腾讯的<code>cdn</code>承担了，后端<code>api</code>的访问由服务器承担。</p><p><img src="cdn1.png" alt="cdn1" /></p><p><img src="cdn2.png" alt="cdn2" /></p><p><img src="back.png" alt="back" /></p><p>在实际上线时，全程监测着服务器的<code>cpu</code>占用率和流量情况。由于前一天发现轻量级服务器不支持短时提升带宽，对当前服务器只有10M带宽感到担忧，但从最终结果来看，带宽高峰期也就出现在比赛开始前和比赛即将结束时，<code>cdn</code>的带宽高峰期有<code>11M</code>，只承担了后端<code>api</code>的服务器带宽高峰期也有<code>9M</code>（但感觉有点异常），可见<code>cdn</code>很好的缓解了流量高峰时服务器的压力，将前端后端访问分离开，才保证了本次比赛的顺利，因为两者加起来所需要的带宽超过了服务器本身的带宽。</p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>最后的最后，感谢你能看到最后。这里只是一些个人的碎碎念。</p><p>总而言之，在最初阶段，应该有充足的时间进行设计，规划好前端页面的组织，前后端数据格式，后端代码的结构。一个良好的设计能够大大降低后续代码的编写复杂度和维护难度，毕竟磨刀不误砍柴工。</p><p>在优化方面，前端涉及的领域是<code>webpack</code>，优化除了上述提到的<code>js</code>，实际还有<code>css</code>方面的优化。该网站虽然主要的<code>js</code>只有<code>40kb</code>，但<code>css</code>文件有<code>500kb</code>。可能是因为包括了<code>semantic</code>库的缘故。但由于后来在服务器的<code>nginx</code>开启了<code>gzip</code>压缩，传输的<code>css</code>只有<code>100kb</code>，因此也就没有太大的优化了。后端的由于不太熟悉，除了用高性能的框架之外，还暂时不知该如何优化。</p><p>如果有以后，<code>UI</code>库想试试<a href="https://mantine.dev">mantine</a>库。而<code>golang</code>用用<a href="https://github.com/gourouting/singo">singo</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 网站搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 碎碎念 </tag>
            
            <tag> react </tag>
            
            <tag> golang </tag>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新环境配置</title>
      <link href="/posts/b8a8c0a4.html"/>
      <url>/posts/b8a8c0a4.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近由于要部署网站到新服务器，为方便操作要安装一些软件比如vim、ranger、zsh、lazygit。曾经从Ubuntu换到ArchLinux再换到MacOS，期间都是上网搜的教程部署，想着留得青山在，就不怕没柴烧的想法，就部署部署就没了，期间遇到的一些问题和搜到的解决方案也是解决后就扔了，没有记录存档下来。因此最近部署重新安装时又要费时上网搜，于是打算记录一下个人的安装教程，以便后续复用，减少配置环境的时间。</p></blockquote><h2 id="总命令"><a class="markdownIt-Anchor" href="#总命令"></a> 总命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># update</span></span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt upgrade</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">need_install</span></span>()&#123;</span><br><span class="line">    <span class="built_in">sudo</span> apt install nodejs npm tmux nginx -y</span><br><span class="line">    <span class="built_in">sudo</span> npm install -g pm2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">zsh_install</span></span>()&#123;</span><br><span class="line">    <span class="comment"># install zsh, git</span></span><br><span class="line">    <span class="built_in">sudo</span> apt install zsh git unzip -y</span><br><span class="line">    chsh -s /bin/zsh</span><br><span class="line">    <span class="comment"># install oh my zsh</span></span><br><span class="line">    curl -fsSL https://gh-proxy.com/https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh -o install.sh</span><br><span class="line">    sed -i <span class="string">&quot;73c REMOTE=<span class="variable">$&#123;REMOTE:-https://gh-proxy.com/https://github.com/<span class="variable">$&#123;REPO&#125;</span>.git&#125;</span>&quot;</span> install.sh</span><br><span class="line">    bash install.sh</span><br><span class="line">    <span class="built_in">rm</span> install.sh</span><br><span class="line"></span><br><span class="line">    <span class="comment"># install dracula theme</span></span><br><span class="line">    wget https://gh-proxy.com/https://github.com/dracula/zsh/archive/master.zip</span><br><span class="line">    unzip master.zip</span><br><span class="line">    <span class="built_in">mv</span> zsh-master/dracula.zsh-theme ~/.oh-my-zsh/themes</span><br><span class="line">    <span class="built_in">mv</span> zsh-master/lib ~/.oh-my-zsh/themes</span><br><span class="line">    <span class="built_in">rm</span> master.zip</span><br><span class="line">    <span class="built_in">rm</span> -rf zsh-master</span><br><span class="line">    git <span class="built_in">clone</span> https://gh-proxy.com/https://github.com/zsh-users/zsh-autosuggestions <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-autosuggestions</span><br><span class="line">    git <span class="built_in">clone</span> https://gh-proxy.com/https://github.com/zsh-users/zsh-syntax-highlighting.git <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-syntax-highlighting</span><br><span class="line">    sed -i <span class="string">&quot;11c ZSH_THEME=\&quot;dracula\&quot;&quot;</span> ~/.zshrc</span><br><span class="line">    sed -i <span class="string">&quot;73c plugins=( git cp z wd sudo colored-man-pages zsh-autosuggestions zsh-syntax-highlighting web-search extract )&quot;</span> ~/.zshrc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">nvim_install</span></span>()&#123;</span><br><span class="line">    <span class="comment"># install nvim</span></span><br><span class="line">    <span class="built_in">sudo</span> apt-get install software-properties-common</span><br><span class="line">    <span class="built_in">sudo</span> add-apt-repository ppa:neovim-ppa/stable</span><br><span class="line">    <span class="built_in">sudo</span> apt update</span><br><span class="line">    <span class="built_in">sudo</span> apt install -y neovim</span><br><span class="line">    <span class="comment"># remove vi vim</span></span><br><span class="line">    <span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /usr/bin/vi</span><br><span class="line">    <span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /usr/bin/vim</span><br><span class="line">    <span class="built_in">sudo</span> <span class="built_in">ln</span> -s /usr/bin/nvim /usr/bin/vi</span><br><span class="line">    <span class="built_in">sudo</span> <span class="built_in">ln</span> -s /usr/bin/nvim /usr/bin/vim</span><br><span class="line">    <span class="comment"># install vim plug</span></span><br><span class="line">    curl -fLo ~/.config/nvim/autoload/plug.vim --create-dirs https://gh-proxy.com/https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</span><br><span class="line">    <span class="comment"># install nodejs npm</span></span><br><span class="line">    <span class="built_in">sudo</span> apt install nodejs npm</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">lazygit_install</span></span>()&#123;</span><br><span class="line">    LAZYGIT_VERSION=$(curl -s <span class="string">&quot;https://api.github.com/repos/jesseduffield/lazygit/releases/latest&quot;</span> | \grep -Po <span class="string">&#x27;&quot;tag_name&quot;: *&quot;v\K[^&quot;]*&#x27;</span>)</span><br><span class="line">    curl -Lo lazygit.tar.gz <span class="string">&quot;https://gh-proxy.com/https://github.com/jesseduffield/lazygit/releases/download/v<span class="variable">$&#123;LAZYGIT_VERSION&#125;</span>/lazygit_<span class="variable">$&#123;LAZYGIT_VERSION&#125;</span>_Linux_x86_64.tar.gz&quot;</span></span><br><span class="line">    tar xf lazygit.tar.gz lazygit</span><br><span class="line">    <span class="built_in">sudo</span> install lazygit -D -t /usr/local/bin/</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">yazi_install</span></span>()&#123;</span><br><span class="line">    YAZI_VERSION=$(curl -s <span class="string">&quot;https://api.github.com/repos/sxyazi/yazi/releases/latest&quot;</span> | \grep -Po <span class="string">&#x27;&quot;tag_name&quot;: *&quot;v\K[^&quot;]*&#x27;</span>)</span><br><span class="line">    curl -Lo yazi.tar.gz <span class="string">&quot;https://gh-proxy.com/https://github.com/sxyazi/yazi/releases/download/v<span class="variable">$&#123;YAZI_VERSION&#125;</span>/yazi-x86_64-unknown-linux-gnu.zip&quot;</span></span><br><span class="line">    unzip yazi.tar.gz</span><br><span class="line">    <span class="built_in">cd</span> yazi-x86_64-unknown-linux-gnu</span><br><span class="line">    <span class="built_in">sudo</span> install ya yazi -D -t /usr/local/bin/</span><br><span class="line">    <span class="built_in">cd</span> ..</span><br><span class="line">    <span class="built_in">rm</span> -rf yazi-x86_64-unknown-linux-gnu</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Do you wish to install zsh?&quot;</span></span><br><span class="line"><span class="keyword">select</span> yn <span class="keyword">in</span> <span class="string">&quot;Yes&quot;</span> <span class="string">&quot;No&quot;</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">case</span> <span class="variable">$yn</span> <span class="keyword">in</span></span><br><span class="line">        Yes )</span><br><span class="line">            zsh_install</span><br><span class="line">            ;;</span><br><span class="line">        No )</span><br><span class="line">            ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Do you wish to install nvim?&quot;</span></span><br><span class="line"><span class="keyword">select</span> yn <span class="keyword">in</span> <span class="string">&quot;Yes&quot;</span> <span class="string">&quot;No&quot;</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">case</span> <span class="variable">$yn</span> <span class="keyword">in</span></span><br><span class="line">        Yes )</span><br><span class="line">            nvim_install</span><br><span class="line">            ;;</span><br><span class="line">        No )</span><br><span class="line">            ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Do you wish to install yazi?&quot;</span></span><br><span class="line"><span class="keyword">select</span> yn <span class="keyword">in</span> <span class="string">&quot;Yes&quot;</span> <span class="string">&quot;No&quot;</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">case</span> <span class="variable">$yn</span> <span class="keyword">in</span></span><br><span class="line">        Yes )</span><br><span class="line">            lazygit_install</span><br><span class="line">            ;;</span><br><span class="line">        No )</span><br><span class="line">            ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Do you wish to install ranger?&quot;</span></span><br><span class="line"><span class="keyword">select</span> yn <span class="keyword">in</span> <span class="string">&quot;Yes&quot;</span> <span class="string">&quot;No&quot;</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">case</span> <span class="variable">$yn</span> <span class="keyword">in</span></span><br><span class="line">        Yes )</span><br><span class="line">            ranger_install</span><br><span class="line">            ;;</span><br><span class="line">        No )</span><br><span class="line">            ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="初始化"><a class="markdownIt-Anchor" href="#初始化"></a> 初始化</h2><p>刚买的服务器首先要更新软件版本信息</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Ubuntu</span></span><br><span class="line"><span class="comment"># 更新软件源信息</span></span><br><span class="line"><span class="built_in">sudo</span> apt update     </span><br><span class="line"><span class="comment"># 更新软件</span></span><br><span class="line"><span class="built_in">sudo</span> apt upgrade</span><br><span class="line"></span><br><span class="line"><span class="comment"># ArchLinux</span></span><br><span class="line"><span class="comment"># 更新软件源信息+软件</span></span><br><span class="line"><span class="built_in">sudo</span> pacman -Syyu</span><br><span class="line"></span><br><span class="line"><span class="comment"># MacOS</span></span><br><span class="line"><span class="comment"># 更新软件源信息</span></span><br><span class="line">brew update</span><br><span class="line"><span class="comment"># 更新软件</span></span><br><span class="line">brew upgrade</span><br></pre></td></tr></table></figure><h2 id="zsh"><a class="markdownIt-Anchor" href="#zsh"></a> zsh</h2><h3 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h3><p><code>zsh</code>相比<code>bash</code>有非常棒的<strong>历史命令补全</strong>和<strong>优化的Tab补全</strong>，在输入搜索文件文本命令<code>find . -type f | xargs grep &quot;zsh</code>时能节省大量时间以及可以按Tab选择补全项。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装zsh</span></span><br><span class="line"><span class="built_in">sudo</span> apt install zsh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将zsh设置为默认shell</span></span><br><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure><p>重新登录终端即替换成<code>zsh</code>。</p><p>关于<code>zsh</code>可以修改<code>~/.zshrc</code>文件。</p><h2 id="oh-my-zsh"><a class="markdownIt-Anchor" href="#oh-my-zsh"></a> oh my zsh</h2><h3 id="安装-2"><a class="markdownIt-Anchor" href="#安装-2"></a> 安装</h3><p><code>oh my zsh</code>是一个配置<code>zsh</code>的框架，可以方便设置主题，添加插件等。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 需要安装git</span></span><br><span class="line">sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure><h3 id="主题"><a class="markdownIt-Anchor" href="#主题"></a> 主题</h3><p>安装主题<code>dracula</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/dracula/zsh/archive/master.zip</span><br><span class="line">unzip master.zip</span><br><span class="line"><span class="built_in">mv</span> dracula.zsh-theme/dracula.zsh-theme ~/.oh-my-zsh/themes</span><br><span class="line"><span class="built_in">mv</span> dracula.zsh-theme/lib ~/.oh-my-zsh/themes</span><br><span class="line"><span class="built_in">rm</span> master.zip</span><br><span class="line"><span class="built_in">rm</span> -rf dracula.zsh-theme</span><br></pre></td></tr></table></figure><p>编辑<code>~/.zshrc</code>文件，修改主题为<code>ZSH_THEME=&quot;dracula&quot;</code></p><h3 id="插件"><a class="markdownIt-Anchor" href="#插件"></a> 插件</h3><p><code>oh my zsh</code>内置挺多插件的，一般用到的如下</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">plugins=(</span><br><span class="line"><span class="comment"># 提供了git常用命令的别名，但由于用lazygit这个很少用到</span></span><br><span class="line">    git</span><br><span class="line"><span class="comment"># 提供cpv命令带有进度条的rsync功能</span></span><br><span class="line">    <span class="built_in">cp</span></span><br><span class="line"><span class="comment"># 记录跳转目录频率，输入文件夹名即可跳转</span></span><br><span class="line">    z</span><br><span class="line"><span class="comment"># 给目录添加别名功能，方便跳转</span></span><br><span class="line">    wd</span><br><span class="line"><span class="comment"># 按两下esc即可加sudo</span></span><br><span class="line">    <span class="built_in">sudo</span></span><br><span class="line"><span class="comment"># 让man手册彩色易读</span></span><br><span class="line">    colored-man-pages</span><br><span class="line"><span class="comment"># zsh自动补全</span></span><br><span class="line">    zsh-autosuggestions</span><br><span class="line"><span class="comment"># zsh语法高亮，如不可执行命令为红色否则为绿色</span></span><br><span class="line">    zsh-syntax-highlighting</span><br><span class="line"><span class="comment"># 网页搜索</span></span><br><span class="line">    web-search</span><br><span class="line"><span class="comment"># 一键解压</span></span><br><span class="line">    extract</span><br><span class="line"><span class="comment"># vi模式，默认插入模式</span></span><br><span class="line">    vi-mode</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>其中自动补全和语法高亮需要额外下载。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-autosuggestions</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure><h2 id="vim"><a class="markdownIt-Anchor" href="#vim"></a> Vim</h2><h3 id="安装-3"><a class="markdownIt-Anchor" href="#安装-3"></a> 安装</h3><p>一开始用<code>Vim</code>后来用<code>NVim</code>，感觉也没太大差别。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装管理源的工具</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get install software-properties-common</span><br><span class="line"><span class="comment"># 添加新源，安装neovim</span></span><br><span class="line"><span class="built_in">sudo</span> add-apt-repository ppa:neovim-ppa/stable</span><br><span class="line"><span class="comment"># 更新软件源信息</span></span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="comment"># 安装neovim</span></span><br><span class="line"><span class="built_in">sudo</span> apt install -y neovim</span><br></pre></td></tr></table></figure><p>然后把<code>vi</code>和<code>vim</code>都删了（</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /usr/bin/vi </span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /usr/bin/vim</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">ln</span> -s /usr/bin/nvim /usr/bin/vi</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">ln</span> -s /usr/bin/nvim /usr/bin/vim</span><br></pre></td></tr></table></figure><h3 id="插件-2"><a class="markdownIt-Anchor" href="#插件-2"></a> 插件</h3><p><code>vim</code>推荐用<code>vim-plug</code>管理插件。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -fLo ~/.config/nvim/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</span><br></pre></td></tr></table></figure><p>语法高亮用的是<code>coc.nvim</code>，需要安装<code>nodejs</code>和<code>npm</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install nodejs npm</span><br></pre></td></tr></table></figure><p>编辑<code>~/.config/nvim/init.vim</code>文件（没有就新建）。</p><h2 id="lazygit"><a class="markdownIt-Anchor" href="#lazygit"></a> Lazygit</h2><p><code>Lazygit</code>是一个图形化（？但还是键盘操控）的<code>git</code>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> add-apt-repository ppa:lazygit-team/release</span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install lazygit</span><br></pre></td></tr></table></figure><p>然后终端输入<code>lazygit</code>就可以打开了</p><h2 id="ranger"><a class="markdownIt-Anchor" href="#ranger"></a> ranger</h2><p>参考<a href="https://www.zssnp.top/2021/06/03/ranger/">学习博客</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install ranger</span><br></pre></td></tr></table></figure><p>终端输入<code>ranger</code>就可以打开了</p><p>然后创建配置文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ranger --copy-config=all</span><br></pre></td></tr></table></figure><p>编辑<code>~/.config/ranger/rc.conf</code></p><p>个人就修改了几个常用的路径跳转指令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 74行打开预览图片</span><br><span class="line">set preview_images true</span><br><span class="line"></span><br><span class="line">map gd cd ~/Documents</span><br><span class="line">map gD cd ~/Downloads</span><br><span class="line">map gl cd ~/Documents/Latex</span><br><span class="line">map gc cd ~/Documents/Code</span><br></pre></td></tr></table></figure><p>预览图片需要安装<code>w3m-img</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install w3m-img</span><br></pre></td></tr></table></figure><p>然后添加<code>ranger</code>的文件图标</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/alexanderjeurissen/ranger_devicons ~/.config/ranger/plugins/ranger_devicons</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;default_linemode devicons&quot;</span> &gt;&gt; <span class="variable">$HOME</span>/.config/ranger/rc.conf</span><br></pre></td></tr></table></figure><p>安装<code>highlight</code>以启动<code>ranger</code>的代码预览高亮</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install highlight</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 环境部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
            <tag> zsh </tag>
            
            <tag> ranger </tag>
            
            <tag> lazygit </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
